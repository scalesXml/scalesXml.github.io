<?xml version='1.0' encoding='utf-8' ?><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><link href="./scales_base.css" rel="stylesheet" type="text/css" media="screen" /><link href="./site_docs.css" rel="stylesheet" type="text/css" media="screen" /><link href="./highlight/styles/idea.css" rel="stylesheet" type="text/css" media="screen" /><script src="./jquery.js" type="text/javascript"></script><script src="./highlight/highlight.pack.js" type="text/javascript"></script><script type="text/javascript">
$(function() {
$("pre[class^='language-']").each(function(i,elem) {
  var clazz = $(elem).attr('class');
  var str = elem.innerHTML//.replace(/\r\n|\r|\n/g,"<br/>");
  // Workaround for IE <PRE> innerHTML normalization quirk
  if (elem.tagName == "PRE" && "outerHTML" in elem)
    {
      elem.outerHTML = "<PRE><CODE class='"+clazz+"'>" + str + "</CODE></PRE>";
    }
  else
    {
      elem.innerHTML = "<CODE class='"+clazz+"'>" + str + "</CODE>"; //.replace(/\r\n|\r|\n/g,"<br/>");;
    }
});
  hljs.initHighlighting();
//$("pre[class^='language-']").each(function(i, e) {hljs.highlightBlock(e)});
});
</script>
</head><body><h1 id="Introduction">Introduction</h1><p>Scales SBT Plugins is a collection of plugins providing wiki building (for user docs), linking of scala docs to sxr higlighted source, showing of test results in a pretty html form with stack linking to sxr highlighted source and a few other odds and ends.</p><p>Add to your project Plugins.scala thusly:</p><pre class="language-scala">
  val scalesRepo = "Scales Repo" at "https://scala-scales.googlecode.com/svn/repo"
  val scalesSnapshotRepo = "Scales Snapshot Repo" at "https://scala-scales.googlecode.com/svn/repo-snapshots"

  val scalesPlugins = "scales" % "scales-sbt-plugins" % "0.2.2"
</pre><p>Follow with adding into your project definition:</p><pre class="language-scala">
  import sbt._
  import scales.sbtplugins._ 

  class MyProject(info: ProjectInfo) extends DefaultProject(info) with SurefireTestsProject with SxrWrapper with ScctProject with SiteProject with TestReviewer
  {
	
    val sxr = "org.scala-tools.sxr" % "sxr_2.8.0" % "0.2.6"

    // Can be List() if you don't want to (or don't yet have any) files to show.
    val siteMarkupDocs = List("YourMarkupFileWithoutExtension"-&gt;"The description of your markup file", "AnotherOne"-&gt;"Another one of interest in the index page")

    override def siteMarkupDocHeaders = Map[String, MarkupHeader]( "MarkupFile.mw" -&gt; MarkupHeader("The title of the markup file"))

    // you probably want to override this function with your source controls files
    override def siteIgnore : Iterable[FileFilter] = super.siteIgnore ++ List(GlobFilter("*.your unwanted extensions here"))

    // other user defintions...
  }
</pre><p>And run site-all to get the goods built and present in the site target directory.  Most of the web functionality present in the Scales SBT Project is provided by JQuery.</p><p><b>NOTE:</b> These plugins only run correctly with sbt 0.7.5 due to packageToPublishActions being a Set in earlier versions, although it seems to lead to ivy issues for publish local and sources (don't seem to be easily disabled - might have to filter on the super for package artifacts....)</p><h1 id="Extra_Tasks">Extra Tasks</h1><table border="0" cellpadding="5" cellspacing="0"><tr><th>Task</th><th>Description</th></tr><tr><td>site-docs</td><td>Copies over files from src/site and converts any SbtWiki compatible files to html.</td></tr><tr><td>site</td><td>Runs site-docs, copies over available sites and creates an index based on both the sites and any siteMarukupDocs.</td></tr><tr><td>site-all</td><td>Runs all siteAllActions follwed by site.  Allows handling of tools like scct that require a very specific run order to be compatible with other plugins</td></tr><tr><td>package-site</td><td>Runs site and generates a zip file from the site.  Does not currently rely on site-all but perhaps should...</td></tr><tr><td>deploy-site</td><td>Runs packageSite and copies the resulting files to a local directory (siteDeployFile)</td></tr><tr><td>test-review</td><td>Runs test but ignores failure.  We are interestd in failed tests and want to collect their runs.  It then generates an html report "site" for test navigation.</td></tr><tr><td>doc</td><td>Ok, not strictly new, but now provides SXR based fun.  Each line has a direct link and highlighting and SXR is removed when you don't want it (console or scct runs).</td></tr></table><h1 id="SxrWrapper">SxrWrapper</h1><p>SxrWrapper is composed of three components SxrLineWrapper, SxrRelativeTestUrls and SxrHelper.  SxrLineWrapper adds line highlighting to SXR output, you can use:</p><pre class="language-scala">
	override highlightColour = "bbbbbb"
</pre><p>in hex to change what colour is used to highlight lines.  Adding #l14 to the end of an SXR url highlights that line of code.  This is leveraged by TestReviewer to allow clicking to lines of code from a stack trace.</p><p>SxrRelativeTestUrls adjusts for SXRs need for absolute urls in file links used to map sets of code, in this case allowing click through from test code into the main source code SXR pages.</p><p>SxrHelper is the base functionality, disabling SXR output when used by anything else other than compile and test-compile.  In particular this ensures the correct nesting of packages and source and the ability to link.  At the end of a complile action the file target/**/classes.sxr contains a format suitable for SXR to perform linking of sources.</p><h1 id="DocsWrapper">DocsWrapper</h1><p>This component is included by SiteProject and fixes scaladocs output to show links to the locally generated source, SXR source html (*.scala.html) in particular.  This allows clicking the source links from the generated scaladocs.</p><h1 id="TestReviewer">TestReviewer</h1><p>TestReviewer provides an html view of sbt test runs.  Failures are shown at the top and the results are shown in a collapseable group.  Click to go to a test, all stack traces are, where appropriate, linked to the projects source code with the clicked line highlighted for additional browsing comfort.</p><dl><dd><img title="Test Review Sample" alt="Test Review Sample" border="0" src="img/test-review.png"/></dd></dl><p>TestReviewer also uses SxrHelper to lookup source code artifacts and show line numbers where relevant.</p><p>The following options can be overridden:</p><pre class="language-scala">
  def testReviewTitle = projectOrganization.value+ " : " + artifactID + "-" + projectVersion.value.toString

  def testReviewCSSLocation = resourcesOutDir(this) / "test_review.css"
  def testReviewPNGsLocation = resourcesOutDir(this)
  def testReviewJQueryLocation = siteJQuery
</pre><p>allowing complete customisation of look and feel.  resourcesOutDir is an expanded directory of resources from the plugin jar itself (look in the target/XX directory for the contents).  (The siteCSS base used can only be overridden for the entire site however).</p><h1 id="SbtWiki">SbtWiki</h1><p>This utility module provides conversion of Textile (.textile extension), MediaWiki (.mw and .mwiki extensions) and TracWiki (.trac extensions).  It could be extended to use Confluence pages as well.</p><p>This is all enabled via the eclipse mylyn wikitext project.  Only mediawiki is currently supported as a dependency.  To add the other wiki type support add the relevant wikitext jars to plugin libs.</p><p>The basic conversion operates in two phases - add headers and replace tokens (see <a href="#Tokens">#Tokens</a>.  The headers can be passed in as either a site default (as per copyAndConvert) or per indvidiual file (the other two converts).  All files use utf-8 encoding.</p><p>The site-docs task allows use of MarkupHeaders attached to a given relative file path see <a href="#SiteProject">#SiteProject</a> for more information.</p><p>A further extra feature of mediawiki (again provided by mylyn wikitext) is templates.  They are usable but be warned &lt;nowiki&gt; only seems to function properly on a single line.  Use ${cscala} and ${cend} tokens to wrap syntax highlighted blocks of code and avoid each line being wrapped in &lt;p&gt; elements.</p><h1 id="Tokens">Tokens</h1><p>Tokens (driven by Tokens.scala) are variables with the following format ${variable}.  This expansion can be nested, each expansion expanding nested properties as needed.  Simply add a \ in front of the dollar sign to escape.</p><h1 id="SiteProject">SiteProject</h1><p>This component pulls all the pieces together.  Running site-all creates a site including a good to run locally zip for downloading.  </p><p>By default src/site is used as the root for any site documents (generated with SbtWiki and a call to site-docs) but you can override it with siteResourceDir.  The sites are shown at the top of the page, with any registered siteMarkupDoc:</p><dl><dd><img title="Site Example" alt="Site Example" border="0" src="img/site.png"/></dd></dl><p>There are a number of customisations available:</p><h2 id="*Ignore">*Ignore</h2><pre class="language-scala">
  def siteIngore : Iterable[FileFilter]
</pre><p>provides a list of the default FileFilters to ignore when running site, site-docs and deploy-site.  Each three can be individually overridden with siteDocsIgnore and deploySiteIgnore.</p><p>Of interest is that a given site can also provide site specific ignores via the ignore parameter.</p><h2 id="siteTokens">siteTokens</h2><pre class="language-scala">
  def siteTokens : Map[String, ()=&gt;String]
</pre><p>provides access to customising what Tokens are available throughout generated site documents.</p><p>The following default tokens are provided:</p><ul><li>User - username</li><li>timestamp - Default Date.toString</li><li>datetime - default DateFormat.DateTimeInstance format</li><li>artifactID - The projects artifactID</li><li>projectName</li><li>projectVersion</li><li>projectOrganization/projectOrganisation</li><li>FullVersion - {() =&gt; projectOrganization.value+ " : " + artifactID + "-" + projectVersion.value.toString}</li><li>cscala - start of a scala block of code</li><li>cxml - start of an xml block</li><li>cjava - start of a java code block</li><li>cend - end any code block</li></ul><p>plus all system and environmental properties</p><h3 id="Mediaw_Wiki_templates">Mediaw Wiki templates</h3><p>A mediawiki specific token system is templates.  You can register new templates with siteMediaWikiTemplates.  Be warned wikitext doesn't seem to respect templates across newlines, so the provided {{code template isn't that useful.</p><h2 id="Source_Syntax_Highlighting">Source Syntax Highlighting</h2><p>All syntax highlighting of source blocks in SiteProject are driven by highlight.js.  To change the scripts used replace the highlightScripts function.  If the system does not use </p><pre class="language-xml">
  &lt;pre&gt;
    &lt;code class="language-scala"&gt;
   the code
    &lt;/code&gt;
  &lt;pre&gt;
</pre><p>then you can also replace the cbs and cend functions to match your source highlighter.</p><p>What is more expected is to want to use a different css for displaying the source, overriding siteHighlightStyle does just that.</p><p>A future version might stop copying over highlight as well when "disabled".</p><p>Note, due to mediawiki / wikitext processing and a tonne of IE insanity the wrapping of &lt;code&gt; blocks only takes place in the browser (driven by highlightScripts).</p><h2 id="siteHeaders">siteHeaders</h2><p>SiteHeaders provides a site wide override mechanism for deciding what is in each of the generated wiki files headers.  You can add new libaries here, or a meta-equiv or two.</p><h2 id="siteMarkupDocs">siteMarkupDocs</h2><p>Any site/project documentation you want to appear in the main site index goes here.  Use relative filenames with a base of the site directory as ._1.  The ._2 part is the description of the file used by index.html.</p><h2 id="siteMarkupDocHeaders">siteMarkupDocHeaders</h2><p>Each converted wiki file can supply its own title and other extraHeaders.  If you create the MarkupHeader with overrideHeader set to true then <b>only</b> the extraHeaders from thie MarkupHeader will be used, and the siteHeaders ignored.</p><h2 id="deploy-site">deploy-site</h2><p>The deploy site task copies the site to a location on the local machine - for example an svn or git backed directory.</p><p>Overriding getSiteDeployFile will control where (relative to the current project) the site will be copied to.  It does not allow changing the mechanism used for deploying but allows a degree of customisation.</p><p>To fundementally change how the site is deployed override the deploySiteAction, the task simply copies the site and site.zip.</p><p>getSitePublishRelative is used to identify what path it should add to the root of siteDeployFile.  Currently it uses the project organisation, artificat id and project version to create the path.</p><h2 id="Sites">Sites</h2><p>The basis of SiteProject is that it groups other sub sites, like Maven site does on the left panel.  Currently the following sites are configured:</p><ul><li>Scala X-Ray - shows the main and test classes</li><li>Scaladocs - shows the "linked to sxr" scaladocs</li><li>SCCT - shows the coverage reports (if enabled as a plugin) for the project</li><li>Surefire Reports - shows the surefire compatible reports (if enabled as a plugin)</li><li>Test Review - shows the TestReviewers output, hyperlinked to the SXR outputs</li></ul><p><br/>
To configure a new sub site override sites and append to super.sites.  A Site is made of a Copy a description and an optional siteLink.  Copy it self simply provides a from and to location, where from is relative to the target directory, when only a from is given then the name will be kept the same. Suprisingly enough when no siteLink is given it defaults to Copy.to/index.html</p><p>The ignore parameter is combined with the siteIgnore list to customise which files are not to be copied to the final site.</p><h2 id="site-all">site-all</h2><p>During development it became painfully clear that the sbt DAG neither allowed ordering nor the concept of a general cleanup function.  You can get around this to an extent but something always stops you.  SBT however provides a far simpler way to chain complex tasks: the command line ; chaining.</p><p>As such SiteProject has simply copied this mechanism.  site-all uses siteAllActions, a simple string seperated by ;.  Its possible that some tasks are allowed to fail and they go in the canFailActions list.</p><p>We want to be able to generate a site if a test is failing, or if a code coverage metric has not been met.  This still provides feedback to the developer.</p><h1 id="Utils">Utils</h1><p>As the name suggests it provides a number of utility functions and a pimp or two. My favourite pimp being the fold and ~~&gt; lazily provided for Options.  SBT makes heavy use of Options for returning error conditions, so typically you use orElse to join parts of your code that may fail.  ~~&gt; simply replaces orElse and gives a nice flow to the code.</p><p>copyDir is a variation on the SBT copy function that does not require a virginal target directory, it will overwrite files as necessary making it ideal for site related tasks - especially when wishing to keep .svn directories around.  It also accepts a filter to stop the copying of .svn files for example.</p><p>copyFiles simply works with an existing directory and adds a list of files to it, folding the resulting Option[String] with ~~&gt;.</p><p>depth measures how deep a directory structure is, this allows easier adjustment of relative paths to and from sxr.  manip is used through out the code base to modify files in place or signal an error.  replaceToken replaces a path token within a file using the depth function to correctly adjust.</p><p>callCommands is used by SiteProject's siteTasks to run ; seperated commands.</p><p>A variety of css and js helpers exist (css, js, title) exist to help create headers.  </p><h1 id="Future_Direction">Future Direction</h1><p>SitePlugin is not multi-module aware, and I'm not planning that for any 0.7.x based release.  I will look at doing that for SBT 0.9 however, given its complete restructuring.  The trick will be knowing what to force on the parent projects.</p><p>I problem that has hit me, and other Maven site users is that occasionally it decideds to upgrade a skin, when a skin is forced on it it must be forced in its parent projects as well, leaving trails of src directories where they don't make sense.</p><p>I'm not interested in repeating such mistakes, but I'm open to ideas on how to balance that.</p><p>Of immediate interest to me is a TODO site.  It will trawl through source code (configurable patterns) and grab the TODO (configurable patterns) and the source line number.  When its an SXR supported source it can hyperlink directly to the line, highlighting the line via SxrLineWrapper.  Non SXR sources must perhaps be simply htmlised (wrap each line in a p pre and hyperlink as per SxrLineWrapper) and displayed.</p></body></html>