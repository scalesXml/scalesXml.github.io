<?xml version='1.0' encoding='utf-8' ?><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=8" /><link href="./scales_base.css" rel="stylesheet" type="text/css" media="screen" /><link href="./site_docs.css" rel="stylesheet" type="text/css" media="screen" /><link href="./highlight/styles/idea.css" rel="stylesheet" type="text/css" media="screen" /><script src="./jquery.js" type="text/javascript"></script><script src="./highlight/highlight.pack.js" type="text/javascript"></script><script type="text/javascript">
$(function() {
$("pre[class^='language-']").each(function(i,elem) {
  var clazz = $(elem).attr('class');
  var str = elem.innerHTML//.replace(/\r\n|\r|\n/g,"<br/>");
  // Workaround for IE <PRE> innerHTML normalization quirk
  if (elem.tagName == "PRE" && "outerHTML" in elem)
    {
      elem.outerHTML = "<PRE><CODE class='"+clazz+"'>" + str + "</CODE></PRE>";
    }
  else
    {
      elem.innerHTML = "<CODE class='"+clazz+"'>" + str + "</CODE>"; //.replace(/\r\n|\r|\n/g,"<br/>");;
    }
});
  hljs.initHighlighting();
});
</script>
<link href="./menubar.css" rel="stylesheet" type="text/css" media="screen" />
  <script type="text/javascript">
  $(function(){

  $('#scales-site-menubar li:has(ul)').toggleClass('menuPlus');
  $('#scales-site-menubar ul').children('li:has(ul)').click(function(event){
            if (this == event.target) {                
                $(this).children('ul').fadeToggle('fast');
		$(this).toggleClass('menuPlus');
		$(this).toggleClass('menuMinus');
            }
	    if ($(event).get(0).target.tagName.toLowerCase() == "a") {
	      return true; // we want links to be clickable
	    } else {
              return false;
	    }
        })
        .children('ul').hide();

});
</script>
</head><body><h1 id="XPath_Embedded_DSL">XPath Embedded DSL</h1><p>The XML XPath specifications allows navigation of XML documents via a DSL that describes routes through a document using a combination of axe, steps and predicates.  It has a limited number of these abstractions but together they create a powerful direct, whilst remaining simple to use, querying language.</p><p>Scales provides this power via both a traditional string based approach and an embedded DSL that leverages the power of Scalas syntactical flexibility to mimic the XPath syntax.</p><p>The DSL uses the existing Scales abstractions to the full, and works via a zipper over the XmlTree itself.  Each navigation step through the tree creates new zippers and new paths through the tree.</p><p>In every case possible (with the exception of the namespace:: axis) the range of behaviours closely follows the specification, like for like queries matching 100%.  Instead of matching on prefixes Scales uses fully qualified expanded QNames (qualifiedName in the <a href="XPathFunctions.html#QName_Functions">QName Functions</a>) to match against, not requiring a prefix context within which to evaluate.</p><p>Internally, perhaps unsurprisingly, XPath is implemented as a combination of filter, map and flatMap.  When retrieving results (e.g. converting to an Iterable) the results are sorted into Document order, this can be expensive for large result sets (see <a href="#Unsorted_Results_and_Views">Unsorted Results</a> for alternatives).</p><h2 id="Simple_Usage_Examples">Simple Usage Examples</h2><p>Given the following document:</p><pre class="language-scala">
  val ns = Namespace("test:uri")
  val nsa = Namespace("test:uri:attribs")
  val nsp = nsa.prefixed("pre")

  val builder = 
    ns("Elem") /@ (nsa("pre", "attr1") -&gt; "val1",
      	    	   "attr2" -&gt; "val2",
		   nsp("attr3") -&gt; "val3") /(
      ns("Child"),
      "Mixed Content",
      ns("Child2") /( ns("Subchild") ~&gt; "text" )
    )
</pre><p>we can easily query for the Subchild:</p><pre class="language-scala">
  // top produces a Path from a Tree, in this case an XPath
  val path = top(builder)

  val res = path \* ns("Child2") \* ns("Subchild")
  res.size // 1

  string(res) // text
  qname(res) // Subchild
</pre><h2 id="XPath_Crash_Course">XPath Crash Course</h2><p>Scales Xml follows the XPath spec fairly closely and accordingly represents the concepts of context, location steps and axe, full details of which can be found in the <a href="http://www.w3.org/TR/xpath20/#id-path-expressions">XPath Standard</a>.</p><p>The context, which can be thought of as current "place" in the document, is represented by the following:</p><ul><li>a notional node - where we are in the document - an element, a text node, an attribute etc.</li><li>the position - index within a context and the size of this context</li></ul><p>Location steps are a combination of axe, node test and predicates e.g. /*fred which represents the child axe, element node test and a predicate against a no-namespace local name of "fred".</p><p>As the XPath adds more axe, steps and predicates the context changes, reducing or expanding possible matches as it develops.  Scales Xml's XPath DSL represents that context with the <a href="./doc/scales/xml/xpath.XPath.html">XPath</a> class, where each operation on that class returns another immutable instance for the next context.</p><p>As with XPath, Scales Xml predicates, axe and node tests can be chained with the current context (the self axe in XPath) always represented by the resulting Scales XPath object.  Only when the underlying results are used (for example by string or qname functions) do they leave the XPath object and get transformed into a, by default, ordered list of matching nodes.</p><h2 id="XPath_Axe">XPath Axe</h2><p>Scales supports the complete useful XPath axe, each of which can be used against a given context (an instance of <a href="./doc/scales/xml/xpath/XPath.html">Scales XPath</a>), for the full XPath axe details find the spec <a href="http://www.w3.org/TR/xpath20/#axes">here</a>:</p><table class="genTable"><tr><th>XPath Axis</th><th>Scales DSL</th><th>Details</th></tr><tr><td>ancestor</td><td>ancestor_::</td><td>All the parents of this context</td></tr><tr><td>ancestor-or-self</td><td>ancestor_or_self::</td><td>All the parents of this context and this node</td></tr><tr><td>attribute</td><td>*@</td><td>All the attributes for a given context, is often combined directly with a name</td></tr><tr><td>child</td><td>\ or \+ to expand XmlItems</td><td>Children of this context. NB: \ alone in Scales DSL simply removes the initialNode setting required by \\.  If the children should be expanded (e.g. to use .filter directly) then \+ will "unpack" the child nodes.</td></tr><tr><td>descendant</td><td>descendant_::</td><td>All children, and their children</td></tr><tr><td>descendant-or-self</td><td>descendant_or_self_::</td><td>This node and all descendants, also known as \\</td></tr><tr><td>following</td><td>following_::</td><td>All nodes that follow this context in document order without child nodes of this context</td></tr><tr><td>following-sibling</td><td>following_sibling_::</td><td>All direct children of this contexts parent node that follow in document order.</td></tr><tr><td>parent</td><td>\^</td><td>The parent context of this context.  For elements it represents the parent eleemnt and for attributes the containing element.</td></tr><tr><td>preceding</td><td>preceding_::</td><td>All nodes that precede this context in document order excluding the parent nodes</td></tr><tr><td>preceding-sibling</td><td>preceding_sibling_::</td><td>All previous children of the parent in the current context in document order.</td></tr><tr><td>self</td><td>The XPath object itself via <b>.</b></td><td>The current context node within a document.</td></tr></table><p>A commonly used abbreviation not listed above is of course \\, which means descendant_or_self_::.  The difference being that \\ also supports possible eager evaluation and as per the spec the notion of <a href="http://www.w3.org/TR/xpath20/#id-path-expressions">\\ in the beginning expression</a>.</p><p><i>NB Scales Embedded XPath DSL does not support the namespace axis - if you have a requirement for it then it can be looked at (please send an email to <a href="mailto:scales-xml@googlegroups.com">the mailing list</a> to discuss possible improvements)</i></p><h2 id="Node_Tests">Node Tests</h2><p>Scales embedded XPath DSL views the majority of node tests as predicates</p><table class="genTable"><tr><th>XPath Node Test</th><th>Scales DSL</th><th>Details</th></tr><tr><td>node()</td><td>.\+</td><td>Returns a new context for all the children below a given context</td></tr><tr><td>text()</td><td>.text</td><td>Returns a new context for all the text and cdata below a given context</td></tr><tr><td>comment()</td><td>.comment</td><td>Returns a new context for all the comments below a given context</td></tr></table><p>Scales XML also adds:</p><ul><li>.textOnly - filters out CData, just giving text nodes</li><li>.cdata - provides CData nodes</li><li>.pi - provides processing instructions</li></ul><h2 id="Predicates">Predicates</h2><p>There are three areas allowing for predicates within XPaths:</p><ul><li>Attributes</li><li>Elements</li><li>General</li></ul><p>The first two are special cased, as in the XPath spec, as they are the most heavily used predicates (using the above example document):</p><pre class="language-scala">
  // QName based match
  val attributeNamePredicates = path \@ nsp("attr3")
  string(attributeNamePredicates) // "val3"
  
  // predicate based match
  val attributePredicates = path \@ ( string(_) == "val3" )
  qualifiedName(attributePredicates) // {test:uri:attribs}attr3

  // Find child descendants that contain a Subchild 
  val elemsWithASubchild = path \\* ( _ \* ns("Subchild"))
  string(elemsWithASubchild) // text
  qualifiedName(elemsWithASubchild) // {test:uri}Child2
</pre><p>In each case the XmlPath (or AttributePath) is passed to the predicate with a number of shortcuts for the common QName based matches and positional matches for elements:</p><pre class="language-scala">
  val second = path \*(2) // path \* 2 is also valid but doesn't read like \*[2]
  qname(second) // Child2
</pre><p>The developer can chose to ignore namespaces (not recommended) by using the *:* and *:@ predicates instead (equivalent to string xpath /*<a href="local-name()">= "x"</a>).</p><h3 id="Predicate_Construction">Predicate Construction</h3><p>All the predicates in Scales are built from two simple building blocks:</p><ol><li>XmlPath =&gt; Boolean - via the XPath.filter function</li><li>AttributePath =&gt; Boolean - via the <a href="./doc/scales/xml/xpath/AttributeAxis.html">AttributeAxis</a>.*@ function</li></ol><p>The various base node types and filters are based on these functions, for example the element predicate * is implemented as:</p><pre class="language-scala">
def *(pred : XmlPath =&gt; Boolean) : XPath[T] = 
  filter(x =&gt; x.isItem == false &amp;&amp; pred(x))
</pre><p>In turn \* can be seen as a combination of the \ child step and the * predicate (via xflatMap) and is provided as syntactic sugar.</p><p>Similarly text is implemented using filter.</p><p>All of the standard set of predicates (and axis combinations) can be found in the <a href="./doc/scales/xml/xpath/XPath.html">XPath</a> ScalaDoc.  Clicking the right arrow for many of the functions will lead you to the Definition Classes docs and their code. </p><h3 id="Chaining_Predicates">Chaining Predicates</h3><p>Predicates can be chained on the context itself, i.e. the XPath object, for example:</p><pre class="language-scala">
val pathsCombinedPredicates =
    root.\*(ns("Child")).
      *(_.\@( nsp("attr3") )) // context is still Child matches, but has additionally reduced it to only items with an attribute of attr3
</pre><p>This represents /root/*ns:Child[.\@nsp:attr3] where the * Scales Xml element predicate allows matching on the self axis.  The same chaining is available on the attribute axis represented by the <a href="./doc/scales/xml/xpath/AttributePaths.html">AttributePaths</a> class.</p><h3 id="Positional_Predicates">Positional Predicates</h3><table class="genTable"><tr><th>XPath Position Function</th><th>Scales DSL</th><th>Details</th></tr><tr><td>position()</td><td>pos_&lt;, pos_==, pos() and pos_&gt;</td><td>Functions to work against the current position within a context</td></tr><tr><td>last()</td><td>last_&lt;, last_== and last_&gt;</td><td>Functions that work against the size of a given context</td></tr><tr><td>position() == last()</td><td>pos_eq_last</td><td>Take the last item in a context</td></tr></table><p>These, more difficult to model, positional tests can be leveraged the same way as position() and last() can be in XPath.</p><p>So, for example:</p><pre class="language-scala">
  // /*[position() = last()]
  val theLast = path.\.pos_eq_last
  qname(theLast) // Elem

  // //*[position() = last()]
  val allLasts = path.\\*.pos_eq_last
  allLasts map(qname(_)) // List(Elem, Child2, Subchild)

  // all elems with more than one child
  // //*[ ./*[last() &gt; 1]]
  val moreThanOne = path.\\*( _.\*.last_&gt;(1) )
  qname(moreThanOne) // Elem

  // all elems that aren't the first child
  // //*[ position() &gt; 1]
  val notFirst = path.\\*.pos_&gt;(1)
  qname(notFirst) // Child2
</pre><h3 id="Direct_Filtering">Direct Filtering</h3><p>The xflatMap, xmap, xfilter and filter methods allow extra predicate usage where the existing XPath 1.0 functions don't suffice.</p><p>The filter method accepts a simple XmlPath =&gt; Boolean, whereas the other varieties work on the matching sets themselves.</p><p>It is not recommended to use these functions for general use as they primarily exist for internal re-use.</p><h2 id="Unsorted_Results_and_Views">Unsorted Results and Views</h2><p>In order to meet XPath expected usage results are sorted in Document order and checked for duplicates.  If this is not necessary - but speed of matching over a result set is (for example lazy querying over a large set) - then the raw functions (either raw or rawLazy) are good choices.</p><p>The viewed function however uses views as its default type and may help add further lazy evaluation.  Whilst tests have shown lazy evaluation takes place its worth profiling your application to see if it actually impacts performance in an expected fashion.</p><p>See the <a href="./doc/scales/xml/xpath/XmlPaths.html">XmlPaths trait</a> for more information.</p><div id="scales-site-menubar"><h1 id="Scales_Xml_0.5.0">Scales Xml 0.5.0</h1><h2 id="Generated_Documentation">Generated Documentation</h2><ul><li><a href="./api.sxr/index.html">SXR Source</a></li><li><a href="./doc/index.html">ScalaDocs</a></li></ul><h2 id="Documentation_Highlights">Documentation Highlights</h2><ul><li><a href="./ScalesXmlIntro.html">Overview</a></li><li><a href="./MemoryOptimisation.html">Memory and Performance</a></li></ul><dl><dt><b>First Steps</b><ul><li><a href="Setup.html">Setup</a></li><li><a href="HowToUse.html">How To Use</a></li></ul></dt></dl><dl><dt><b>Xml Model</b><ul><li><a href="QNames.html">QNames</a><ul><li><a href="QNames.html#Creating_QNames">Creating QNames</a><ul><li><a href="QNames.html#Directly">Directly</a></li><li><a href="QNames.html#Implicits">With Sugar</a></li></ul></li><li><a href="QNames.html#Namespaces_.26_Scope">Namespaces &amp; Scope</a></li><li><a href="QNames.html#Namespaces_in_Scales">Namespaces in Scales</a></li><li><a href="QNames.html#QNames_in_Scales_-_Let_the_compiler_help_us">Type System FTW</a></li><li><a href="QNames.html#Runtime_Validation">Runtime Validation</a></li><li><a href="QNames.html#Equality">Equality</a><ul><li><a href="QNames.html#Scalaz_Equal_and_Scales_Equiv">via Scalaz Equal and Scales Equiv</a></li></ul></li><li><a href="QNames.html#Testing_For_QNames">Testing For QNames</a></li><li><a href="QNames.html#Serializing_QNames">Serializing QNames</a></li></ul></li><li><a href="XmlVersionSupport.html">XML Version Support</a><ul><li><a href="XmlVersionSupport.html#Differences_Between_1.0_and_1.1">Differences Between Xml 1.0 and 1.1</a></li><li><a href="XmlVersionSupport.html#How_Does_Scales_Allow_Both_Versions_.3F">Scales Support for Both Versions</a><ul><li><a href="XmlVersionSupport.html#In_Parser_We_Trust_-_Users_We_Protect">In Parser We Trust - Users We Protect</a></li><li><a href="XmlVersionSupport.html#Runtime_XmlVersion_QName_Related_Correctness">Runtime XmlVersion QName Related Correctness</a></li></ul></li></ul></li><li><a href="Attributes.html">Attributes</a><ul><li><a href="Attributes.html#Defining_an_Attribute">Defining</a><ul><li><a href="Attributes.html#Explicitly">Explicitly</a></li><li><a href="Attributes.html#Implicitly">Implicitly</a></li></ul></li><li><a href="Attributes.html#Equality">Equality</a><ul><li><a href="Attributes.html#Within_an_Elem">Within an Elem</a></li><li><a href="Attributes.html#Attributes_ListSet">Attributes ListSet</a></li></ul></li><li><a href="Attributes.html#Testing_Against_QNames_or_Namespaces">Testing Against QNames or Namespaces</a></li></ul></li><li><a href="Elem.html">Elem</a><ul><li><a href="Elem.html#XML_Elements">XML Elements</a></li><li><a href="Elem.html#Declaring">Declaring</a></li><li><a href="Elem.html#QName_And_Namespace_Correctness">QName And Namespace Correctness</a></li><li><a href="Elem.html#Elems_Are_Reusable">Elems Are Reusable</a></li><li><a href="Elem.html#Runtime_Validation_Checks">Runtime Validation Checks</a></li></ul></li><li><a href="XmlItem.html">XmlItem</a><ul><li><a href="XmlItem.html#Declaring">Declaring</a></li><li><a href="XmlItem.html#XmlItems_Are_Reusable">XmlItems Are Reusable</a></li><li><a href="XmlItem.html#Runtime_Correctness_Checks">Runtime Correctness Checks</a></li><li><a href="XmlItem.html#Serializing_XmlItems">Serializing XmlItems</a><ul><li><a href="XmlItem.html#Serializing_CData">Serializing CData</a></li></ul></li></ul></li><li><a href="XmlDsl.html">Xml DSL and Trees</a><ul><li><a href="XmlDsl.html#Tour_of_the_DSL">Tour of the DSL</a></li><li><a href="XmlDsl.html#Creating_a_Tree">Creating a Tree</a></li><li><a href="XmlDsl.html#Adding_To_The_Tree">Adding To The Tree</a></li><li><a href="XmlDsl.html#Adding_an_Attribute">Adding an Attribute</a></li><li><a href="XmlDsl.html#Setting_Text">Setting Text</a></li><li><a href="XmlDsl.html#Removing_Children">Removing Children</a></li><li><a href="XmlDsl.html#Removing_Attributes">Removing Attributes</a></li><li><a href="XmlDsl.html#Optional_XML">Optional XML</a></li><li><a href="XmlDsl.html#Folding_Within_The_DSL">Folding Within The DSL</a></li></ul></li><li><a href="OptionalDsl.html">Optional Xml DSL</a><ul><li><a href="OptionalDsl.html#Cascading_Optionals">Cascading Optionals</a></li></ul></li></ul></dt></dl><dl><dt><b>Accessing and Querying Data</b><ul><li><a href="XPaths.html">XPath Embedded DSL</a><ul><li><a href="XPaths.html#Simple_Usage_Examples">Simple Usage Examples</a></li><li><a href="XPaths.html#XPath_Crash_Course">XPath Crash Course</a></li><li><a href="XPaths.html#XPath_Axe">XPath Axe</a></li><li><a href="XPaths.html#Node_Tests">Node Tests</a></li><li><a href="XPaths.html#Predicates">Predicates</a><ul><li><a href="XPaths.html#Predicate_Construction">Predicate Construction</a></li><li><a href="XPaths.html#Chaining_Predicates">Chaining Predicates</a></li><li><a href="XPaths.html#Positional_Predicates">Positional Predicates</a></li><li><a href="XPaths.html#Direct_Filtering">Direct Filtering</a></li></ul></li><li><a href="XPaths.html#Unsorted_Results_and_Views">Unsorted Results and Views</a></li></ul></li><li><a href="XPathFunctions.html">XPath Functions</a><ul><li><a href="XPathFunctions.html#Organisation">Organisation</a></li><li><a href="XPathFunctions.html#QName_Functions">QName Functions</a></li><li><a href="XPathFunctions.html#Text_Functions">Text Functions</a></li><li><a href="XPathFunctions.html#Boolean_Function">Boolean Function</a></li></ul></li><li><a href="StringXPaths.html">XPath 1.0 String Evaluation</a><ul><li><a href="StringXPaths.html#How_To_Use">How To Use</a></li><li><a href="StringXPaths.html#Other_Jaxen_Tricks">Other Jaxen Tricks</a></li></ul></li></ul></dt></dl><dl><dt><b>Parsing XML</b><ul><li><a href="FullParsing.html">Full XML Doc Parsing</a><ul><li><a href="FullParsing.html#Direct_SAX_XMLReader_Usage">Direct SAX XMLReader Usage</a></li></ul></li><li><a href="PullParsing.html">Pull Parsing</a><ul><li><a href="PullParsing.html#Pull_Model">Pull Model</a></li><li><a href="PullParsing.html#Resource_Management">Resource Management</a></li><li><a href="PullParsing.html#Simple_Reading_Of_Repeated_Sections">Simple Reading Of Repeated Sections</a></li><li><a href="PullParsing.html#Buffering_And_Identifying_Xml_Messages">Buffering And Identifying Xml Messages</a></li></ul></li><li><a href="RepeatedSections.html">Pulling Repeated Sections</a><ul><li><a href="RepeatedSections.html#Supported_Repeating_Section_Examples">Supported Repeating Section Examples</a><ul><li><a href="RepeatedSections.html#alternating_and_Repeating_Elements">Alternating and Repeating Elements</a></li><li><a href="RepeatedSections.html#Grouped_Repeating">Grouped Repeating</a></li><li><a href="RepeatedSections.html#Repeating_Nested">Repeating Nested</a></li><li><a href="RepeatedSections.html#Sectioned_Grouped_Repeated">Sectioned Grouped Repeating</a></li></ul></li><li><a href="RepeatedSections.html#Pull_Parsing_ResumableIter.27atees">Pull Parsing ResumableIter'atees</a></li></ul></li><li><a href="AsyncPull.html">Async Pull</a><ul><li><a href="AsyncPull.html#Integrating_With_Enumeratees_-_enumToMany">Integrating With Enumeratees - enumToMany</a></li><li><a href="AsyncPull.html#Async_Pull_with_enumToMany">Asyc Pull with enumToMany</a></li></ul></li></ul></dt></dl><dl><dt><b>Serializing &amp; Transforming XML</b><ul><li><a href="SerializingIntro.html">Serializing</a><ul><li><a href="SerializingIntro.html#writeTo_.26_writeTo">writeTo &amp; writeTo</a></li><li><a href="SerializingIntro.html#What_Can_Be_Serialized.3F">What Can Be Serialized?</a></li></ul></li><li><a href="Folding.html">Folding Xml</a><ul><li><a href="Folding.html#PathFoldR_-_Catchy_Result_Type">PathFoldR - Catchy Result Type</a></li><li><a href="Folding.html#Composing_Transformations">Composing Transformations</a><ul><li><a href="Folding.html#ReplaceWith_-_Nested"> ReplaceWith - Nested</a></li><li><a href="Folding.html#.26_-_Fail_Early">&amp; - Fail Early</a></li><li><a href="Folding.html#.7C_-_Try_The_Next">| - Try The Next</a></li></ul></li></ul></li><li><a href="XSLT.html">TrAX &amp; XSLT Support</a><ul><li><a href="XSLT.html#Simple_Usage_Example">Simple Usage Example</a></li></ul></li></ul></dt></dl><dl><dt><b>Xml Equality</b><ul><li><a href="EqualityBasics.html">Xml Equality Basics</a><ul><li><a href="EqualityBasics.html#How_To_Use">How To Use</a></li><li><a href="EqualityBasics.html#Types_Covered">Types Covered</a></li><li><a href="EqualityBasics.html#Why_Join_Adjacent_Text_and_CData.3F">Why Join Adjacent Text and CData?</a></li><li><a href="EqualityBasics.html#Removing_Comments_And_PIs">Removing Comments and PIs</a></li><li><a href="EqualityBasics.html#Why_Not_Use_Canonical_Xml.3F">Why Not Use Canonical Xml?</a></li></ul></li><li><a href="XmlComparison.html">XmlComparison - Where Is It Different?</a><ul><li><a href="XmlComparison.html#The_compare_Function">The compare Function</a><ul><li><a href="XmlComparison.html#The_calculate_Parameter">The calculate Parameter</a></li><li><a href="XmlComparison.html#ComparisonContext">ComparisonContext</a></li><li><a href="XmlComparison.html#Return_Value">Return Value</a></li></ul></li><li><a href="XmlComparison.html#XmlDifference">XmlDifference</a></li><li><a href="XmlComparison.html#QName_Token_Handling">QName Token Handling</a></li></ul></li></ul></dt></dl><dl><dt><b>Technical Details</b><ul><li><a href="MemoryOptimisation.html">Memory Optimisation</a><ul><li><a href="MemoryOptimisation.html#Disclaimer">Disclaimer</a></li><li><a href="MemoryOptimisation.html#Introduction">Introduction</a></li><li><a href="MemoryOptimisation.html#Options_for_memory_optimisation">Options for memory optimisation</a></li><li><a href="MemoryOptimisation.html#Resulting_Sizes">Resulting Sizes</a></li><li><a href="MemoryOptimisation.html#Memory_Consumption_During_Parsing">Memory Consumption During Parsing</a></li><li><a href="MemoryOptimisation.html#Overall_Parsing_Performance">Overall Parsing Performance</a></li><li><a href="MemoryOptimisation.html#Special_Case_-_Pull_Parsing_via_onQNames">Special Case - Pull Parsing via onQNames</a></li></ul></li><li><a href="OptimisationDetails.html">General Memory Optimisation Details</a><ul><li><a href="OptimisationDetails.html#ImmutableArrayProxy">ImmutableArrayProxy</a></li><li><a href="OptimisationDetails.html#EitherLike">EitherLike</a></li><li><a href="OptimisationDetails.html#TreeOptimisation">TreeOptimisation</a></li><li><a href="OptimisationDetails.html#QName_and_Elem_Memory_Usage">QName and Elem Memory Usage</a></li><li><a href="OptimisationDetails.html#TreeProxies_and_Builders">TreeProxies and Builders</a></li></ul></li><li><a href="Serialization.html">Serializing Details</a><ul><li><a href="Serialization.html#Encoding">Encoding</a><ul><li><a href="Serialization.html#XML_Names">XML Names</a></li><li><a href="Serialization.html#Text_Data">Text Data</a></li><li><a href="Serialization.html#Other_Markup_Character_Data">Other Markup Character Data</a></li></ul></li><li><a href="Serialization.html#Creating_a_SerializerFactory">Creating a SerializerFactory</a></li></ul></li></ul></dt></dl></div></body></html>