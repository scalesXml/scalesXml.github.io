<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>scales\utils\collection\Trees.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> scales.utils.collection

<span class="keyword">import</span> scala.collection.IndexedSeqLike
<span class="keyword">import</span> scala.collection.generic.CanBuildFrom

<span class="keyword">import</span> scales.utils.<span class="delimiter">{</span>LeftLike, RightLike, EitherLike<span class="delimiter">}</span>

<span class="keyword">trait</span> <a title="trait Trees extends AnyRef" id="scales.utils.collection;Trees">Trees</a> <span title="Unit" class="delimiter">{</span>

  <span class="keyword">type</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]]scales.utils.EitherLike[Item,scales.utils.collection.Tree[Item,Section,CC]]" id="scales.utils.collection;Trees;ItemOrTree">ItemOrTree</a><span class="delimiter">[</span><a title=" &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]]" id="scales.utils.collection;Trees;ItemOrTree;Item">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection;Trees;ItemOrTree;Section">Section</a>, <a title="[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="scales.utils.collection;Trees;ItemOrTree;CC">CC</a><span class="delimiter">[</span><a title="" id="scales.utils.collection;Trees;ItemOrTree;CC;X">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> = <a href="../EitherLike.scala.html#scales.utils;EitherLike" title="scales.utils.EitherLike[Item,scales.utils.collection.Tree[Item,Section,CC]]">EitherLike</a><span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>

  <span class="comment">/** badly named the boolean should indicate if it has any children */</span>
  <span class="keyword">type</span> <a title="[Item, Section]Either[Item,scales.utils.collection.SectionWalk[Section]]" id="scales.utils.collection;Trees;ItemOrSectionWalk">ItemOrSectionWalk</a><span class="delimiter">[</span><a title="" id="scales.utils.collection;Trees;ItemOrSectionWalk;Item">Item</a>, <a title="" id="scales.utils.collection;Trees;ItemOrSectionWalk;Section">Section</a><span class="delimiter">]</span> = <span title="Either[Item,scales.utils.collection.SectionWalk[Section]]">Either</span><span class="delimiter">[</span>Item, SectionWalk<span class="delimiter">[</span>Section<span class="delimiter">]</span><span class="delimiter">]</span>

  <span class="keyword">type</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]]scala.collection.generic.CanBuildFrom[CC[_],Trees.this.ItemOrTree[Item,Section,CC],CC[Trees.this.ItemOrTree[Item,Section,CC]]]" id="scales.utils.collection;Trees;TreeCBF">TreeCBF</a><span class="delimiter">[</span><a title=" &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]]" id="scales.utils.collection;Trees;TreeCBF;Item">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection;Trees;TreeCBF;Section">Section</a>, <a title="[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="scales.utils.collection;Trees;TreeCBF;CC">CC</a><span class="delimiter">[</span><a title="" id="scales.utils.collection;Trees;TreeCBF;CC;X">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> = <span title="scala.collection.generic.CanBuildFrom[CC[_],Trees.this.ItemOrTree[Item,Section,CC],CC[Trees.this.ItemOrTree[Item,Section,CC]]]">CanBuildFrom</span><span class="delimiter">[</span>CC<span class="delimiter">[</span>_<span class="delimiter">]</span>, ItemOrTree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, CC<span class="delimiter">[</span>ItemOrTree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span>

  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]], A](a: A)(folder: (Trees.this.ItemOrSectionWalk[Item,Section], A) =&gt; A)(tree: scales.utils.collection.Tree[Item,Section,CC])A" id="scales.utils.collection;Trees.fold">fold</a><span class="delimiter">[</span><a title=" &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]]" id="scales.utils.collection;Trees.fold;Item">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection;Trees.fold;Section">Section</a>, <a title="[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="scales.utils.collection;Trees.fold;CC">CC</a><span class="delimiter">[</span><a title="" id="scales.utils.collection;Trees.fold;CC;X">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection;Trees.fold;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="scales.utils.collection;Trees.fold.a">a</a>: <a href="#scales.utils.collection;Trees.fold;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(Trees.this.ItemOrSectionWalk[Item,Section], A) =&gt; A" id="scales.utils.collection;Trees.fold.folder">folder</a>: <span class="delimiter">(</span>ItemOrSectionWalk<span class="delimiter">[</span>Item, Section<span class="delimiter">]</span>, A<span class="delimiter">)</span> =&gt; A<span class="delimiter">)</span><span class="delimiter">(</span><a title="scales.utils.collection.Tree[Item,Section,CC]" id="scales.utils.collection;Trees.fold.tree">tree</a>: <a href="#scales.utils.collection;Tree" title="scales.utils.collection.Tree[Item,Section,CC]">Tree</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scales.utils.collection;Trees.fold;A" title="A">A</a> =
    <a href="#scales.utils.collection;Trees.fold.tree" title="scales.utils.collection.Tree[Item,Section,CC]">tree</a>.<a href="#scales.utils.collection;Tree.fold(911488d4b4)" title="(a: A)(folder: (scales.utils.ItemOrSectionWalk[Item,Section], A) =&gt; A)A">fold</a><span class="delimiter">(</span><a href="#scales.utils.collection;Trees.fold.a" title="A">a</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scales.utils.collection;Trees.fold.folder" title="(Trees.this.ItemOrSectionWalk[Item,Section], A) =&gt; A">folder</a><span class="delimiter">)</span>

<span class="delimiter">}</span>

<span title="AnyRef" class="keyword">import</span> scales.utils.<span class="delimiter">{</span>ItemOrTree, ItemOrSectionWalk<span class="delimiter">}</span>

<span class="comment">/**
 * IF hasChildren then isStart indicates that this particular occurence
 * is the start of the element or the end
 *
 * @author Chris
 *
 */</span>
<span class="keyword">case class</span> <a href="#scales.utils.collection;SectionWalk.productElement.x$1" title="class SectionWalk[Section] extends AnyRef with Product with Serializable" id="scales.utils.collection.SectionWalk.readResolve">SectionWalk</a><span class="delimiter">[</span><a title="" id="scales.utils.collection.SectionWalk.apply$default$3;Section">Section</a><span class="delimiter">]</span><a href="#scales.utils.collection.SectionWalk.readResolve" title="Product" class="delimiter">(</a><a title="Section" id="scales.utils.collection;SectionWalk.section">section</a>: <a href="#scales.utils.collection.SectionWalk.apply$default$3;Section" title="Section">Section</a>, <a title="Boolean" id="scales.utils.collection.SectionWalk.apply$default$2">hasChildren</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span>, <a title="Boolean" id="scales.utils.collection.SectionWalk.apply$default$3">isStart</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>


<span class="keyword">object</span> <a title="scales.utils.collection.Tree.type" id="scales.utils.collection.Tree">Tree</a> <a href="#scales.utils.collection.Tree" title="scales.utils.collection.Tree.type" class="delimiter">{</a>
  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]], Section, CC[C] &lt;: scala.collection.IndexedSeqLike[C,CC[C]]](isection: Section, ichildren: CC[scales.utils.ItemOrTree[Item,Section,CC]])scales.utils.collection.Tree[Item,Section,CC]" id="scales.utils.collection.Tree.apply">apply</a><span class="delimiter">[</span><a title=" &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]]" id="scales.utils.collection.Tree.apply;Item">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection.Tree.apply;Section">Section</a>, <a title="[C] &lt;: scala.collection.IndexedSeqLike[C,CC[C]]" id="scales.utils.collection.Tree.apply;CC">CC</a><span class="delimiter">[</span><a title="" id="scales.utils.collection.Tree.apply;CC;C">C</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>C, CC<span class="delimiter">[</span>C<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="Section" id="scales.utils.collection.Tree.apply.isection">isection</a>: <a href="#scales.utils.collection.Tree.apply;Section" title="Section">Section</a>, <a title="CC[scales.utils.ItemOrTree[Item,Section,CC]]" id="scales.utils.collection.Tree.apply.ichildren">ichildren</a>: <a href="#scales.utils.collection.Tree.apply;CC" title="CC[scales.utils.ItemOrTree[Item,Section,CC]]">CC</a><span class="delimiter">[</span>ItemOrTree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> : <a href="#scales.utils.collection;Tree" title="scales.utils.collection.Tree[Item,Section,CC]">Tree</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> = <a href="#scales.utils.collection.Tree.apply;$anon" title="scales.utils.collection.Tree[Item,Section,CC]{}" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scales.utils.collection.Tree[Item,Section,CC]" id="scales.utils.collection.Tree.apply;$anon">Tree</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Section" id="scales.utils.collection.Tree.apply;$anon.section">section</a> = <a href="#scales.utils.collection.Tree.apply.isection" title="Section">isection</a>
    <span class="keyword">val</span> <a title="CC[scales.utils.ItemOrTree[Item,Section,CC]]" id="scales.utils.collection.Tree.apply;$anon.children">children</a> = <a href="#scales.utils.collection.Tree.apply.ichildren" title="CC[scales.utils.ItemOrTree[Item,Section,CC]]">ichildren</a>

    <span class="keyword">def</span> <a title="(section: Section, children: CC[scales.utils.ItemOrTree[Item,Section,CC]])scales.utils.collection.Tree[Item,Section,CC]" id="scales.utils.collection.Tree.apply;$anon.copy">copy</a><span class="delimiter">(</span> <a title="Section" id="scales.utils.collection.Tree.apply;$anon.copy$default$1">section</a> : <a href="#scales.utils.collection.Tree.apply;Section" title="Section">Section</a> = <a href="#scales.utils.collection.Tree.apply;$anon.copy$default$1" title="Section">section</a>, <a title="CC[scales.utils.ItemOrTree[Item,Section,CC]]" id="scales.utils.collection.Tree.apply;$anon.copy$default$2">children</a> : <a href="#scales.utils.collection.Tree.apply;CC" title="CC[scales.utils.ItemOrTree[Item,Section,CC]]">CC</a><span class="delimiter">[</span>ItemOrTree<span class="delimiter">[</span>Item,Section,CC<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#scales.utils.collection.Tree.apply;$anon.copy$default$2" title="CC[scales.utils.ItemOrTree[Item,Section,CC]]">children</a><span class="delimiter">)</span> = <a href="#scales.utils.collection.Tree.apply" title="(isection: Section, ichildren: CC[scales.utils.ItemOrTree[Item,Section,CC]])scales.utils.collection.Tree[Item,Section,CC]">apply</a><span class="delimiter">(</span><a href="#scales.utils.collection.Tree.apply;$anon.copy$default$1" title="Section">section</a>, <a href="#scales.utils.collection.Tree.apply;$anon.copy$default$2" title="CC[scales.utils.ItemOrTree[Item,Section,CC]]">children</a><span class="delimiter">)</span>

  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]], Section, CC[C] &lt;: scala.collection.IndexedSeqLike[C,CC[C]]](t: scales.utils.collection.Tree[Item,Section,CC])Option[(Section, CC[scales.utils.ItemOrTree[Item,Section,CC]])]" id="scales.utils.collection.Tree.unapply">unapply</a><span class="delimiter">[</span><a title=" &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]]" id="scales.utils.collection.Tree.unapply;Item">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection.Tree.unapply;Section">Section</a>, <a title="[C] &lt;: scala.collection.IndexedSeqLike[C,CC[C]]" id="scales.utils.collection.Tree.unapply;CC">CC</a><span class="delimiter">[</span><a title="" id="scales.utils.collection.Tree.unapply;CC;C">C</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>C, CC<span class="delimiter">[</span>C<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span> <a title="scales.utils.collection.Tree[Item,Section,CC]" id="scales.utils.collection.Tree.unapply.t">t</a> : <a href="#scales.utils.collection;Tree" title="scales.utils.collection.Tree[Item,Section,CC]">Tree</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> <span class="delimiter">)</span> : <span title="Option[(Section, CC[scales.utils.ItemOrTree[Item,Section,CC]])]">Option</span><span class="delimiter">[</span><span class="delimiter">(</span>Section, CC<span class="delimiter">[</span>ItemOrTree<span class="delimiter">[</span>Item,Section,CC<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span> = <span title="(x: (Section, CC[scales.utils.ItemOrTree[Item,Section,CC]]))Some[(Section, CC[scales.utils.ItemOrTree[Item,Section,CC]])]">Some</span><span class="delimiter">(</span><span title="(_1: Section, _2: CC[scales.utils.ItemOrTree[Item,Section,CC]])(Section, CC[scales.utils.ItemOrTree[Item,Section,CC]])" class="delimiter">(</span><a href="#scales.utils.collection.Tree.unapply.t" title="scales.utils.collection.Tree[Item,Section,CC]">t</a>.<a href="#scales.utils.collection;Tree.section" title="=&gt; Section">section</a>, <a href="#scales.utils.collection.Tree.unapply.t" title="scales.utils.collection.Tree[Item,Section,CC]">t</a>.<a href="#scales.utils.collection;Tree.children" title="=&gt; CC[scales.utils.ItemOrTree[Item,Section,CC]]">children</a><span class="delimiter">)</span><span class="delimiter">)</span>
<span class="delimiter">}</span>


<span title="AnyRef" class="keyword">trait</span> <a title="trait Tree[Item &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]], Section, CC[C] &lt;: scala.collection.IndexedSeqLike[C,CC[C]]] extends AnyRef with scales.utils.RightLike[Item,scales.utils.collection.Tree[Item,Section,CC]]" id="scales.utils.collection;Tree">Tree</a><span class="delimiter">[</span><a title=" &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]]" id="scales.utils.collection;Tree;Item">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection;Tree;Section">Section</a>, <a title="[C] &lt;: scala.collection.IndexedSeqLike[C,CC[C]]" id="scales.utils.collection;Tree;CC">CC</a><span class="delimiter">[</span><a title="" id="scales.utils.collection;Tree;CC;C">C</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>C, CC<span class="delimiter">[</span>C<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> <span title="Unit" class="keyword">extends</span> <a href="../EitherLike.scala.html#scales.utils;RightLike" title="scales.utils.RightLike[Item,scales.utils.collection.Tree[Item,Section,CC]]">RightLike</a><span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>

  <span class="keyword">def</span> <a title="=&gt; Section" id="scales.utils.collection;Tree.section">section</a>: <a href="#scales.utils.collection;Tree;Section" title="Section">Section</a>
  <span class="keyword">def</span> <a title="=&gt; CC[scales.utils.ItemOrTree[Item,Section,CC]]" id="scales.utils.collection;Tree.children">children</a>: <a href="#scales.utils.collection;Tree;CC" title="CC[scales.utils.ItemOrTree[Item,Section,CC]]">CC</a><span class="delimiter">[</span>ItemOrTree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>

  <span class="keyword">def</span> <a title="(section: Section, children: CC[scales.utils.ItemOrTree[Item,Section,CC]])scales.utils.collection.Tree[Item,Section,CC]" id="scales.utils.collection;Tree.copy">copy</a><span class="delimiter">(</span> <a title="Section" id="scales.utils.collection;Tree.copy$default$1">section</a> : <a href="#scales.utils.collection;Tree;Section" title="Section">Section</a> = <a href="#scales.utils.collection;Tree.copy$default$1" title="Section">section</a>, <a title="CC[scales.utils.ItemOrTree[Item,Section,CC]]" id="scales.utils.collection;Tree.copy$default$2">children</a> : <a href="#scales.utils.collection;Tree;CC" title="CC[scales.utils.ItemOrTree[Item,Section,CC]]">CC</a><span class="delimiter">[</span>ItemOrTree<span class="delimiter">[</span>Item,Section,CC<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#scales.utils.collection;Tree.copy$default$2" title="CC[scales.utils.ItemOrTree[Item,Section,CC]]">children</a><span class="delimiter">)</span> : <a href="#scales.utils.collection;Tree" title="scales.utils.collection.Tree[Item,Section,CC]">Tree</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>

  <span class="keyword">def</span> <a title="[A](a: A)(folder: (scales.utils.ItemOrSectionWalk[Item,Section], A) =&gt; A)A" id="scales.utils.collection;Tree.fold(911488d4b4)">fold</a><span class="delimiter">[</span><a title="" id="scales.utils.collection;Tree.fold(911488d4b4);A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="scales.utils.collection;Tree.fold(911488d4b4).a">a</a>: <a href="#scales.utils.collection;Tree.fold(911488d4b4);A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(scales.utils.ItemOrSectionWalk[Item,Section], A) =&gt; A" id="scales.utils.collection;Tree.fold(911488d4b4).folder">folder</a>: <span class="delimiter">(</span>ItemOrSectionWalk<span class="delimiter">[</span>Item, Section<span class="delimiter">]</span>, A<span class="delimiter">)</span> =&gt; A<span class="delimiter">)</span>: <a href="#scales.utils.collection;Tree.fold(911488d4b4);A" title="A">A</a> = <span class="delimiter">{</span>
    <span class="comment">// @scala.annotation.tailrec can't optimize</span>
    <span class="keyword">def</span> <a title="(a: A, folder: (scales.utils.ItemOrSectionWalk[Item,Section], A) =&gt; A, tree: scales.utils.collection.Tree[Item,Section,CC])A" id="scales.utils.collection;Tree.fold(911488d4b4).ifold">ifold</a><span class="delimiter">(</span><a title="A" id="scales.utils.collection;Tree.fold(911488d4b4).ifold.a">a</a>: <a href="#scales.utils.collection;Tree.fold(911488d4b4);A" title="A">A</a>, <a title="(scales.utils.ItemOrSectionWalk[Item,Section], A) =&gt; A" id="scales.utils.collection;Tree.fold(911488d4b4).ifold.folder">folder</a>: <span class="delimiter">(</span>ItemOrSectionWalk<span class="delimiter">[</span>Item, Section<span class="delimiter">]</span>, A<span class="delimiter">)</span> =&gt; A,
      <a title="scales.utils.collection.Tree[Item,Section,CC]" id="scales.utils.collection;Tree.fold(911488d4b4).ifold.tree">tree</a>: <a href="#scales.utils.collection;Tree" title="scales.utils.collection.Tree[Item,Section,CC]">Tree</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scales.utils.collection;Tree.fold(911488d4b4);A" title="A">A</a> =
      <span class="comment">// match against</span>
      <a href="#scales.utils.collection;Tree.fold(911488d4b4).ifold.tree" title="scales.utils.collection.Tree[Item,Section,CC]">tree</a> <span title="A" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a href="#scales.utils.collection.Tree.unapply" title="(t: scales.utils.collection.Tree[Item,Section,CC])Option[(Section, CC[scales.utils.ItemOrTree[Item,Section,CC]])]">Tree</a><span class="delimiter">(</span><span title="Section">top</span>, <a title="CC[scales.utils.ItemOrTree[Item,Section,CC]]" id="scales.utils.collection;Tree.fold(911488d4b4).ifold.x">x</a><span class="delimiter">)</span> <span class="keyword">if</span> <span class="delimiter">(</span><a href="#scales.utils.collection;Tree.fold(911488d4b4).ifold.x" title="CC[scales.utils.ItemOrTree[Item,Section,CC]]">x</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> =&gt; <a href="#scales.utils.collection;Tree.fold(911488d4b4).ifold.folder" title="(v1: scales.utils.ItemOrSectionWalk[Item,Section], v2: A)A">folder</a><span class="delimiter">(</span><span title="(b: scales.utils.collection.SectionWalk[Section])scala.util.Right[Nothing,scales.utils.collection.SectionWalk[Section]]">Right</span><span class="delimiter">(</span><a href="#scales.utils.collection.SectionWalk.readResolve" title="(section: Section, hasChildren: Boolean, isStart: Boolean)scales.utils.collection.SectionWalk[Section]">SectionWalk</a><span class="delimiter">(</span><span title="Section">top</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#scales.utils.collection;Tree.fold(911488d4b4).ifold.a" title="A">a</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <a href="#scales.utils.collection.Tree.unapply" title="(t: scales.utils.collection.Tree[Item,Section,CC])Option[(Section, CC[scales.utils.ItemOrTree[Item,Section,CC]])]">Tree</a><span class="delimiter">(</span><span title="Section">top</span>, <a title="CC[scales.utils.ItemOrTree[Item,Section,CC]]" id="scales.utils.collection;Tree.fold(911488d4b4).ifold.children">children</a><span class="delimiter">)</span> =&gt;
          <span class="keyword">val</span> <a title="A" id="scales.utils.collection;Tree.fold(911488d4b4).ifold.temp">temp</a> = <a href="#scales.utils.collection;Tree.fold(911488d4b4).ifold.folder" title="(v1: scales.utils.ItemOrSectionWalk[Item,Section], v2: A)A">folder</a><span class="delimiter">(</span><span title="(b: scales.utils.collection.SectionWalk[Section])scala.util.Right[Nothing,scales.utils.collection.SectionWalk[Section]]">Right</span><span class="delimiter">(</span><a href="#scales.utils.collection.SectionWalk.readResolve" title="(section: Section, hasChildren: Boolean, isStart: Boolean)scales.utils.collection.SectionWalk[Section]">SectionWalk</a><span class="delimiter">(</span><span title="Section">top</span>, hasChildren = <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#scales.utils.collection;Tree.fold(911488d4b4).ifold.a" title="A">a</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="A" id="scales.utils.collection;Tree.fold(911488d4b4).ifold.fres">fres</a> = <a href="#scales.utils.collection;Tree.fold(911488d4b4).ifold.children" title="CC[scales.utils.ItemOrTree[Item,Section,CC]]">children</a>.<span title="(z: A)(op: (A, scales.utils.ItemOrTree[Item,Section,CC]) =&gt; A)A">foldLeft</span><span class="delimiter">(</span><a href="#scales.utils.collection;Tree.fold(911488d4b4).ifold.temp" title="A">temp</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="A" id="scales.utils.collection;Tree.fold(911488d4b4).ifold.fres.$anonfun.foldeda">foldeda</a>, <a title="scales.utils.ItemOrTree[Item,Section,CC]" id="scales.utils.collection;Tree.fold(911488d4b4).ifold.fres.$anonfun.iort">iort</a><a href="../EitherLike.scala.html#scales.utils;EitherLike" title="scales.utils.ItemOrTree[Item,Section,CC]" class="delimiter">)</a> =&gt;
            <a href="#scales.utils.collection;Tree.fold(911488d4b4).ifold.fres.$anonfun.iort" title="scales.utils.ItemOrTree[Item,Section,CC]">iort</a>.<a href="../EitherLike.scala.html#scales.utils;EitherLike.fold" title="(fl: Item =&gt; A, fr: scales.utils.collection.Tree[Item,Section,CC] =&gt; A)A">fold</a><span class="delimiter">(</span> 
	      <span class="delimiter">(</span>item : <a href="#scales.utils.collection;Tree;Item" title="Item">Item</a><span class="delimiter">)</span> =&gt; <a href="#scales.utils.collection;Tree.fold(911488d4b4).ifold.folder" title="(v1: scales.utils.ItemOrSectionWalk[Item,Section], v2: A)A">folder</a><span class="delimiter">(</span><span title="(a: Item)scala.util.Left[Item,Nothing]">Left</span><span class="delimiter">(</span><a href="#scales.utils.collection;Tree.fold(911488d4b4).ifold.fres.$anonfun.$anonfun.item" title="Item">item</a><span class="delimiter">)</span>, <a href="#scales.utils.collection;Tree.fold(911488d4b4).ifold.fres.$anonfun.foldeda" title="A">foldeda</a><span class="delimiter">)</span>, 
	      <span class="delimiter">(</span>rtree : <a href="#scales.utils.collection;Tree" title="scales.utils.collection.Tree[Item,Section,CC]">Tree</a><span class="delimiter">[</span>Item,Section,CC<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; <a href="#scales.utils.collection;Tree.fold(911488d4b4).ifold" title="(a: A, folder: (scales.utils.ItemOrSectionWalk[Item,Section], A) =&gt; A, tree: scales.utils.collection.Tree[Item,Section,CC])A">ifold</a><span class="delimiter">(</span><a href="#scales.utils.collection;Tree.fold(911488d4b4).ifold.fres.$anonfun.foldeda" title="A">foldeda</a>, <a href="#scales.utils.collection;Tree.fold(911488d4b4).ifold.folder" title="(scales.utils.ItemOrSectionWalk[Item,Section], A) =&gt; A">folder</a>, <a href="#scales.utils.collection;Tree.fold(911488d4b4).ifold.fres.$anonfun.$anonfun.rtree" title="scales.utils.collection.Tree[Item,Section,CC]">rtree</a><span class="delimiter">)</span>
	    <span class="delimiter">)</span>
          <span class="delimiter">}</span>
          <a href="#scales.utils.collection;Tree.fold(911488d4b4).ifold.folder" title="(v1: scales.utils.ItemOrSectionWalk[Item,Section], v2: A)A">folder</a><span class="delimiter">(</span><span title="(b: scales.utils.collection.SectionWalk[Section])scala.util.Right[Nothing,scales.utils.collection.SectionWalk[Section]]">Right</span><span class="delimiter">(</span><a href="#scales.utils.collection.SectionWalk.readResolve" title="(section: Section, hasChildren: Boolean, isStart: Boolean)scales.utils.collection.SectionWalk[Section]">SectionWalk</a><span class="delimiter">(</span><span title="Section">top</span>, hasChildren = <span title="Boolean(true)" class="keyword">true</span>, isStart = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#scales.utils.collection;Tree.fold(911488d4b4).ifold.fres" title="A">fres</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <a href="#scales.utils.collection;Tree.fold(911488d4b4).ifold" title="(a: A, folder: (scales.utils.ItemOrSectionWalk[Item,Section], A) =&gt; A, tree: scales.utils.collection.Tree[Item,Section,CC])A">ifold</a><span class="delimiter">(</span><a href="#scales.utils.collection;Tree.fold(911488d4b4).a" title="A">a</a>, <a href="#scales.utils.collection;Tree.fold(911488d4b4).folder" title="(scales.utils.ItemOrSectionWalk[Item,Section], A) =&gt; A">folder</a>, <a href="#scales.utils.collection;Tree" title="scales.utils.collection.Tree[Item,Section,CC]" class="keyword">this</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

<span class="delimiter">}</span>

<span class="comment">/*
case class Tree[Item &lt;: LeftLike[Item, Tree[Item, Section, CC]], Section, CC[C] &lt;: IndexedSeqLike[C, CC[C]]](section: Section, children: CC[ItemOrTree[Item, Section, CC]]) extends RightLike[Item, Tree[Item, Section, CC]]
//    (implicit cbf : TreeCBF[Item, Section, CC]) 
{
  def fold[A](a: A)(folder: (ItemOrSectionWalk[Item, Section], A) =&gt; A): A = {
    // @scala.annotation.tailrec can't optimize
    def ifold(a: A, folder: (ItemOrSectionWalk[Item, Section], A) =&gt; A,
      tree: Tree[Item, Section, CC]): A =
      // match against
      tree match {
        case Tree(top, x) if (x.isEmpty) =&gt; folder(Right(SectionWalk(top)), a)
        case Tree(top, children) =&gt;
          val temp = folder(Right(SectionWalk(top, hasChildren = true)), a)
          val fres = children.foldLeft(temp) { (foldeda, iort) =&gt;
            iort.fold( 
	      (item : Item) =&gt; folder(Left(item), foldeda), 
	      (rtree : Tree[Item,Section,CC]) =&gt; ifold(foldeda, folder, rtree)
	    )
          }
          folder(Right(SectionWalk(top, hasChildren = true, isStart = false)), fres)
      }
    ifold(a, folder, this)
  }
}
*/</span>

        </pre>
    </body>
</html>
