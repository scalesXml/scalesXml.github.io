<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>scales\utils\collection\path\PathFolds.scala</title>
        <script type="text/javascript" src="../../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> scales.utils.collection.path

<span class="keyword">import</span> scala.collection.immutable.Stack
<span class="keyword">import</span> scala.collection.IndexedSeqLike
<span class="keyword">import</span> scala.collection.generic.CanBuildFrom

<span class="keyword">import</span> scales.utils.collection.Tree
<span class="keyword">import</span> scales.utils.<span class="delimiter">{</span>PathFoldR, FoldR, LeftLike, deepestLast, top, ItemOrTree, TreeCBF<span class="delimiter">}</span>

<span class="comment">/**
 * Represents the base for operations that fold over a list of paths
 */</span> 
<span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait FoldOperation[Item &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]] extends AnyRef" id="scales.utils.collection.path;FoldOperation">FoldOperation</a><span class="delimiter">[</span><a title=" &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]]" id="scales.utils.collection.path;FoldOperation;Item">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection.path;FoldOperation;Section">Section</a>, <a title="[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="scales.utils.collection.path;FoldOperation;CC">CC</a><span class="delimiter">[</span><a title="" id="scales.utils.collection.path;FoldOperation;CC;X">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> <span title="Unit" class="delimiter">{</span>

  <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="scales.utils.collection.path;FoldOperation.rootChangeAllowed">rootChangeAllowed</a> = <span title="Boolean(false)" class="keyword">false</span>

  <span class="keyword">def</span> <a title="(path: scales.utils.collection.path.Path[Item,Section,CC])scales.utils.FoldR[Item,Section,CC]" id="scales.utils.collection.path;FoldOperation.perform">perform</a><span class="delimiter">(</span><a title="scales.utils.collection.path.Path[Item,Section,CC]" id="scales.utils.collection.path;FoldOperation.perform.path">path</a>: <a href="Paths.scala.html#scales.utils.collection.path;Path" title="scales.utils.collection.path.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scales.utils.FoldR[Item,Section,CC]">FoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>

  <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(path: scales.utils.collection.path.Path[Item,Section,CC], direction: Int, newPath: Iterable[scales.utils.ItemOrTree[Item,Section,CC]])(implicit cbf: scales.utils.TreeCBF[Item,Section,CC])scales.utils.FoldR[Item,Section,CC]" id="scales.utils.collection.path;FoldOperation.add">add</a><span class="delimiter">(</span><a title="scales.utils.collection.path.Path[Item,Section,CC]" id="scales.utils.collection.path;FoldOperation.add.path">path</a>: <a href="Paths.scala.html#scales.utils.collection.path;Path" title="scales.utils.collection.path.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, <a title="Int" id="scales.utils.collection.path;FoldOperation.add.direction">direction</a>: <span title="Int">Int</span>, <a title="Iterable[scales.utils.ItemOrTree[Item,Section,CC]]" id="scales.utils.collection.path;FoldOperation.add.newPath">newPath</a>: <span title="Iterable[scales.utils.ItemOrTree[Item,Section,CC]]">Iterable</span><span class="delimiter">[</span>ItemOrTree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scales.utils.TreeCBF[Item,Section,CC]" id="scales.utils.collection.path;FoldOperation.add.cbf">cbf</a> : <span title="scales.utils.TreeCBF[Item,Section,CC]">TreeCBF</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> : <span title="scales.utils.FoldR[Item,Section,CC]">FoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="comment">// need to go up to replace</span>
    <span class="keyword">val</span> <a title="scales.utils.collection.path.Path[Item,Section,CC]" id="scales.utils.collection.path;FoldOperation.add.parent">parent</a> = <a href="#scales.utils.collection.path;FoldOperation.add.path" title="scales.utils.collection.path.Path[Item,Section,CC]">path</a>.<a href="Paths.scala.html#scales.utils.collection.path;Path.zipUp" title="()scales.utils.collection.path.Path[Item,Section,CC]">zipUp</a>
    <span title="scales.utils.FoldR[Item,Section,CC]" class="keyword">if</span> <span class="delimiter">(</span><a href="#scales.utils.collection.path;FoldOperation.add.path" title="scales.utils.collection.path.Path[Item,Section,CC]">path</a>.<a href="Paths.scala.html#scales.utils.collection.path;Path.top" title="=&gt; scales.utils.EitherLike[scales.utils.collection.path.Top[Item,Section,CC],scales.utils.collection.path.Path[Item,Section,CC]]">top</a>.<a href="../../EitherLike.scala.html#scales.utils;EitherLike.isLeft" title="=&gt; Boolean">isLeft</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#scales.utils.collection.path;FoldOperation.rootChangeAllowed" title="=&gt; Boolean">rootChangeAllowed</a><span class="delimiter">)</span>
      <span title="(b: scales.utils.collection.path.AddedBeforeOrAfterRoot.type)scala.util.Right[Nothing,scales.utils.collection.path.AddedBeforeOrAfterRoot.type]">Right</span><span class="delimiter">(</span><a href="#scales.utils.collection.path.AddedBeforeOrAfterRoot.readResolve" title="scales.utils.collection.path.AddedBeforeOrAfterRoot.type">AddedBeforeOrAfterRoot</a><span class="delimiter">)</span>
    <span class="keyword">else</span>
      <span title="(a: scales.utils.collection.path.Path[Item,Section,CC])scala.util.Left[scales.utils.collection.path.Path[Item,Section,CC],Nothing]">Left</span><span class="delimiter">(</span><a href="#scales.utils.collection.path;FoldOperation.add.parent" title="scales.utils.collection.path.Path[Item,Section,CC]">parent</a>.
        <a href="Paths.scala.html#scales.utils.collection.path;Path.modify" title="(newFocus: scales.utils.ItemOrTree[Item,Section,CC] =&gt; scales.utils.ItemOrTree[Item,Section,CC])scales.utils.collection.path.Path[Item,Section,CC]">modify</a> <span class="delimiter">{</span> <a title="scales.utils.ItemOrTree[Item,Section,CC]" id="scales.utils.collection.path;FoldOperation.add.$anonfun.x">x</a> =&gt;
          <span class="keyword">val</span> <a title="scales.utils.collection.Tree[Item,Section,CC]" id="scales.utils.collection.path;FoldOperation.add.$anonfun.tree">tree</a> = <a href="#scales.utils.collection.path;FoldOperation.add.$anonfun.x" title="scales.utils.ItemOrTree[Item,Section,CC]">x</a>.<a href="../../EitherLike.scala.html#scales.utils;EitherLike.right" title="=&gt; scales.utils.impl.RightLikeProjection[scales.utils.collection.Tree[Item,Section,CC]]">right</a>.<a href="../../impl/EitherLikeImpl.scala.html#scales.utils.impl;RightLikeProjection.get" title="=&gt; scales.utils.collection.Tree[Item,Section,CC]">get</a>;
          <span class="keyword">val</span> <a title="Int" id="scales.utils.collection.path;FoldOperation.add.$anonfun.index">index</a> = <a href="#scales.utils.collection.path;FoldOperation.add.path" title="scales.utils.collection.path.Path[Item,Section,CC]">path</a>.<a href="Paths.scala.html#scales.utils.collection.path;Path.node" title="=&gt; scales.utils.collection.path.Node[Item,Section,CC]">node</a>.<a href="Paths.scala.html#scales.utils.collection.path;Node.index" title="=&gt; Int">index</a> <span title="(x: Int)Int">+</span> <a href="#scales.utils.collection.path;FoldOperation.add.direction" title="Int">direction</a>
          <span class="keyword">val</span> <a href="#scales.utils.collection.path;FoldOperation.add.$anonfun.pre" title="(CC[scales.utils.ItemOrTree[Item,Section,CC]], CC[scales.utils.ItemOrTree[Item,Section,CC]])" class="delimiter">(</a><a href="#scales.utils.collection.path;FoldOperation.add.$anonfun.x$1" title="CC[scales.utils.ItemOrTree[Item,Section,CC]]" id="scales.utils.collection.path;FoldOperation.add.$anonfun.pre">pre</a>,<a href="#scales.utils.collection.path;FoldOperation.add.$anonfun.x$1" title="CC[scales.utils.ItemOrTree[Item,Section,CC]]" id="scales.utils.collection.path;FoldOperation.add.$anonfun.pos">pos</a><span class="delimiter">)</span> = <a href="#scales.utils.collection.path;FoldOperation.add.$anonfun.tree" title="scales.utils.collection.Tree[Item,Section,CC]">tree</a>.<a href="../Trees.scala.html#scales.utils.collection;Tree.children" title="=&gt; CC[scales.utils.ItemOrTree[Item,Section,CC]]">children</a>.<span title="(n: Int)(CC[scales.utils.ItemOrTree[Item,Section,CC]], CC[scales.utils.ItemOrTree[Item,Section,CC]])">splitAt</span><span title="(CC[scales.utils.ItemOrTree[Item,Section,CC]], CC[scales.utils.ItemOrTree[Item,Section,CC]]) @unchecked" class="delimiter">(</span><a href="#scales.utils.collection.path;FoldOperation.add.$anonfun.index" title="Int">index</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="CC[scales.utils.ItemOrTree[Item,Section,CC]]" id="scales.utils.collection.path;FoldOperation.add.$anonfun.newChildren">newChildren</a> = <span class="delimiter">(</span><a href="#scales.utils.collection.path;FoldOperation.add.$anonfun.pre" title="CC[scales.utils.ItemOrTree[Item,Section,CC]]">pre</a> <a href="#scales.utils.collection.path;FoldOperation.add.cbf" title="(that: scala.collection.GenTraversableOnce[scales.utils.ItemOrTree[Item,Section,CC]])(implicit bf: scala.collection.generic.CanBuildFrom[CC[scales.utils.ItemOrTree[Item,Section,CC]],scales.utils.ItemOrTree[Item,Section,CC],CC[scales.utils.ItemOrTree[Item,Section,CC]]])CC[scales.utils.ItemOrTree[Item,Section,CC]]">++</a> <a href="#scales.utils.collection.path;FoldOperation.add.newPath" title="Iterable[scales.utils.ItemOrTree[Item,Section,CC]]">newPath</a><span class="delimiter">)</span> <a href="#scales.utils.collection.path;FoldOperation.add.cbf" title="(that: scala.collection.GenTraversableOnce[scales.utils.ItemOrTree[Item,Section,CC]])(implicit bf: scala.collection.generic.CanBuildFrom[CC[scales.utils.ItemOrTree[Item,Section,CC]],scales.utils.ItemOrTree[Item,Section,CC],CC[scales.utils.ItemOrTree[Item,Section,CC]]])CC[scales.utils.ItemOrTree[Item,Section,CC]]">++</a> <a href="#scales.utils.collection.path;FoldOperation.add.$anonfun.pos" title="CC[scales.utils.ItemOrTree[Item,Section,CC]]">pos</a>
          <a href="../Trees.scala.html#scales.utils.collection.Tree.apply" title="(isection: Section, ichildren: CC[scales.utils.ItemOrTree[Item,Section,CC]])scales.utils.collection.Tree[Item,Section,CC]">Tree</a><span class="delimiter">(</span><a href="#scales.utils.collection.path;FoldOperation.add.$anonfun.tree" title="scales.utils.collection.Tree[Item,Section,CC]">tree</a>.<a href="../Trees.scala.html#scales.utils.collection;Tree.section" title="=&gt; Section">section</a>, <a href="#scales.utils.collection.path;FoldOperation.add.$anonfun.newChildren" title="CC[scales.utils.ItemOrTree[Item,Section,CC]]">newChildren</a><span class="delimiter">)</span>
        <span class="delimiter">}</span><span class="delimiter">)</span>

  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span title="AnyRef" class="keyword">case class</span> <a href="#scales.utils.collection.path;Remove.productElement.x$1" title="class Remove[Item &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]] extends AnyRef with scales.utils.collection.path.FoldOperation[Item,Section,CC] with Product with Serializable" id="scales.utils.collection.path.Remove.readResolve">Remove</a><span class="delimiter">[</span><a title=" &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]]" id="scales.utils.collection.path;Remove;Item">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection.path;Remove;Section">Section</a>, <a title="[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="scales.utils.collection.path;Remove;CC">CC</a><span class="delimiter">[</span><a title="" id="scales.utils.collection.path;Remove;CC;X">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><a href="#scales.utils.collection.path.Remove.readResolve" title="Product" class="delimiter">(</a><span class="keyword">implicit</span> <a title="scales.utils.TreeCBF[Item,Section,CC]" id="scales.utils.collection.path;Remove.cbf">cbf</a> : <span title="scales.utils.TreeCBF[Item,Section,CC]">TreeCBF</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#scales.utils.collection.path;FoldOperation" title="scales.utils.collection.path.FoldOperation[Item,Section,CC]">FoldOperation</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> <span class="delimiter">{</span>

  <span class="keyword">def</span> <a title="(path: scales.utils.collection.path.Path[Item,Section,CC])scales.utils.FoldR[Item,Section,CC]" id="scales.utils.collection.path;Remove.perform">perform</a><span class="delimiter">(</span><a title="scales.utils.collection.path.Path[Item,Section,CC]" id="scales.utils.collection.path;Remove.perform.path">path</a>: <a href="Paths.scala.html#scales.utils.collection.path;Path" title="scales.utils.collection.path.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scales.utils.FoldR[Item,Section,CC]">FoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Option[scales.utils.collection.path.Path[Item,Section,CC]]" id="scales.utils.collection.path;Remove.perform.ores">ores</a> = <a href="#scales.utils.collection.path;Remove.perform.path" title="scales.utils.collection.path.Path[Item,Section,CC]">path</a>.<a href="Paths.scala.html#scales.utils.collection.path;Path.removeAndUp" title="()Option[scales.utils.collection.path.Path[Item,Section,CC]]">removeAndUp</a><span class="delimiter">(</span><span class="delimiter">)</span>;
    <span title="scales.utils.FoldR[Item,Section,CC]" class="keyword">if</span> <span class="delimiter">(</span><a href="#scales.utils.collection.path;Remove.perform.ores" title="Option[scales.utils.collection.path.Path[Item,Section,CC]]">ores</a>.<span title="=&gt; Boolean">isDefined</span><span class="delimiter">)</span> <span title="(a: scales.utils.collection.path.Path[Item,Section,CC])scala.util.Left[scales.utils.collection.path.Path[Item,Section,CC],Nothing]">Left</span><span class="delimiter">(</span><a href="#scales.utils.collection.path;Remove.perform.ores" title="Option[scales.utils.collection.path.Path[Item,Section,CC]]">ores</a>.<span title="=&gt; scales.utils.collection.path.Path[Item,Section,CC]">get</span><span class="delimiter">)</span>
    <span class="keyword">else</span> <span title="(b: scales.utils.collection.path.RemovedRoot.type)scala.util.Right[Nothing,scales.utils.collection.path.RemovedRoot.type]">Right</span><span class="delimiter">(</span><a href="#scales.utils.collection.path.RemovedRoot.readResolve" title="scales.utils.collection.path.RemovedRoot.type">RemovedRoot</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="keyword">case class</span> <a href="#scales.utils.collection.path;AddBefore.productElement.x$1" title="class AddBefore[Item &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]] extends AnyRef with scales.utils.collection.path.FoldOperation[Item,Section,CC] with Product with Serializable" id="scales.utils.collection.path.AddBefore.readResolve">AddBefore</a><span class="delimiter">[</span><a title=" &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]]" id="scales.utils.collection.path;AddBefore;Item">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection.path;AddBefore;Section">Section</a>, <a title="[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="scales.utils.collection.path;AddBefore;CC">CC</a><span class="delimiter">[</span><a title="" id="scales.utils.collection.path;AddBefore;CC;X">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><a href="#scales.utils.collection.path.AddBefore.readResolve" title="Product" class="delimiter">(</a><a title="scales.utils.ItemOrTree[Item,Section,CC]" id="scales.utils.collection.path;AddBefore.newPath">newPath</a>: <a href="../../EitherLike.scala.html#scales.utils;EitherLike" title="scales.utils.ItemOrTree[Item,Section,CC]">ItemOrTree</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scales.utils.TreeCBF[Item,Section,CC]" id="scales.utils.collection.path;AddBefore.cbf">cbf</a> : <span title="scales.utils.TreeCBF[Item,Section,CC]">TreeCBF</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#scales.utils.collection.path;FoldOperation" title="scales.utils.collection.path.FoldOperation[Item,Section,CC]">FoldOperation</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> <span class="delimiter">{</span>

  <span class="keyword">def</span> <a title="(path: scales.utils.collection.path.Path[Item,Section,CC])scales.utils.FoldR[Item,Section,CC]" id="scales.utils.collection.path;AddBefore.perform">perform</a><span class="delimiter">(</span><a title="scales.utils.collection.path.Path[Item,Section,CC]" id="scales.utils.collection.path;AddBefore.perform.path">path</a>: <a href="Paths.scala.html#scales.utils.collection.path;Path" title="scales.utils.collection.path.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scales.utils.FoldR[Item,Section,CC]">FoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> = <a href="#scales.utils.collection.path;FoldOperation.add" title="(path: scales.utils.collection.path.Path[Item,Section,CC], direction: Int, newPath: Iterable[scales.utils.ItemOrTree[Item,Section,CC]])(implicit cbf: scales.utils.TreeCBF[Item,Section,CC])scales.utils.FoldR[Item,Section,CC]">add</a><a href="#scales.utils.collection.path;AddBefore.cbf" title="scales.utils.TreeCBF[Item,Section,CC]" class="delimiter">(</a><a href="#scales.utils.collection.path;AddBefore.perform.path" title="scales.utils.collection.path.Path[Item,Section,CC]">path</a>, <span title="Int(0)" class="int">0</span>, <span title="(xs: scales.utils.ItemOrTree[Item,Section,CC]*)List[scales.utils.ItemOrTree[Item,Section,CC]]">List</span><span class="delimiter">(</span><a href="#scales.utils.collection.path;AddBefore.newPath" title="=&gt; scales.utils.ItemOrTree[Item,Section,CC]">newPath</a><span class="delimiter">)</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="keyword">case class</span> <a href="#scales.utils.collection.path;AddAfter.productElement.x$1" title="class AddAfter[Item &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]] extends AnyRef with scales.utils.collection.path.FoldOperation[Item,Section,CC] with Product with Serializable" id="scales.utils.collection.path.AddAfter.readResolve">AddAfter</a><span class="delimiter">[</span><a title=" &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]]" id="scales.utils.collection.path;AddAfter;Item">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection.path;AddAfter;Section">Section</a>, <a title="[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="scales.utils.collection.path;AddAfter;CC">CC</a><span class="delimiter">[</span><a title="" id="scales.utils.collection.path;AddAfter;CC;X">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><a href="#scales.utils.collection.path.AddAfter.readResolve" title="Product" class="delimiter">(</a><a title="scales.utils.ItemOrTree[Item,Section,CC]" id="scales.utils.collection.path;AddAfter.newPath">newPath</a>: <a href="../../EitherLike.scala.html#scales.utils;EitherLike" title="scales.utils.ItemOrTree[Item,Section,CC]">ItemOrTree</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scales.utils.TreeCBF[Item,Section,CC]" id="scales.utils.collection.path;AddAfter.cbf">cbf</a> : <span title="scales.utils.TreeCBF[Item,Section,CC]">TreeCBF</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#scales.utils.collection.path;FoldOperation" title="scales.utils.collection.path.FoldOperation[Item,Section,CC]">FoldOperation</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> <span class="delimiter">{</span>

  <span class="keyword">def</span> <a title="(path: scales.utils.collection.path.Path[Item,Section,CC])scales.utils.FoldR[Item,Section,CC]" id="scales.utils.collection.path;AddAfter.perform">perform</a><span class="delimiter">(</span><a title="scales.utils.collection.path.Path[Item,Section,CC]" id="scales.utils.collection.path;AddAfter.perform.path">path</a>: <a href="Paths.scala.html#scales.utils.collection.path;Path" title="scales.utils.collection.path.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scales.utils.FoldR[Item,Section,CC]">FoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> = <a href="#scales.utils.collection.path;FoldOperation.add" title="(path: scales.utils.collection.path.Path[Item,Section,CC], direction: Int, newPath: Iterable[scales.utils.ItemOrTree[Item,Section,CC]])(implicit cbf: scales.utils.TreeCBF[Item,Section,CC])scales.utils.FoldR[Item,Section,CC]">add</a><a href="#scales.utils.collection.path;AddAfter.cbf" title="scales.utils.TreeCBF[Item,Section,CC]" class="delimiter">(</a><a href="#scales.utils.collection.path;AddAfter.perform.path" title="scales.utils.collection.path.Path[Item,Section,CC]">path</a>, <span title="Int(1)" class="int">1</span>, <span title="(xs: scales.utils.ItemOrTree[Item,Section,CC]*)List[scales.utils.ItemOrTree[Item,Section,CC]]">List</span><span class="delimiter">(</span><a href="#scales.utils.collection.path;AddAfter.newPath" title="=&gt; scales.utils.ItemOrTree[Item,Section,CC]">newPath</a><span class="delimiter">)</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * Use to make it easier to filter out large sets (for those that aren't interesting simply asis them, see tests for use case)
 */</span>
<span class="keyword">case class</span> <a href="#scales.utils.collection.path;AsIs.productElement.x$1" title="class AsIs[Item &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]] extends AnyRef with scales.utils.collection.path.FoldOperation[Item,Section,CC] with Product with Serializable" id="scales.utils.collection.path.AsIs.readResolve">AsIs</a><span class="delimiter">[</span><a title=" &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]]" id="scales.utils.collection.path;AsIs;Item">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection.path;AsIs;Section">Section</a>, <a title="[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="scales.utils.collection.path;AsIs;CC">CC</a><span class="delimiter">[</span><a title="" id="scales.utils.collection.path;AsIs;CC;X">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><a href="#scales.utils.collection.path.AsIs.readResolve" title="Product" class="delimiter">(</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#scales.utils.collection.path;FoldOperation" title="scales.utils.collection.path.FoldOperation[Item,Section,CC]">FoldOperation</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> <span class="delimiter">{</span>

  <span class="keyword">def</span> <a title="(path: scales.utils.collection.path.Path[Item,Section,CC])scales.utils.FoldR[Item,Section,CC]" id="scales.utils.collection.path;AsIs.perform">perform</a><span class="delimiter">(</span><a title="scales.utils.collection.path.Path[Item,Section,CC]" id="scales.utils.collection.path;AsIs.perform.path">path</a>: <a href="Paths.scala.html#scales.utils.collection.path;Path" title="scales.utils.collection.path.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scales.utils.FoldR[Item,Section,CC]">FoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> = <span title="(a: scales.utils.collection.path.Path[Item,Section,CC])scala.util.Left[scales.utils.collection.path.Path[Item,Section,CC],Nothing]">Left</span><span class="delimiter">(</span><a href="#scales.utils.collection.path;AsIs.perform.path" title="scales.utils.collection.path.Path[Item,Section,CC]">path</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="keyword">object</span> <a title="scales.utils.collection.path.Replace.type" id="scales.utils.collection.path.Replace.readResolve">Replace</a> <a href="#scales.utils.collection.path.Replace.readResolve" title="scales.utils.collection.path.Replace.type" class="delimiter">{</a>
  <span class="comment">/**
   * Simpler interface
   */</span>
  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](replaceWith: scales.utils.ItemOrTree[Item,Section,CC]*)(implicit cbf: scales.utils.TreeCBF[Item,Section,CC])scales.utils.collection.path.Replace[Item,Section,CC]" id="scales.utils.collection.path.Replace.apply(eb061886d8)">apply</a><span class="delimiter">[</span><a title=" &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]]" id="scales.utils.collection.path.Replace.apply(eb061886d8);Item">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection.path.Replace.apply(eb061886d8);Section">Section</a>, <a title="[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="scales.utils.collection.path.Replace.apply(eb061886d8);CC">CC</a><span class="delimiter">[</span><a title="" id="scales.utils.collection.path.Replace.apply(eb061886d8);CC;X">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="scales.utils.ItemOrTree[Item,Section,CC]*" id="scales.utils.collection.path.Replace.apply(eb061886d8).replaceWith">replaceWith</a>: <span title="scales.utils.ItemOrTree[Item,Section,CC]*">ItemOrTree</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>*<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scales.utils.TreeCBF[Item,Section,CC]" id="scales.utils.collection.path.Replace.apply(eb061886d8).cbf">cbf</a> : <span title="scales.utils.TreeCBF[Item,Section,CC]">TreeCBF</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#scales.utils.collection.path.Replace.apply(eb061886d8).cbf" title="scales.utils.collection.path.Replace[Item,Section,CC]" class="keyword">new</a> <a href="#scales.utils.collection.path;Replace.equals" title="scales.utils.collection.path.Replace[Item,Section,CC]">Replace</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">(</span><a href="#scales.utils.collection.path.Replace.apply(eb061886d8).replaceWith" title="scales.utils.ItemOrTree[Item,Section,CC]*">replaceWith</a><span class="delimiter">)</span>

<span class="delimiter">}</span>

<span class="comment">/**
 * Allows replacing one path with many, may be easier to use the * version however
 */</span>
<span title="AnyRef" class="keyword">case class</span> <a href="#scales.utils.collection.path;Replace.copy$default$1" title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](replaceWith: Iterable[scales.utils.ItemOrTree[Item,Section,CC]])(implicit cbf: scales.utils.TreeCBF[Item,Section,CC])scales.utils.collection.path.Replace[Item,Section,CC]" id="scales.utils.collection.path;Replace.equals">Replace</a><span class="delimiter">[</span><a title=" &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]]" id="scales.utils.collection.path;Replace.copy$default$1;Item">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection.path;Replace.copy$default$1;Section">Section</a>, <a title="[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="scales.utils.collection.path;Replace.copy$default$1;CC">CC</a><span class="delimiter">[</span><a title="" id="scales.utils.collection.path;Replace.copy$default$1;CC;X">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><a href="#scales.utils.collection.path;Replace.equals" title="Product" class="delimiter">(</a><a title="Iterable[scales.utils.ItemOrTree[Item,Section,CC]]" id="scales.utils.collection.path;Replace.copy$default$1">replaceWith</a>: <span title="Iterable[scales.utils.ItemOrTree[Item,Section,CC]]">Iterable</span><span class="delimiter">[</span>ItemOrTree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scales.utils.TreeCBF[Item,Section,CC]" id="scales.utils.collection.path;Replace.copy.cbf">cbf</a> : <span title="scales.utils.TreeCBF[Item,Section,CC]">TreeCBF</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#scales.utils.collection.path;FoldOperation" title="scales.utils.collection.path.FoldOperation[Item,Section,CC]">FoldOperation</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> <span class="delimiter">{</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="scales.utils.collection.path;Replace.rootChangeAllowed">rootChangeAllowed</a> = <span title="Boolean(true)" class="keyword">true</span>

  <span class="keyword">def</span> <a title="(path: scales.utils.collection.path.Path[Item,Section,CC])scales.utils.FoldR[Item,Section,CC]" id="scales.utils.collection.path;Replace.perform">perform</a><span class="delimiter">(</span><a title="scales.utils.collection.path.Path[Item,Section,CC]" id="scales.utils.collection.path;Replace.perform.path">path</a>: <a href="Paths.scala.html#scales.utils.collection.path;Path" title="scales.utils.collection.path.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scales.utils.FoldR[Item,Section,CC]">FoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="comment">// modify with tail</span>
    <span class="keyword">val</span> <a title="scales.utils.collection.path.Path[Item,Section,CC]" id="scales.utils.collection.path;Replace.perform.tpath">tpath</a> = <a href="#scales.utils.collection.path;Replace.perform.path" title="scales.utils.collection.path.Path[Item,Section,CC]">path</a>.<a href="Paths.scala.html#scales.utils.collection.path;Path.modify" title="(newFocus: scales.utils.ItemOrTree[Item,Section,CC] =&gt; scales.utils.ItemOrTree[Item,Section,CC])scales.utils.collection.path.Path[Item,Section,CC]">modify</a><span class="delimiter">(</span><a title="scales.utils.ItemOrTree[Item,Section,CC]" id="scales.utils.collection.path;Replace.perform.tpath.$anonfun.x$2">_</a> =&gt; <a href="#scales.utils.collection.path;Replace.copy$default$1" title="=&gt; Iterable[scales.utils.ItemOrTree[Item,Section,CC]]">replaceWith</a>.<span title="=&gt; scales.utils.ItemOrTree[Item,Section,CC]">head</span><span class="delimiter">)</span>
    <a href="#scales.utils.collection.path;FoldOperation.add" title="(path: scales.utils.collection.path.Path[Item,Section,CC], direction: Int, newPath: Iterable[scales.utils.ItemOrTree[Item,Section,CC]])(implicit cbf: scales.utils.TreeCBF[Item,Section,CC])scales.utils.FoldR[Item,Section,CC]">add</a><a href="#scales.utils.collection.path;Replace.copy.cbf" title="scales.utils.TreeCBF[Item,Section,CC]" class="delimiter">(</a><a href="#scales.utils.collection.path;Replace.perform.tpath" title="scales.utils.collection.path.Path[Item,Section,CC]">tpath</a>, <span title="Int(1)" class="int">1</span>, <a href="#scales.utils.collection.path;Replace.copy$default$1" title="=&gt; Iterable[scales.utils.ItemOrTree[Item,Section,CC]]">replaceWith</a>.<span title="=&gt; Iterable[scales.utils.ItemOrTree[Item,Section,CC]]">tail</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * Allows foldPositions to be nested, only replace and delete makes sense here (afaict).
 *
 * As such, when wholeTree is false, the path (which must be a tree) is transformed
 * 
 *     p =&gt; top(p.tree)
 *
 * and a special case for &quot;deletes&quot; is made - when RemovedRoot is returned from the transformation a delete will take place on the Path.  This enforces that only replace and removes are possible and function appropriately.
 *
 * Warning:
 * 
 * When wholeTree is true the function f is passed the Path (or item) in the original tree, any transformations are then conusmed across the whole tree, which is likely not desired. 
 */</span>
<span class="keyword">case class</span> <a href="#scales.utils.collection.path;ReplaceWith.productElement.x$1" title="class ReplaceWith[Item &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]] extends AnyRef with scales.utils.collection.path.FoldOperation[Item,Section,CC] with Product with Serializable" id="scales.utils.collection.path.ReplaceWith.readResolve">ReplaceWith</a><span class="delimiter">[</span><a title=" &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]]" id="scales.utils.collection.path.ReplaceWith.apply$default$2;Item">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection.path.ReplaceWith.apply$default$2;Section">Section</a>, <a title="[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="scales.utils.collection.path.ReplaceWith.apply$default$2;CC">CC</a><span class="delimiter">[</span><a title="" id="scales.utils.collection.path.ReplaceWith.apply$default$2;CC;X">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><a href="#scales.utils.collection.path.ReplaceWith.readResolve" title="Product" class="delimiter">(</a><a title="scales.utils.collection.path.Path[Item,Section,CC] =&gt; scales.utils.FoldR[Item,Section,CC]" id="scales.utils.collection.path;ReplaceWith.f">f</a>: <span title="scales.utils.collection.path.Path[Item,Section,CC] =&gt; scales.utils.FoldR[Item,Section,CC]">PathFoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, <a title="Boolean" id="scales.utils.collection.path.ReplaceWith.apply$default$2">wholeTree</a> : <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scales.utils.TreeCBF[Item,Section,CC]" id="scales.utils.collection.path;ReplaceWith.cbf">cbf</a> : <span title="scales.utils.TreeCBF[Item,Section,CC]">TreeCBF</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#scales.utils.collection.path;FoldOperation" title="scales.utils.collection.path.FoldOperation[Item,Section,CC]">FoldOperation</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> <span class="delimiter">{</span>

  <span class="keyword">def</span> <a title="(path: scales.utils.collection.path.Path[Item,Section,CC])scales.utils.FoldR[Item,Section,CC]" id="scales.utils.collection.path;ReplaceWith.perform">perform</a><span class="delimiter">(</span><a title="scales.utils.collection.path.Path[Item,Section,CC]" id="scales.utils.collection.path;ReplaceWith.perform.path">path</a>: <a href="Paths.scala.html#scales.utils.collection.path;Path" title="scales.utils.collection.path.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scales.utils.FoldR[Item,Section,CC]">FoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> =
    <span class="comment">// modify back in (allows changes), or pass on the error</span>
    <a href="#scales.utils.collection.path;ReplaceWith.f" title="(v1: scales.utils.collection.path.Path[Item,Section,CC])scales.utils.FoldR[Item,Section,CC]">f</a><span class="delimiter">(</span> <span title="scales.utils.collection.path.Path[Item,Section,CC]" class="keyword">if</span> <span class="delimiter">(</span><a href="#scales.utils.collection.path.ReplaceWith.apply$default$2" title="=&gt; Boolean">wholeTree</a><span class="delimiter">)</span> 
	 <a href="#scales.utils.collection.path;ReplaceWith.perform.path" title="scales.utils.collection.path.Path[Item,Section,CC]">path</a> 
       <span class="keyword">else</span>
	 <a href="PathFunctions.scala.html#scales.utils.collection.path;Paths.top" title="(tree: scales.utils.collection.Tree[Item,Section,CC])(implicit cbf: scales.utils.TreeCBF[Item,Section,CC])scales.utils.collection.path.Path[Item,Section,CC]">top</a><a href="#scales.utils.collection.path;ReplaceWith.cbf" title="scales.utils.TreeCBF[Item,Section,CC]" class="delimiter">(</a><a href="#scales.utils.collection.path;ReplaceWith.perform.path" title="scales.utils.collection.path.Path[Item,Section,CC]">path</a>.<a href="Paths.scala.html#scales.utils.collection.path;Path.tree" title="()scales.utils.collection.Tree[Item,Section,CC]">tree</a><span class="delimiter">)</span> <span class="delimiter">)</span>.
      <span title="(fa: scales.utils.collection.path.Path[Item,Section,CC] =&gt; scales.utils.FoldR[Item,Section,CC], fb: scales.utils.collection.path.FoldError =&gt; scales.utils.FoldR[Item,Section,CC])scales.utils.FoldR[Item,Section,CC]">fold</span><span class="delimiter">(</span><a title="scales.utils.collection.path.Path[Item,Section,CC]" id="scales.utils.collection.path;ReplaceWith.perform.$anonfun.fres">fres</a> =&gt; 
	<span title="(a: scales.utils.collection.path.Path[Item,Section,CC])scala.util.Left[scales.utils.collection.path.Path[Item,Section,CC],Nothing]">Left</span><span class="delimiter">(</span><a href="#scales.utils.collection.path;ReplaceWith.perform.path" title="scales.utils.collection.path.Path[Item,Section,CC]">path</a>.<a href="Paths.scala.html#scales.utils.collection.path;Path.modify" title="(newFocus: scales.utils.ItemOrTree[Item,Section,CC] =&gt; scales.utils.ItemOrTree[Item,Section,CC])scales.utils.collection.path.Path[Item,Section,CC]">modify</a><span class="delimiter">(</span><a title="scales.utils.ItemOrTree[Item,Section,CC]" id="scales.utils.collection.path;ReplaceWith.perform.$anonfun.$anonfun.x$3">_</a> =&gt; 
      	  <a href="#scales.utils.collection.path;ReplaceWith.perform.$anonfun.fres" title="scales.utils.collection.path.Path[Item,Section,CC]">fres</a>.<a href="Paths.scala.html#scales.utils.collection.path;Path.tree" title="()scales.utils.collection.Tree[Item,Section,CC]">tree</a>
	  <span class="delimiter">)</span><span class="delimiter">)</span>,
        <a title="scales.utils.collection.path.FoldError" id="scales.utils.collection.path;ReplaceWith.perform.$anonfun.x">x</a> =&gt; <span class="delimiter">{</span>
	  <span title="scales.utils.FoldR[Item,Section,CC]" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#scales.utils.collection.path;ReplaceWith.perform.$anonfun.x" title="scales.utils.collection.path.FoldError">x</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scales.utils.collection.path.RemovedRoot.readResolve" title="scales.utils.collection.path.RemovedRoot.type">RemovedRoot</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> 
	      <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#scales.utils.collection.path.ReplaceWith.apply$default$2" title="=&gt; Boolean">wholeTree</a><span class="delimiter">)</span><span class="delimiter">)</span>
	    <span class="comment">// delete the node - special case as per doc</span>
	    <a href="#scales.utils.collection.path.Remove.readResolve" title="()(implicit cbf: scales.utils.TreeCBF[Item,Section,CC])scales.utils.collection.path.Remove[Item,Section,CC]">Remove</a><a href="#scales.utils.collection.path;ReplaceWith.cbf" title="scales.utils.TreeCBF[Item,Section,CC]" class="delimiter">(</a><span class="delimiter">)</span>.<a href="#scales.utils.collection.path;Remove.perform" title="(path: scales.utils.collection.path.Path[Item,Section,CC])scales.utils.FoldR[Item,Section,CC]">perform</a><span class="delimiter">(</span><a href="#scales.utils.collection.path;ReplaceWith.perform.path" title="scales.utils.collection.path.Path[Item,Section,CC]">path</a><span class="delimiter">)</span> <span class="comment">// it might itself be the root but thats fine</span>
	  <span class="keyword">else</span>
	    <span title="(b: scales.utils.collection.path.FoldError)scala.util.Right[Nothing,scales.utils.collection.path.FoldError]">Right</span><span class="delimiter">(</span><a href="#scales.utils.collection.path;ReplaceWith.perform.$anonfun.x" title="scales.utils.collection.path.FoldError">x</a><span class="delimiter">)</span><span class="delimiter">}</span><span class="delimiter">)</span>

<span class="delimiter">}</span>

<span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait FoldError extends AnyRef" id="scales.utils.collection.path;FoldError">FoldError</a>

<span title="AnyRef" class="keyword">case object</span> <a href="#scales.utils.collection.path.NoPaths.productElement.x$1" title="scales.utils.collection.path.NoPaths.type" id="scales.utils.collection.path.NoPaths.readResolve">NoPaths</a> <span title="Product" class="keyword">extends</span> <a href="#scales.utils.collection.path;FoldError" title="scales.utils.collection.path.FoldError">FoldError</a>
<span class="keyword">case object</span> <a href="#scales.utils.collection.path.NoSingleRoot.productElement.x$1" title="scales.utils.collection.path.NoSingleRoot.type" id="scales.utils.collection.path.NoSingleRoot.readResolve">NoSingleRoot</a> <span title="Product" class="keyword">extends</span> <a href="#scales.utils.collection.path;FoldError" title="scales.utils.collection.path.FoldError">FoldError</a>
<span class="keyword">case object</span> <a href="#scales.utils.collection.path.RemovedRoot.productElement.x$1" title="scales.utils.collection.path.RemovedRoot.type" id="scales.utils.collection.path.RemovedRoot.readResolve">RemovedRoot</a> <span title="Product" class="keyword">extends</span> <a href="#scales.utils.collection.path;FoldError" title="scales.utils.collection.path.FoldError">FoldError</a>
<span class="keyword">case object</span> <a href="#scales.utils.collection.path.AddedBeforeOrAfterRoot.productElement.x$1" title="scales.utils.collection.path.AddedBeforeOrAfterRoot.type" id="scales.utils.collection.path.AddedBeforeOrAfterRoot.readResolve">AddedBeforeOrAfterRoot</a> <span title="Product" class="keyword">extends</span> <a href="#scales.utils.collection.path;FoldError" title="scales.utils.collection.path.FoldError">FoldError</a>

        </pre>
    </body>
</html>
