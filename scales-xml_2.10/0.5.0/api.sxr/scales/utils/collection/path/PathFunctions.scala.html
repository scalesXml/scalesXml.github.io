<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>scales\utils\collection\path\PathFunctions.scala</title>
        <script type="text/javascript" src="../../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> scales.utils.collection.path

<span class="keyword">import</span> scala.collection.immutable.Stack
<span class="keyword">import</span> scala.collection.IndexedSeqLike
<span class="keyword">import</span> scala.collection.generic.CanBuildFrom

<span class="keyword">import</span> scales.utils._
<span class="keyword">import</span> collection._

<span class="keyword">object</span> <a title="scales.utils.collection.path.PathFold.type" id="scales.utils.collection.path.PathFold">PathFold</a> <a href="#scales.utils.collection.path.PathFold" title="scales.utils.collection.path.PathFold.type" class="delimiter">{</a>

  <span class="comment">/**
   * Folds over positions within a single path, for example all given children.  As such positions must be calculated.
   *
   * Takes the first root, returning Right(NoSingleRoot) if any of the subsequent roots don't match.
   *
   * folder retrieves the current path
   *
   * Each iteration folds the resulting tree back into the path. As this function must maintain the Path it does not expose the new path root until the result.
   *
   * The progress through the document is in reverse document order.  This ensures that transformations can always be safely composed, e.g. a delete of a path won't stop changes below it.  This, however, implies the developer must also handle any accumalation in &quot;reverse&quot;. 
   */</span>
  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]], ACC](locations: Iterable[scales.utils.collection.path.Path[Item,Section,CC]], accumulator: ACC)(folder: (ACC, scales.utils.collection.path.Path[Item,Section,CC]) =&gt; (ACC, scales.utils.collection.path.FoldOperation[Item,Section,CC]))(implicit cbf: scales.utils.TreeCBF[Item,Section,CC], implicit cm: ClassManifest[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])])Either[(ACC, scales.utils.collection.path.Path[Item,Section,CC]),scales.utils.collection.path.FoldError]" id="scales.utils.collection.path.PathFold.foldPositions">foldPositions</a><span class="delimiter">[</span><a title=" &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]]" id="scales.utils.collection.path.PathFold.foldPositions;Item">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection.path.PathFold.foldPositions;Section">Section</a>, <a title="[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="scales.utils.collection.path.PathFold.foldPositions;CC">CC</a><span class="delimiter">[</span><a title="" id="scales.utils.collection.path.PathFold.foldPositions;CC;X">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection.path.PathFold.foldPositions;ACC">ACC</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Iterable[scales.utils.collection.path.Path[Item,Section,CC]]" id="scales.utils.collection.path.PathFold.foldPositions.locations">locations</a>: <span title="Iterable[scales.utils.collection.path.Path[Item,Section,CC]]">Iterable</span><span class="delimiter">[</span>Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="ACC" id="scales.utils.collection.path.PathFold.foldPositions.accumulator">accumulator</a>: <a href="#scales.utils.collection.path.PathFold.foldPositions;ACC" title="ACC">ACC</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(ACC, scales.utils.collection.path.Path[Item,Section,CC]) =&gt; (ACC, scales.utils.collection.path.FoldOperation[Item,Section,CC])" id="scales.utils.collection.path.PathFold.foldPositions.folder">folder</a>: <span class="delimiter">(</span>ACC, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; <span class="delimiter">(</span>ACC, FoldOperation<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scales.utils.TreeCBF[Item,Section,CC]" id="scales.utils.collection.path.PathFold.foldPositions.cbf">cbf</a> : <span title="scales.utils.TreeCBF[Item,Section,CC]">TreeCBF</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, <a title="ClassManifest[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])]" id="scales.utils.collection.path.PathFold.foldPositions.cm">cm</a> : <span title="ClassManifest[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])]">ClassManifest</span><span class="delimiter">[</span><span class="delimiter">(</span>Position<span class="delimiter">[</span>Item,Section,CC<span class="delimiter">]</span>, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span>  : <span title="Either[(ACC, scales.utils.collection.path.Path[Item,Section,CC]),scales.utils.collection.path.FoldError]">Either</span><span class="delimiter">[</span><span class="delimiter">(</span>ACC, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>, FoldError<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#scales.utils.collection.path.PathFold.foldPositions.locations" title="Iterable[scales.utils.collection.path.Path[Item,Section,CC]]">locations</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <span title="(b: scales.utils.collection.path.NoPaths.type)scala.util.Right[Nothing,scales.utils.collection.path.NoPaths.type]">Right</span><span class="delimiter">(</span><a href="PathFolds.scala.html#scales.utils.collection.path.NoPaths" title="scales.utils.collection.path.NoPaths.type">NoPaths</a><span class="delimiter">)</span>

    <span class="keyword">val</span> <a title="Iterable[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])]" id="scales.utils.collection.path.PathFold.foldPositions.sorted">sorted</a> = <a href="#scales.utils.collection.path;Paths.sortPositions" title="(paths: Iterable[scales.utils.collection.path.Path[Item,Section,CC]], isDescending: Boolean)(implicit cm: ClassManifest[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])])Iterable[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])]">sortPositions</a><a href="#scales.utils.collection.path.PathFold.foldPositions.cm" title="ClassManifest[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])]" class="delimiter">(</a><a href="#scales.utils.collection.path.PathFold.foldPositions.locations" title="Iterable[scales.utils.collection.path.Path[Item,Section,CC]]">locations</a>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>

    <span class="keyword">val</span> <a title="(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])" id="scales.utils.collection.path.PathFold.foldPositions.head">head</a> = <a href="#scales.utils.collection.path.PathFold.foldPositions.sorted" title="Iterable[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])]">sorted</a>.<span title="=&gt; (scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])">head</span>
    <span class="keyword">var</span> <a title="ACC" id="scales.utils.collection.path.PathFold.foldPositions.accum">accum</a> = <a href="#scales.utils.collection.path.PathFold.foldPositions.accumulator" title="ACC">accumulator</a>

    <span class="keyword">val</span> <a title="scales.utils.collection.path.Position[Item,Section,CC]" id="scales.utils.collection.path.PathFold.foldPositions.rootPosition">rootPosition</a> = <a href="#scales.utils.collection.path.PathFold.foldPositions.head" title="(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])">head</a>.<span title="=&gt; scales.utils.collection.path.Position[Item,Section,CC]">_1</span>
    <span class="keyword">val</span> <a title="Boolean" id="scales.utils.collection.path.PathFold.foldPositions.differentRoot">differentRoot</a> = <a href="#scales.utils.collection.path.PathFold.foldPositions.sorted" title="Iterable[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])]">sorted</a>.<span title="(p: ((scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])) =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><a title="(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])" id="scales.utils.collection.path.PathFold.foldPositions.differentRoot.$anonfun.p">p</a> =&gt; <a href="#scales.utils.collection.path.PathFold.foldPositions.differentRoot.$anonfun.p" title="(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])">p</a>.<span title="=&gt; scales.utils.collection.path.Position[Item,Section,CC]">_1</span>.<a href="Paths.scala.html#scales.utils.collection.path;Position.root" title="=&gt; scales.utils.collection.path.Path[Item,Section,CC]">root</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#scales.utils.collection.path.PathFold.foldPositions.rootPosition" title="scales.utils.collection.path.Position[Item,Section,CC]">rootPosition</a>.<a href="Paths.scala.html#scales.utils.collection.path;Position.root" title="=&gt; scales.utils.collection.path.Path[Item,Section,CC]">root</a><span class="delimiter">)</span>
    <span title="Either[(ACC, scales.utils.collection.path.Path[Item,Section,CC]),scales.utils.collection.path.FoldError]" class="keyword">if</span> <span class="delimiter">(</span><a href="#scales.utils.collection.path.PathFold.foldPositions.differentRoot" title="Boolean">differentRoot</a><span class="delimiter">)</span>
      <span title="(b: scales.utils.collection.path.NoSingleRoot.type)scala.util.Right[Nothing,scales.utils.collection.path.NoSingleRoot.type]">Right</span><span class="delimiter">(</span><a href="PathFolds.scala.html#scales.utils.collection.path.NoSingleRoot" title="scales.utils.collection.path.NoSingleRoot.type">NoSingleRoot</a><span class="delimiter">)</span>
    <span class="keyword">else</span> <span class="delimiter">{</span>

      <span class="keyword">def</span> <a title="(opositions: Seq[scales.utils.collection.path.Position[Item,Section,CC]])Either[(ACC, scales.utils.collection.path.Path[Item,Section,CC]),scales.utils.collection.path.FoldError]" id="scales.utils.collection.path.PathFold.foldPositions.withPositions">withPositions</a><span class="delimiter">(</span> <a title="Seq[scales.utils.collection.path.Position[Item,Section,CC]]" id="scales.utils.collection.path.PathFold.foldPositions.withPositions.opositions">opositions</a> : <span title="Seq[scales.utils.collection.path.Position[Item,Section,CC]]">Seq</span><span class="delimiter">[</span>Position<span class="delimiter">[</span>Item,Section,CC<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">)</span> : <span title="Either[(ACC, scales.utils.collection.path.Path[Item,Section,CC]),scales.utils.collection.path.FoldError]">Either</span><span class="delimiter">[</span><span class="delimiter">(</span>ACC, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>, FoldError<span class="delimiter">]</span> = <span class="delimiter">{</span>
	<span class="keyword">var</span> <a title="Seq[scales.utils.collection.path.Position[Item,Section,CC]]" id="scales.utils.collection.path.PathFold.foldPositions.withPositions.positions">positions</a> = <a href="#scales.utils.collection.path.PathFold.foldPositions.withPositions.opositions" title="Seq[scales.utils.collection.path.Position[Item,Section,CC]]">opositions</a>
	<span class="keyword">var</span> <a title="scales.utils.collection.path.Path[Item,Section,CC]" id="scales.utils.collection.path.PathFold.foldPositions.withPositions.path">path</a> = <a href="#scales.utils.collection.path.PathFold.foldPositions.head" title="(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])">head</a>.<span title="=&gt; scales.utils.collection.path.Path[Item,Section,CC]">_2</span>
	<span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#scales.utils.collection.path.PathFold.foldPositions.withPositions.positions" title="Seq[scales.utils.collection.path.Position[Item,Section,CC]]">positions</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#scales.utils.collection.path.PathFold.foldPositions.withPositions.while$1" title="()Unit" class="delimiter">{</a>

          <span class="keyword">val</span> <a href="#scales.utils.collection.path.PathFold.foldPositions.withPositions.accf" title="(ACC, scales.utils.collection.path.FoldOperation[Item,Section,CC])" class="delimiter">(</a><a href="#scales.utils.collection.path.PathFold.foldPositions.withPositions.x$1" title="ACC" id="scales.utils.collection.path.PathFold.foldPositions.withPositions.accf">accf</a>, <a href="#scales.utils.collection.path.PathFold.foldPositions.withPositions.x$1" title="scales.utils.collection.path.FoldOperation[Item,Section,CC]" id="scales.utils.collection.path.PathFold.foldPositions.withPositions.res">res</a><span class="delimiter">)</span> = <a href="#scales.utils.collection.path.PathFold.foldPositions.folder" title="(v1: ACC, v2: scales.utils.collection.path.Path[Item,Section,CC])(ACC, scales.utils.collection.path.FoldOperation[Item,Section,CC])">folder</a><span title="(ACC, scales.utils.collection.path.FoldOperation[Item,Section,CC]) @unchecked" class="delimiter">(</span><a href="#scales.utils.collection.path.PathFold.foldPositions.accum" title="ACC">accum</a>, <a href="#scales.utils.collection.path.PathFold.foldPositions.withPositions.path" title="scales.utils.collection.path.Path[Item,Section,CC]">path</a><span class="delimiter">)</span>
          <a href="#scales.utils.collection.path.PathFold.foldPositions.accum" title="ACC">accum</a> = <a href="#scales.utils.collection.path.PathFold.foldPositions.withPositions.accf" title="ACC">accf</a>
          <span class="keyword">val</span> <a title="scales.utils.FoldR[Item,Section,CC]" id="scales.utils.collection.path.PathFold.foldPositions.withPositions.matched">matched</a> = <a href="#scales.utils.collection.path.PathFold.foldPositions.withPositions.res" title="scales.utils.collection.path.FoldOperation[Item,Section,CC]">res</a>.<a href="PathFolds.scala.html#scales.utils.collection.path;FoldOperation.perform" title="(path: scales.utils.collection.path.Path[Item,Section,CC])scales.utils.FoldR[Item,Section,CC]">perform</a><span class="delimiter">(</span><a href="#scales.utils.collection.path.PathFold.foldPositions.withPositions.path" title="scales.utils.collection.path.Path[Item,Section,CC]">path</a><span class="delimiter">)</span> <span class="comment">//matchIt( res, path )</span>

          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#scales.utils.collection.path.PathFold.foldPositions.withPositions.matched" title="scales.utils.FoldR[Item,Section,CC]">matched</a>.<span title="=&gt; Boolean">isLeft</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <a href="#scales.utils.collection.path.PathFold.foldPositions.withPositions.path" title="scales.utils.collection.path.Path[Item,Section,CC]">path</a> = <a href="#scales.utils.collection.path.PathFold.foldPositions.withPositions.matched" title="scales.utils.FoldR[Item,Section,CC]">matched</a>.<span title="=&gt; scala.util.Either.LeftProjection[scales.utils.collection.path.Path[Item,Section,CC],scales.utils.collection.path.FoldError]">left</span>.<span title="=&gt; scales.utils.collection.path.Path[Item,Section,CC]">get</span>
            <a href="#scales.utils.collection.path.PathFold.foldPositions.withPositions.positions" title="Seq[scales.utils.collection.path.Position[Item,Section,CC]]">positions</a> = <a href="#scales.utils.collection.path.PathFold.foldPositions.withPositions.positions" title="Seq[scales.utils.collection.path.Position[Item,Section,CC]]">positions</a>.<span title="(n: Int)Seq[scales.utils.collection.path.Position[Item,Section,CC]]">drop</span><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#scales.utils.collection.path.PathFold.foldPositions.withPositions.positions" title="Seq[scales.utils.collection.path.Position[Item,Section,CC]]">positions</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span class="delimiter">{</span>
              <a href="#scales.utils.collection.path.PathFold.foldPositions.withPositions.path" title="scales.utils.collection.path.Path[Item,Section,CC]">path</a> = <a href="#scales.utils.collection.path;Paths.moveTo" title="(path: scales.utils.collection.path.Path[Item,Section,CC], newPos: scales.utils.collection.path.Position[Item,Section,CC])(implicit cbf: scales.utils.TreeCBF[Item,Section,CC])scales.utils.collection.path.Path[Item,Section,CC]">moveTo</a><a href="#scales.utils.collection.path.PathFold.foldPositions.cbf" title="scales.utils.TreeCBF[Item,Section,CC]" class="delimiter">(</a><a href="#scales.utils.collection.path.PathFold.foldPositions.withPositions.path" title="scales.utils.collection.path.Path[Item,Section,CC]">path</a>, <a href="#scales.utils.collection.path.PathFold.foldPositions.withPositions.positions" title="Seq[scales.utils.collection.path.Position[Item,Section,CC]]">positions</a>.<span title="=&gt; scales.utils.collection.path.Position[Item,Section,CC]">head</span><span class="delimiter">)</span> <span class="comment">// else nothing we keep path to call root</span>
            <span class="delimiter">}</span>
          <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Nothing" class="keyword">return</span> <span title="(b: scales.utils.collection.path.FoldError)scala.util.Right[Nothing,scales.utils.collection.path.FoldError]">Right</span><span class="delimiter">(</span><a href="#scales.utils.collection.path.PathFold.foldPositions.withPositions.matched" title="scales.utils.FoldR[Item,Section,CC]">matched</a>.<span title="=&gt; scala.util.Either.RightProjection[scales.utils.collection.path.Path[Item,Section,CC],scales.utils.collection.path.FoldError]">right</span>.<span title="=&gt; scales.utils.collection.path.FoldError">get</span><span class="delimiter">)</span>
	<span class="delimiter">}</span>
	<span title="(a: (ACC, scales.utils.collection.path.Path[Item,Section,CC]))scala.util.Left[(ACC, scales.utils.collection.path.Path[Item,Section,CC]),Nothing]">Left</span><span class="delimiter">(</span><span title="(_1: ACC, _2: scales.utils.collection.path.Path[Item,Section,CC])(ACC, scales.utils.collection.path.Path[Item,Section,CC])" class="delimiter">(</span><a href="#scales.utils.collection.path.PathFold.foldPositions.accum" title="ACC">accum</a>, <a href="#scales.utils.collection.path;Paths.rootPath" title="(path: scales.utils.collection.path.Path[Item,Section,CC])scales.utils.collection.path.Path[Item,Section,CC]">rootPath</a><span class="delimiter">(</span><a href="#scales.utils.collection.path.PathFold.foldPositions.withPositions.path" title="scales.utils.collection.path.Path[Item,Section,CC]">path</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>

      <span class="comment">// fold over positions, with the path from head, let each foldop decide what the next position sequence looks like</span>
      <span class="keyword">var</span> <a title="Seq[scales.utils.collection.path.Position[Item,Section,CC]]" id="scales.utils.collection.path.PathFold.foldPositions.positions">positions</a> = <a href="#scales.utils.collection.path.PathFold.foldPositions.sorted" title="Iterable[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])]">sorted</a>.<span title="(f: ((scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])) =&gt; scales.utils.collection.path.Position[Item,Section,CC])(implicit bf: scala.collection.generic.CanBuildFrom[Iterable[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])],scales.utils.collection.path.Position[Item,Section,CC],Iterable[scales.utils.collection.path.Position[Item,Section,CC]]])Iterable[scales.utils.collection.path.Position[Item,Section,CC]]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Iterable.Coll,scales.utils.collection.path.Position[Item,Section,CC],Iterable[scales.utils.collection.path.Position[Item,Section,CC]]]" class="delimiter">(</span><a href="#scales.utils.collection.path.PathFold.foldPositions.positions.$anonfun.x$2" title="(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])">_</a>.<span title="=&gt; scales.utils.collection.path.Position[Item,Section,CC]">_1</span><span class="delimiter">)</span>.<span title="=&gt; Seq[scales.utils.collection.path.Position[Item,Section,CC]]">toSeq</span>
	
      <a href="#scales.utils.collection.path.PathFold.foldPositions.withPositions" title="(opositions: Seq[scales.utils.collection.path.Position[Item,Section,CC]])Either[(ACC, scales.utils.collection.path.Path[Item,Section,CC]),scales.utils.collection.path.FoldError]">withPositions</a><span class="delimiter">(</span><a href="#scales.utils.collection.path.PathFold.foldPositions.positions" title="Seq[scales.utils.collection.path.Position[Item,Section,CC]]">positions</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

<span class="delimiter">}</span>

<span class="comment">/**
 * Utility functions for Paths, sorting, moving between Paths, getting to the root etc.
 */</span> 
<span title="AnyRef" class="keyword">trait</span> <a title="trait Paths extends AnyRef" id="scales.utils.collection.path;Paths">Paths</a> <span title="Unit" class="delimiter">{</span>
  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](implicit cbf: scales.utils.TreeCBF[Item,Section,CC])scales.utils.collection.path.Path[Item,Section,CC]" id="scales.utils.collection.path;Paths.noPath">noPath</a><span class="delimiter">[</span><a title=" &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]]" id="scales.utils.collection.path;Paths.noPath;Item">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection.path;Paths.noPath;Section">Section</a>, <a title="[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="scales.utils.collection.path;Paths.noPath;CC">CC</a><span class="delimiter">[</span><a title="" id="scales.utils.collection.path;Paths.noPath;CC;X">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span>
    <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scales.utils.TreeCBF[Item,Section,CC]" id="scales.utils.collection.path;Paths.noPath.cbf">cbf</a> : <span title="scales.utils.TreeCBF[Item,Section,CC]">TreeCBF</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>  = <a href="#scales.utils.collection.path;Paths.noPath;$anon" title="scales.utils.collection.path.Path[Item,Section,CC]" class="keyword">new</a> <a title="anonymous class $anon extends scales.utils.collection.path.Path[Item,Section,CC]" id="scales.utils.collection.path;Paths.noPath;$anon">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">(</span><a href="Paths.scala.html#scales.utils.collection.path;Top" title="()scales.utils.collection.path.Top[Item,Section,CC]">Top</a><span class="delimiter">(</span><span class="delimiter">)</span>, <a href="Paths.scala.html#scales.utils.collection.path;Node" title="(index: Int, focus: scales.utils.ItemOrTree[Item,Section,CC])scales.utils.collection.path.Node[Item,Section,CC]">Node</a><span class="delimiter">(</span>-<span title="Int(-1)" class="int">1</span>, <span title="Null(null)" class="keyword">null</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="scales.utils.ItemOrTree[Item,Section,CC]" class="delimiter">[</span><a href="../../EitherLike.scala.html#scales.utils;EitherLike" title="scales.utils.ItemOrTree[Item,Section,CC]">ItemOrTree</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns the root path for its input, uses zipUp to ensure changes are kept
   */</span>
  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](path: scales.utils.collection.path.Path[Item,Section,CC])scales.utils.collection.path.Path[Item,Section,CC]" id="scales.utils.collection.path;Paths.rootPath">rootPath</a><span class="delimiter">[</span><a title=" &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]]" id="scales.utils.collection.path;Paths.rootPath;Item">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection.path;Paths.rootPath;Section">Section</a>, <a title="[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="scales.utils.collection.path;Paths.rootPath;CC">CC</a><span class="delimiter">[</span><a title="" id="scales.utils.collection.path;Paths.rootPath;CC;X">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="scales.utils.collection.path.Path[Item,Section,CC]" id="scales.utils.collection.path;Paths.rootPath.path">path</a>: <a href="Paths.scala.html#scales.utils.collection.path;Path" title="scales.utils.collection.path.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Paths.scala.html#scales.utils.collection.path;Path" title="scales.utils.collection.path.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">var</span> <a title="scales.utils.collection.path.Path[Item,Section,CC]" id="scales.utils.collection.path;Paths.rootPath.newPath">newPath</a> = <a href="#scales.utils.collection.path;Paths.rootPath.path" title="scales.utils.collection.path.Path[Item,Section,CC]">path</a>
    <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#scales.utils.collection.path;Paths.rootPath.newPath" title="scales.utils.collection.path.Path[Item,Section,CC]">newPath</a>.<a href="Paths.scala.html#scales.utils.collection.path;Path.top" title="=&gt; scales.utils.EitherLike[scales.utils.collection.path.Top[Item,Section,CC],scales.utils.collection.path.Path[Item,Section,CC]]">top</a>.<a href="../../EitherLike.scala.html#scales.utils;EitherLike.isLeft" title="=&gt; Boolean">isLeft</a><span class="delimiter">)</span>
      <a href="#scales.utils.collection.path;Paths.rootPath.newPath" title="scales.utils.collection.path.Path[Item,Section,CC]">newPath</a> = <a href="#scales.utils.collection.path;Paths.rootPath.newPath" title="scales.utils.collection.path.Path[Item,Section,CC]">newPath</a>.<a href="Paths.scala.html#scales.utils.collection.path;Path.zipUp" title="()scales.utils.collection.path.Path[Item,Section,CC]">zipUp</a>
    <a href="#scales.utils.collection.path;Paths.rootPath.newPath" title="scales.utils.collection.path.Path[Item,Section,CC]">newPath</a>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Navigates the path until the new position is reached, throws if either its a new root or the position is not reachable
   */</span>
  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](path: scales.utils.collection.path.Path[Item,Section,CC], newPos: scales.utils.collection.path.Position[Item,Section,CC])(implicit cbf: scales.utils.TreeCBF[Item,Section,CC])scales.utils.collection.path.Path[Item,Section,CC]" id="scales.utils.collection.path;Paths.moveTo">moveTo</a><span class="delimiter">[</span><a title=" &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]]" id="scales.utils.collection.path;Paths.moveTo;Item">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection.path;Paths.moveTo;Section">Section</a>, <a title="[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="scales.utils.collection.path;Paths.moveTo;CC">CC</a><span class="delimiter">[</span><a title="" id="scales.utils.collection.path;Paths.moveTo;CC;X">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="scales.utils.collection.path.Path[Item,Section,CC]" id="scales.utils.collection.path;Paths.moveTo.path">path</a>: <a href="Paths.scala.html#scales.utils.collection.path;Path" title="scales.utils.collection.path.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, <a title="scales.utils.collection.path.Position[Item,Section,CC]" id="scales.utils.collection.path;Paths.moveTo.newPos">newPos</a>: <a href="Paths.scala.html#scales.utils.collection.path;Position" title="scales.utils.collection.path.Position[Item,Section,CC]">Position</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>
    <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scales.utils.TreeCBF[Item,Section,CC]" id="scales.utils.collection.path;Paths.moveTo.cbf">cbf</a> : <span title="scales.utils.TreeCBF[Item,Section,CC]">TreeCBF</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> : <a href="Paths.scala.html#scales.utils.collection.path;Path" title="scales.utils.collection.path.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> = <span class="delimiter">{</span>

    <span class="keyword">val</span> <a title="scales.utils.collection.path.Path[Item,Section,CC]" id="scales.utils.collection.path;Paths.moveTo.root">root</a> = <a href="#scales.utils.collection.path;Paths.rootPath" title="(path: scales.utils.collection.path.Path[Item,Section,CC])scales.utils.collection.path.Path[Item,Section,CC]">rootPath</a><span class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.moveTo.path" title="scales.utils.collection.path.Path[Item,Section,CC]">path</a><span class="delimiter">)</span>
    <span class="comment">// cheaty way, crap but quick enough</span>
    <span class="comment">// TODO come back to this and properly move,</span>
    <a href="#scales.utils.collection.path;Paths.moveTo.newPos" title="scales.utils.collection.path.Position[Item,Section,CC]">newPos</a>.<a href="Paths.scala.html#scales.utils.collection.path;Position.position" title="=&gt; scala.collection.immutable.Stack[Int]">position</a>.<span title="=&gt; scala.collection.immutable.Stack[Int]">pop</span>.<span title="(z: scales.utils.collection.path.Path[Item,Section,CC])(f: (scales.utils.collection.path.Path[Item,Section,CC], Int) =&gt; scales.utils.collection.path.Path[Item,Section,CC])scales.utils.collection.path.Path[Item,Section,CC]">foldLeft</span><span class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.moveTo.root" title="scales.utils.collection.path.Path[Item,Section,CC]">root</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="scales.utils.collection.path.Path[Item,Section,CC]" id="scales.utils.collection.path;Paths.moveTo.$anonfun.path">path</a>, <a title="Int" id="scales.utils.collection.path;Paths.moveTo.$anonfun.pos">pos</a><span title="Int" class="delimiter">)</span> =&gt;
      <a href="Paths.scala.html#scales.utils.collection.path;Path" title="(top: scales.utils.EitherLike[scales.utils.collection.path.Top[Item,Section,CC],scales.utils.collection.path.Path[Item,Section,CC]], node: scales.utils.collection.path.Node[Item,Section,CC])(implicit cbf: scala.collection.generic.CanBuildFrom[CC[_],scales.utils.ItemOrTree[Item,Section,CC],CC[scales.utils.ItemOrTree[Item,Section,CC]]])scales.utils.collection.path.Path[Item,Section,CC]">Path</a><a href="#scales.utils.collection.path;Paths.moveTo.cbf" title="scales.utils.TreeCBF[Item,Section,CC]" class="delimiter">(</a><a href="#scales.utils.collection.path;Paths.moveTo.$anonfun.path" title="scales.utils.collection.path.Path[Item,Section,CC]">path</a>, <a href="Paths.scala.html#scales.utils.collection.path;Node" title="(index: Int, focus: scales.utils.ItemOrTree[Item,Section,CC])scales.utils.collection.path.Node[Item,Section,CC]">Node</a><span class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.moveTo.$anonfun.pos" title="Int">pos</a>, <a href="#scales.utils.collection.path;Paths.moveTo.$anonfun.path" title="scales.utils.collection.path.Path[Item,Section,CC]">path</a>.<a href="Paths.scala.html#scales.utils.collection.path;Path.children" title="(idx: Int)scales.utils.ItemOrTree[Item,Section,CC]">children</a><span class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.moveTo.$anonfun.pos" title="Int">pos</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">type</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]]Either[scales.utils.collection.path.Path[Item,Section,CC],scales.utils.collection.path.FoldError]" id="scales.utils.collection.path;Paths;FoldR">FoldR</a><span class="delimiter">[</span><a title=" &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]]" id="scales.utils.collection.path;Paths;FoldR;Item">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection.path;Paths;FoldR;Section">Section</a>, <a title="[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="scales.utils.collection.path;Paths;FoldR;CC">CC</a><span class="delimiter">[</span><a title="" id="scales.utils.collection.path;Paths;FoldR;CC;X">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> = <span title="Either[scales.utils.collection.path.Path[Item,Section,CC],scales.utils.collection.path.FoldError]">Either</span><span class="delimiter">[</span>Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, FoldError<span class="delimiter">]</span>

  <span class="keyword">type</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]]scales.utils.collection.path.Path[Item,Section,CC] =&gt; Paths.this.FoldR[Item,Section,CC]" id="scales.utils.collection.path;Paths;PathFoldR">PathFoldR</a><span class="delimiter">[</span><a title=" &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]]" id="scales.utils.collection.path;Paths;PathFoldR;Item">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection.path;Paths;PathFoldR;Section">Section</a>, <a title="[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="scales.utils.collection.path;Paths;PathFoldR;CC">CC</a><span class="delimiter">[</span><a title="" id="scales.utils.collection.path;Paths;PathFoldR;CC;X">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">(</span>Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; FoldR<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>

  <span class="comment">/**
   * As per the non accumalating version, folds over positions within a given tree but allows for an additional accumalation.
   * 
   * The progress through the document is in reverse document order.  This ensures that transformations can always be safely composed, e.g. a delete of a path won't stop changes below it.  This, however, implies the developer must also handle any accumulation in &quot;reverse&quot;. 
   */</span> 
  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]], ACC](locations: Iterable[scales.utils.collection.path.Path[Item,Section,CC]], accumulator: ACC)(folder: (ACC, scales.utils.collection.path.Path[Item,Section,CC]) =&gt; (ACC, scales.utils.collection.path.FoldOperation[Item,Section,CC]))(implicit cbf: scales.utils.TreeCBF[Item,Section,CC], implicit cm: ClassManifest[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])])Either[(ACC, scales.utils.collection.path.Path[Item,Section,CC]),scales.utils.collection.path.FoldError]" id="scales.utils.collection.path;Paths.foldPositions(47a5a8bb7e)">foldPositions</a><span class="delimiter">[</span><a title=" &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]]" id="scales.utils.collection.path;Paths.foldPositions(47a5a8bb7e);Item">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection.path;Paths.foldPositions(47a5a8bb7e);Section">Section</a>, <a title="[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="scales.utils.collection.path;Paths.foldPositions(47a5a8bb7e);CC">CC</a><span class="delimiter">[</span><a title="" id="scales.utils.collection.path;Paths.foldPositions(47a5a8bb7e);CC;X">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection.path;Paths.foldPositions(47a5a8bb7e);ACC">ACC</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Iterable[scales.utils.collection.path.Path[Item,Section,CC]]" id="scales.utils.collection.path;Paths.foldPositions(47a5a8bb7e).locations">locations</a>: <span title="Iterable[scales.utils.collection.path.Path[Item,Section,CC]]">Iterable</span><span class="delimiter">[</span>Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="ACC" id="scales.utils.collection.path;Paths.foldPositions(47a5a8bb7e).accumulator">accumulator</a>: <a href="#scales.utils.collection.path;Paths.foldPositions(47a5a8bb7e);ACC" title="ACC">ACC</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(ACC, scales.utils.collection.path.Path[Item,Section,CC]) =&gt; (ACC, scales.utils.collection.path.FoldOperation[Item,Section,CC])" id="scales.utils.collection.path;Paths.foldPositions(47a5a8bb7e).folder">folder</a>: <span class="delimiter">(</span>ACC, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; <span class="delimiter">(</span>ACC, FoldOperation<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scales.utils.TreeCBF[Item,Section,CC]" id="scales.utils.collection.path;Paths.foldPositions(47a5a8bb7e).cbf">cbf</a> : <span title="scales.utils.TreeCBF[Item,Section,CC]">TreeCBF</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, <a title="ClassManifest[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])]" id="scales.utils.collection.path;Paths.foldPositions(47a5a8bb7e).cm">cm</a> : <span title="ClassManifest[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])]">ClassManifest</span><span class="delimiter">[</span><span class="delimiter">(</span>Position<span class="delimiter">[</span>Item,Section,CC<span class="delimiter">]</span>, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span>  : <span title="Either[(ACC, scales.utils.collection.path.Path[Item,Section,CC]),scales.utils.collection.path.FoldError]">Either</span><span class="delimiter">[</span><span class="delimiter">(</span>ACC, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>, FoldError<span class="delimiter">]</span> = <a href="#scales.utils.collection.path.PathFold" title="scales.utils.collection.path.PathFold.type">PathFold</a>.<a href="#scales.utils.collection.path.PathFold.foldPositions" title="(locations: Iterable[scales.utils.collection.path.Path[Item,Section,CC]], accumulator: ACC)(folder: (ACC, scales.utils.collection.path.Path[Item,Section,CC]) =&gt; (ACC, scales.utils.collection.path.FoldOperation[Item,Section,CC]))(implicit cbf: scales.utils.TreeCBF[Item,Section,CC], implicit cm: ClassManifest[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])])Either[(ACC, scales.utils.collection.path.Path[Item,Section,CC]),scales.utils.collection.path.FoldError]">foldPositions</a><span class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.foldPositions(47a5a8bb7e).locations" title="Iterable[scales.utils.collection.path.Path[Item,Section,CC]]">locations</a>, <a href="#scales.utils.collection.path;Paths.foldPositions(47a5a8bb7e).accumulator" title="ACC">accumulator</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.foldPositions(47a5a8bb7e).folder" title="(ACC, scales.utils.collection.path.Path[Item,Section,CC]) =&gt; (ACC, scales.utils.collection.path.FoldOperation[Item,Section,CC])">folder</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.foldPositions(47a5a8bb7e).cbf" title="scales.utils.TreeCBF[Item,Section,CC]">cbf</a>, <a href="#scales.utils.collection.path;Paths.foldPositions(47a5a8bb7e).cm" title="ClassManifest[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])]">cm</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Folds over positions within a single path, for example all given children.  As such positions must be calculated.
   *
   * Takes the first root, returning Right(NoSingleRoot) if any of the subsequent roots don't match.
   *
   * folder retrieves the current path
   *
   * Each iteration folds the resulting tree back into the path. As this function must maintain the Path it does not expose the new path root until the result.
   */</span>
  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](locations: Iterable[scales.utils.collection.path.Path[Item,Section,CC]])(folder: scales.utils.collection.path.Path[Item,Section,CC] =&gt; scales.utils.collection.path.FoldOperation[Item,Section,CC])(implicit cbf: scales.utils.TreeCBF[Item,Section,CC], implicit cm: ClassManifest[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])])Paths.this.FoldR[Item,Section,CC]" id="scales.utils.collection.path;Paths.foldPositions(59a5d52af9)">foldPositions</a><span class="delimiter">[</span><a title=" &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]]" id="scales.utils.collection.path;Paths.foldPositions(59a5d52af9);Item">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection.path;Paths.foldPositions(59a5d52af9);Section">Section</a>, <a title="[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="scales.utils.collection.path;Paths.foldPositions(59a5d52af9);CC">CC</a><span class="delimiter">[</span><a title="" id="scales.utils.collection.path;Paths.foldPositions(59a5d52af9);CC;X">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="Iterable[scales.utils.collection.path.Path[Item,Section,CC]]" id="scales.utils.collection.path;Paths.foldPositions(59a5d52af9).locations">locations</a>: <span title="Iterable[scales.utils.collection.path.Path[Item,Section,CC]]">Iterable</span><span class="delimiter">[</span>Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="scales.utils.collection.path.Path[Item,Section,CC] =&gt; scales.utils.collection.path.FoldOperation[Item,Section,CC]" id="scales.utils.collection.path;Paths.foldPositions(59a5d52af9).folder">folder</a>: <span class="delimiter">(</span>Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; FoldOperation<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scales.utils.TreeCBF[Item,Section,CC]" id="scales.utils.collection.path;Paths.foldPositions(59a5d52af9).cbf">cbf</a> : <span title="scales.utils.TreeCBF[Item,Section,CC]">TreeCBF</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, <a title="ClassManifest[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])]" id="scales.utils.collection.path;Paths.foldPositions(59a5d52af9).cm">cm</a> : <span title="ClassManifest[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])]">ClassManifest</span><span class="delimiter">[</span><span class="delimiter">(</span>Position<span class="delimiter">[</span>Item,Section,CC<span class="delimiter">]</span>, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span> : <span title="Paths.this.FoldR[Item,Section,CC]">FoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> =
    <a href="#scales.utils.collection.path;Paths.foldPositions(47a5a8bb7e)" title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]], ACC](locations: Iterable[scales.utils.collection.path.Path[Item,Section,CC]], accumulator: ACC)(folder: (ACC, scales.utils.collection.path.Path[Item,Section,CC]) =&gt; (ACC, scales.utils.collection.path.FoldOperation[Item,Section,CC]))(implicit cbf: scales.utils.TreeCBF[Item,Section,CC], implicit cm: ClassManifest[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])])Either[(ACC, scales.utils.collection.path.Path[Item,Section,CC]),scales.utils.collection.path.FoldError]">foldPositions</a><span title="(locations: Iterable[scales.utils.collection.path.Path[Item,Section,CC]], accumulator: Unit)(folder: (Unit, scales.utils.collection.path.Path[Item,Section,CC]) =&gt; (Unit, scales.utils.collection.path.FoldOperation[Item,Section,CC]))(implicit cbf: scales.utils.TreeCBF[Item,Section,CC], implicit cm: ClassManifest[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])])Either[(Unit, scales.utils.collection.path.Path[Item,Section,CC]),scales.utils.collection.path.FoldError]" class="delimiter">[</span><a href="#scales.utils.collection.path;Paths.foldPositions(59a5d52af9);Item" title="Item">Item</a>, <a href="#scales.utils.collection.path;Paths.foldPositions(59a5d52af9);Section" title="Section">Section</a>, <a href="#scales.utils.collection.path;Paths.foldPositions(59a5d52af9);CC" title="CC">CC</a>, <span title="Unit">Unit</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.foldPositions(59a5d52af9).locations" title="Iterable[scales.utils.collection.path.Path[Item,Section,CC]]">locations</a>, <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><a href="#scales.utils.collection.path;Paths.foldPositions(59a5d52af9).cbf" title="scales.utils.TreeCBF[Item,Section,CC]" class="delimiter">(</a><span class="delimiter">(</span><a title="Unit" id="scales.utils.collection.path;Paths.foldPositions(59a5d52af9).$anonfun.u">u</a>, <a title="scales.utils.collection.path.Path[Item,Section,CC]" id="scales.utils.collection.path;Paths.foldPositions(59a5d52af9).$anonfun.p">p</a><a href="Paths.scala.html#scales.utils.collection.path;Path" title="scales.utils.collection.path.Path[Item,Section,CC]" class="delimiter">)</a> =&gt; <span title="(_1: Unit, _2: scales.utils.collection.path.FoldOperation[Item,Section,CC])(Unit, scales.utils.collection.path.FoldOperation[Item,Section,CC])" class="delimiter">(</span><span title="Unit" class="delimiter">(</span><span class="delimiter">)</span>, <a href="#scales.utils.collection.path;Paths.foldPositions(59a5d52af9).folder" title="(v1: scales.utils.collection.path.Path[Item,Section,CC])scales.utils.collection.path.FoldOperation[Item,Section,CC]">folder</a><span class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.foldPositions(59a5d52af9).$anonfun.p" title="scales.utils.collection.path.Path[Item,Section,CC]">p</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>.
      <span title="(fa: ((Unit, scales.utils.collection.path.Path[Item,Section,CC])) =&gt; Product with Serializable with scala.util.Either[scales.utils.collection.path.Path[Item,Section,CC],scales.utils.collection.path.FoldError], fb: scales.utils.collection.path.FoldError =&gt; Product with Serializable with scala.util.Either[scales.utils.collection.path.Path[Item,Section,CC],scales.utils.collection.path.FoldError])Product with Serializable with scala.util.Either[scales.utils.collection.path.Path[Item,Section,CC],scales.utils.collection.path.FoldError]">fold</span><span class="delimiter">(</span><a title="(Unit, scales.utils.collection.path.Path[Item,Section,CC])" id="scales.utils.collection.path;Paths.foldPositions(59a5d52af9).$anonfun.x">x</a> =&gt; <span title="(a: scales.utils.collection.path.Path[Item,Section,CC])scala.util.Left[scales.utils.collection.path.Path[Item,Section,CC],Nothing]">Left</span><span class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.foldPositions(59a5d52af9).$anonfun.x" title="(Unit, scales.utils.collection.path.Path[Item,Section,CC])">x</a>.<span title="=&gt; scales.utils.collection.path.Path[Item,Section,CC]">_2</span><span class="delimiter">)</span>, <span title="(b: scales.utils.collection.path.FoldError)scala.util.Right[Nothing,scales.utils.collection.path.FoldError]">Right</span><span class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.foldPositions(59a5d52af9).$anonfun.x$3" title="scales.utils.collection.path.FoldError">_</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="keyword">val</span> <a title="Int" id="scales.utils.collection.path;Paths.NotSameRoot">NotSameRoot</a> = <span title="Int(1000)" class="int">1000</span>

  <span class="comment">/**
   * When paths are not in the same root, they are compared based on the identity hash of the given roots.  Of course this relies on that function
   * having a decent vm implementation.
   *
   * @param path1
   * @param path2
   * @return 1 if path1 is before path2, -1 if path2 is before path1, 0 if they are the same and NotSameRoot+-1 if they are not in the same root
   */</span>
  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](path1: scales.utils.collection.path.Position[Item,Section,CC], path2: scales.utils.collection.path.Position[Item,Section,CC])Int" id="scales.utils.collection.path;Paths.comparePathPositions">comparePathPositions</a><span class="delimiter">[</span><a title=" &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]]" id="scales.utils.collection.path;Paths.comparePathPositions;Item">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection.path;Paths.comparePathPositions;Section">Section</a>, <a title="[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="scales.utils.collection.path;Paths.comparePathPositions;CC">CC</a><span class="delimiter">[</span><a title="" id="scales.utils.collection.path;Paths.comparePathPositions;CC;X">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="scales.utils.collection.path.Position[Item,Section,CC]" id="scales.utils.collection.path;Paths.comparePathPositions.path1">path1</a>: <a href="Paths.scala.html#scales.utils.collection.path;Position" title="scales.utils.collection.path.Position[Item,Section,CC]">Position</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, <a title="scales.utils.collection.path.Position[Item,Section,CC]" id="scales.utils.collection.path;Paths.comparePathPositions.path2">path2</a>: <a href="Paths.scala.html#scales.utils.collection.path;Position" title="scales.utils.collection.path.Position[Item,Section,CC]">Position</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <span class="delimiter">{</span>

    <span title="Int" class="keyword">if</span> <span class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.comparePathPositions.path1" title="scales.utils.collection.path.Position[Item,Section,CC]">path1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scales.utils.collection.path;Paths.comparePathPositions.path2" title="scales.utils.collection.path.Position[Item,Section,CC]">path2</a><span class="delimiter">)</span> <span title="Int(0)" class="int">0</span>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <span title="Int" class="keyword">if</span> <span class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.comparePathPositions.path1" title="scales.utils.collection.path.Position[Item,Section,CC]">path1</a>.<a href="Paths.scala.html#scales.utils.collection.path;Position.root" title="=&gt; scales.utils.collection.path.Path[Item,Section,CC]">root</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#scales.utils.collection.path;Paths.comparePathPositions.path2" title="scales.utils.collection.path.Position[Item,Section,CC]">path2</a>.<a href="Paths.scala.html#scales.utils.collection.path;Position.root" title="=&gt; scales.utils.collection.path.Path[Item,Section,CC]">root</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Int" id="scales.utils.collection.path;Paths.comparePathPositions.p1R">p1R</a> = <span title="System.type">System</span>.<span title="(x$1: Any)Int">identityHashCode</span><span class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.comparePathPositions.path1" title="scales.utils.collection.path.Position[Item,Section,CC]">path1</a>.<a href="Paths.scala.html#scales.utils.collection.path;Position.root" title="=&gt; scales.utils.collection.path.Path[Item,Section,CC]">root</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Int" id="scales.utils.collection.path;Paths.comparePathPositions.p2R">p2R</a> = <span title="System.type">System</span>.<span title="(x$1: Any)Int">identityHashCode</span><span class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.comparePathPositions.path2" title="scales.utils.collection.path.Position[Item,Section,CC]">path2</a>.<a href="Paths.scala.html#scales.utils.collection.path;Position.root" title="=&gt; scales.utils.collection.path.Path[Item,Section,CC]">root</a><span class="delimiter">)</span>
        <a href="#scales.utils.collection.path;Paths.NotSameRoot" title="=&gt; Int">NotSameRoot</a> <span title="(x: Int)Int">+</span> <span class="delimiter">(</span><span title="Int" class="keyword">if</span> <span class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.comparePathPositions.p1R" title="Int">p1R</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#scales.utils.collection.path;Paths.comparePathPositions.p2R" title="Int">p2R</a><span class="delimiter">)</span> <span title="Int(1)" class="int">1</span> <span class="keyword">else</span> -<span title="Int(-1)" class="int">1</span><span class="delimiter">)</span>
      <span class="delimiter">}</span> <span class="keyword">else</span>
        <a href="../StackUtils.scala.html#scales.utils.collection;StackUtils.compareStack" title="(p1: scala.collection.immutable.Stack[Int], p2: scala.collection.immutable.Stack[Int])Int">compareStack</a><span class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.comparePathPositions.path1" title="scales.utils.collection.path.Position[Item,Section,CC]">path1</a>.<a href="Paths.scala.html#scales.utils.collection.path;Position.position" title="=&gt; scala.collection.immutable.Stack[Int]">position</a>, <a href="#scales.utils.collection.path;Paths.comparePathPositions.path2" title="scales.utils.collection.path.Position[Item,Section,CC]">path2</a>.<a href="Paths.scala.html#scales.utils.collection.path;Position.position" title="=&gt; scala.collection.immutable.Stack[Int]">position</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Helper for comparePaths, will not evaluate position if the paths are equal
   */</span>
  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](path1: scales.utils.collection.path.Path[Item,Section,CC], path2: scales.utils.collection.path.Path[Item,Section,CC])Boolean" id="scales.utils.collection.path;Paths.comparePathsDirect">comparePathsDirect</a><span class="delimiter">[</span><a title=" &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]]" id="scales.utils.collection.path;Paths.comparePathsDirect;Item">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection.path;Paths.comparePathsDirect;Section">Section</a>, <a title="[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="scales.utils.collection.path;Paths.comparePathsDirect;CC">CC</a><span class="delimiter">[</span><a title="" id="scales.utils.collection.path;Paths.comparePathsDirect;CC;X">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="scales.utils.collection.path.Path[Item,Section,CC]" id="scales.utils.collection.path;Paths.comparePathsDirect.path1">path1</a>: <a href="Paths.scala.html#scales.utils.collection.path;Path" title="scales.utils.collection.path.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, <a title="scales.utils.collection.path.Path[Item,Section,CC]" id="scales.utils.collection.path;Paths.comparePathsDirect.path2">path2</a>: <a href="Paths.scala.html#scales.utils.collection.path;Path" title="scales.utils.collection.path.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
    <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.comparePathsDirect.path1" title="scales.utils.collection.path.Path[Item,Section,CC]">path1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scales.utils.collection.path;Paths.comparePathsDirect.path2" title="scales.utils.collection.path.Path[Item,Section,CC]">path2</a><span class="delimiter">)</span>
      <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">else</span>
      <a href="#scales.utils.collection.path;Paths.comparePathsP" title="(path1: (scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC]), path2: (scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC]))(Int, scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Position[Item,Section,CC])">comparePathsP</a><span class="delimiter">(</span><span title="(_1: scales.utils.collection.path.Position[Item,Section,CC], _2: scales.utils.collection.path.Path[Item,Section,CC])(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])" class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.comparePathsDirect.path1" title="scales.utils.collection.path.Path[Item,Section,CC]">path1</a>.<a href="Paths.scala.html#scales.utils.collection.path;Path.position" title="()scales.utils.collection.path.Position[Item,Section,CC]">position</a>, <a href="#scales.utils.collection.path;Paths.comparePathsDirect.path1" title="scales.utils.collection.path.Path[Item,Section,CC]">path1</a><span class="delimiter">)</span>, <span title="(_1: scales.utils.collection.path.Position[Item,Section,CC], _2: scales.utils.collection.path.Path[Item,Section,CC])(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])" class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.comparePathsDirect.path2" title="scales.utils.collection.path.Path[Item,Section,CC]">path2</a>.<a href="Paths.scala.html#scales.utils.collection.path;Path.position" title="()scales.utils.collection.path.Position[Item,Section,CC]">position</a>, <a href="#scales.utils.collection.path;Paths.comparePathsDirect.path2" title="scales.utils.collection.path.Path[Item,Section,CC]">path2</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="=&gt; Int">_1</span> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span>

  <span class="comment">/**
   * When paths are not in the same root, they are compared based on the identity hash of the given roots.  Of course this relies on that function
   * having a decent vm implementation. See http://www.w3.org/TR/2007/REC-xpath20-20070123/#dt-document-order, tree order must remain constant.  Its
   * also a pretty sensible approach for non xml trees.
   *
   * @param path1
   * @param path2
   * @return 1 if path1 is before path2, -1 if path2 is before path1, 0 if they are the same and NotSameRoot+-1 if they are not in the same root
   */</span>
  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](path1: scales.utils.collection.path.Path[Item,Section,CC], path2: scales.utils.collection.path.Path[Item,Section,CC])(Int, scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Position[Item,Section,CC])" id="scales.utils.collection.path;Paths.comparePaths">comparePaths</a><span class="delimiter">[</span><a title=" &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]]" id="scales.utils.collection.path;Paths.comparePaths;Item">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection.path;Paths.comparePaths;Section">Section</a>, <a title="[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="scales.utils.collection.path;Paths.comparePaths;CC">CC</a><span class="delimiter">[</span><a title="" id="scales.utils.collection.path;Paths.comparePaths;CC;X">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="scales.utils.collection.path.Path[Item,Section,CC]" id="scales.utils.collection.path;Paths.comparePaths.path1">path1</a>: <a href="Paths.scala.html#scales.utils.collection.path;Path" title="scales.utils.collection.path.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, <a title="scales.utils.collection.path.Path[Item,Section,CC]" id="scales.utils.collection.path;Paths.comparePaths.path2">path2</a>: <a href="Paths.scala.html#scales.utils.collection.path;Path" title="scales.utils.collection.path.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(Int, scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Position[Item,Section,CC])" class="delimiter">(</span>Int, Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> =
    <a href="#scales.utils.collection.path;Paths.comparePathsP" title="(path1: (scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC]), path2: (scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC]))(Int, scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Position[Item,Section,CC])">comparePathsP</a><span class="delimiter">(</span><span title="(_1: scales.utils.collection.path.Position[Item,Section,CC], _2: scales.utils.collection.path.Path[Item,Section,CC])(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])" class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.comparePaths.path1" title="scales.utils.collection.path.Path[Item,Section,CC]">path1</a>.<a href="Paths.scala.html#scales.utils.collection.path;Path.position" title="()scales.utils.collection.path.Position[Item,Section,CC]">position</a>, <a href="#scales.utils.collection.path;Paths.comparePaths.path1" title="scales.utils.collection.path.Path[Item,Section,CC]">path1</a><span class="delimiter">)</span>, <span title="(_1: scales.utils.collection.path.Position[Item,Section,CC], _2: scales.utils.collection.path.Path[Item,Section,CC])(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])" class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.comparePaths.path2" title="scales.utils.collection.path.Path[Item,Section,CC]">path2</a>.<a href="Paths.scala.html#scales.utils.collection.path;Path.position" title="()scales.utils.collection.path.Position[Item,Section,CC]">position</a>, <a href="#scales.utils.collection.path;Paths.comparePaths.path2" title="scales.utils.collection.path.Path[Item,Section,CC]">path2</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](path1: (scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC]), path2: (scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC]))(Int, scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Position[Item,Section,CC])" id="scales.utils.collection.path;Paths.comparePathsP">comparePathsP</a><span class="delimiter">[</span><a title=" &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]]" id="scales.utils.collection.path;Paths.comparePathsP;Item">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection.path;Paths.comparePathsP;Section">Section</a>, <a title="[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="scales.utils.collection.path;Paths.comparePathsP;CC">CC</a><span class="delimiter">[</span><a title="" id="scales.utils.collection.path;Paths.comparePathsP;CC;X">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])" id="scales.utils.collection.path;Paths.comparePathsP.path1">path1</a>: <span title="(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])" class="delimiter">(</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>, <a title="(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])" id="scales.utils.collection.path;Paths.comparePathsP.path2">path2</a>: <span title="(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])" class="delimiter">(</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span>: <span title="(Int, scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Position[Item,Section,CC])" class="delimiter">(</span>Int, Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span title="(Int, scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Position[Item,Section,CC])" class="keyword">if</span> <span class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.comparePathsP.path1" title="(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])">path1</a>.<span title="=&gt; scales.utils.collection.path.Path[Item,Section,CC]">_2</span> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scales.utils.collection.path;Paths.comparePathsP.path2" title="(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])">path2</a>.<span title="=&gt; scales.utils.collection.path.Path[Item,Section,CC]">_2</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="scales.utils.collection.path.Position[Item,Section,CC]" id="scales.utils.collection.path;Paths.comparePathsP.pos">pos</a> = <a href="#scales.utils.collection.path;Paths.comparePathsP.path1" title="(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])">path1</a>.<span title="=&gt; scales.utils.collection.path.Position[Item,Section,CC]">_1</span>
      <span title="(_1: Int, _2: scales.utils.collection.path.Position[Item,Section,CC], _3: scales.utils.collection.path.Position[Item,Section,CC])(Int, scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Position[Item,Section,CC])" class="delimiter">(</span><span title="Int(0)" class="int">0</span>, <a href="#scales.utils.collection.path;Paths.comparePathsP.pos" title="scales.utils.collection.path.Position[Item,Section,CC]">pos</a>, <a href="#scales.utils.collection.path;Paths.comparePathsP.pos" title="scales.utils.collection.path.Position[Item,Section,CC]">pos</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a href="#scales.utils.collection.path;Paths.comparePathsP.pos1" title="(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Position[Item,Section,CC])" class="delimiter">(</a><a href="#scales.utils.collection.path;Paths.comparePathsP.x$4" title="scales.utils.collection.path.Position[Item,Section,CC]" id="scales.utils.collection.path;Paths.comparePathsP.pos1">pos1</a>, <a href="#scales.utils.collection.path;Paths.comparePathsP.x$4" title="scales.utils.collection.path.Position[Item,Section,CC]" id="scales.utils.collection.path;Paths.comparePathsP.pos2">pos2</a><span class="delimiter">)</span> = <span title="(_1: scales.utils.collection.path.Position[Item,Section,CC], _2: scales.utils.collection.path.Position[Item,Section,CC])(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Position[Item,Section,CC])" class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.comparePathsP.path1" title="(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])">path1</a>.<span title="=&gt; scales.utils.collection.path.Position[Item,Section,CC]">_1</span>, <a href="#scales.utils.collection.path;Paths.comparePathsP.path2" title="(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])">path2</a>.<span title="=&gt; scales.utils.collection.path.Position[Item,Section,CC]">_1</span><span class="delimiter">)</span>
      <span title="(_1: Int, _2: scales.utils.collection.path.Position[Item,Section,CC], _3: scales.utils.collection.path.Position[Item,Section,CC])(Int, scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Position[Item,Section,CC])" class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.comparePathPositions" title="(path1: scales.utils.collection.path.Position[Item,Section,CC], path2: scales.utils.collection.path.Position[Item,Section,CC])Int">comparePathPositions</a><span class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.comparePathsP.pos1" title="scales.utils.collection.path.Position[Item,Section,CC]">pos1</a>, <a href="#scales.utils.collection.path;Paths.comparePathsP.pos2" title="scales.utils.collection.path.Position[Item,Section,CC]">pos2</a><span class="delimiter">)</span>, <a href="#scales.utils.collection.path;Paths.comparePathsP.pos1" title="scales.utils.collection.path.Position[Item,Section,CC]">pos1</a>, <a href="#scales.utils.collection.path;Paths.comparePathsP.pos2" title="scales.utils.collection.path.Position[Item,Section,CC]">pos2</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]], T](path1: (scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC])), path2: (scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC])))(Int, scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Position[Item,Section,CC])" id="scales.utils.collection.path;Paths.comparePathsT">comparePathsT</a><span class="delimiter">[</span><a title=" &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]]" id="scales.utils.collection.path;Paths.comparePathsT;Item">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection.path;Paths.comparePathsT;Section">Section</a>, <a title="[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="scales.utils.collection.path;Paths.comparePathsT;CC">CC</a><span class="delimiter">[</span><a title="" id="scales.utils.collection.path;Paths.comparePathsT;CC;X">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection.path;Paths.comparePathsT;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC]))" id="scales.utils.collection.path;Paths.comparePathsT.path1">path1</a>: <span title="(scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC]))" class="delimiter">(</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, <span class="delimiter">(</span>T, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a title="(scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC]))" id="scales.utils.collection.path;Paths.comparePathsT.path2">path2</a>: <span title="(scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC]))" class="delimiter">(</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, <span class="delimiter">(</span>T, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>: <span title="(Int, scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Position[Item,Section,CC])" class="delimiter">(</span>Int, Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span title="(Int, scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Position[Item,Section,CC])" class="keyword">if</span> <span class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.comparePathsT.path1" title="(scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC]))">path1</a>.<span title="=&gt; (T, scales.utils.collection.path.Path[Item,Section,CC])">_2</span>.<span title="=&gt; scales.utils.collection.path.Path[Item,Section,CC]">_2</span> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scales.utils.collection.path;Paths.comparePathsT.path2" title="(scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC]))">path2</a>.<span title="=&gt; (T, scales.utils.collection.path.Path[Item,Section,CC])">_2</span>.<span title="=&gt; scales.utils.collection.path.Path[Item,Section,CC]">_2</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="scales.utils.collection.path.Position[Item,Section,CC]" id="scales.utils.collection.path;Paths.comparePathsT.pos">pos</a> = <a href="#scales.utils.collection.path;Paths.comparePathsT.path1" title="(scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC]))">path1</a>.<span title="=&gt; scales.utils.collection.path.Position[Item,Section,CC]">_1</span>
      <span title="(_1: Int, _2: scales.utils.collection.path.Position[Item,Section,CC], _3: scales.utils.collection.path.Position[Item,Section,CC])(Int, scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Position[Item,Section,CC])" class="delimiter">(</span><span title="Int(0)" class="int">0</span>, <a href="#scales.utils.collection.path;Paths.comparePathsT.pos" title="scales.utils.collection.path.Position[Item,Section,CC]">pos</a>, <a href="#scales.utils.collection.path;Paths.comparePathsT.pos" title="scales.utils.collection.path.Position[Item,Section,CC]">pos</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a href="#scales.utils.collection.path;Paths.comparePathsT.pos1" title="(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Position[Item,Section,CC])" class="delimiter">(</a><a href="#scales.utils.collection.path;Paths.comparePathsT.x$5" title="scales.utils.collection.path.Position[Item,Section,CC]" id="scales.utils.collection.path;Paths.comparePathsT.pos1">pos1</a>, <a href="#scales.utils.collection.path;Paths.comparePathsT.x$5" title="scales.utils.collection.path.Position[Item,Section,CC]" id="scales.utils.collection.path;Paths.comparePathsT.pos2">pos2</a><span class="delimiter">)</span> = <span title="(_1: scales.utils.collection.path.Position[Item,Section,CC], _2: scales.utils.collection.path.Position[Item,Section,CC])(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Position[Item,Section,CC])" class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.comparePathsT.path1" title="(scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC]))">path1</a>.<span title="=&gt; scales.utils.collection.path.Position[Item,Section,CC]">_1</span>, <a href="#scales.utils.collection.path;Paths.comparePathsT.path2" title="(scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC]))">path2</a>.<span title="=&gt; scales.utils.collection.path.Position[Item,Section,CC]">_1</span><span class="delimiter">)</span>
      <span title="(_1: Int, _2: scales.utils.collection.path.Position[Item,Section,CC], _3: scales.utils.collection.path.Position[Item,Section,CC])(Int, scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Position[Item,Section,CC])" class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.comparePathPositions" title="(path1: scales.utils.collection.path.Position[Item,Section,CC], path2: scales.utils.collection.path.Position[Item,Section,CC])Int">comparePathPositions</a><span class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.comparePathsT.pos1" title="scales.utils.collection.path.Position[Item,Section,CC]">pos1</a>, <a href="#scales.utils.collection.path;Paths.comparePathsT.pos2" title="scales.utils.collection.path.Position[Item,Section,CC]">pos2</a><span class="delimiter">)</span>, <a href="#scales.utils.collection.path;Paths.comparePathsT.pos1" title="scales.utils.collection.path.Position[Item,Section,CC]">pos1</a>, <a href="#scales.utils.collection.path;Paths.comparePathsT.pos2" title="scales.utils.collection.path.Position[Item,Section,CC]">pos2</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>


  <span class="keyword">import</span> scalaz.Equal
  <span class="keyword">import</span> scalaz.<span title="scalaz.Scalaz.type">Scalaz</span>.equal

  <span class="comment">/**
   * Provides an instance of the Equal type class for positional Equality
   */</span> 
  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]]=&gt; scalaz.Equal[scales.utils.collection.path.Path[Item,Section,CC]]" id="scales.utils.collection.path;Paths.toPositionalEqual">toPositionalEqual</a><span class="delimiter">[</span><a title=" &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]]" id="scales.utils.collection.path;Paths.toPositionalEqual;Item">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection.path;Paths.toPositionalEqual;Section">Section</a>, <a title="[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="scales.utils.collection.path;Paths.toPositionalEqual;CC">CC</a><span class="delimiter">[</span><a title="" id="scales.utils.collection.path;Paths.toPositionalEqual;CC;X">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> : <span title="scalaz.Equal[scales.utils.collection.path.Path[Item,Section,CC]]">Equal</span><span class="delimiter">[</span>Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span> =
    <span title="(f: (scales.utils.collection.path.Path[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC]) =&gt; Boolean)scalaz.Equal[scales.utils.collection.path.Path[Item,Section,CC]]">equal</span> <span class="delimiter">{</span>
      <a href="#scales.utils.collection.path;Paths.comparePathsDirect" title="(path1: scales.utils.collection.path.Path[Item,Section,CC], path2: scales.utils.collection.path.Path[Item,Section,CC])Boolean">comparePathsDirect</a><span class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.toPositionalEqual.$anonfun.x$6" title="scales.utils.collection.path.Path[Item,Section,CC]">_</a>,<a href="#scales.utils.collection.path;Paths.toPositionalEqual.$anonfun.x$7" title="scales.utils.collection.path.Path[Item,Section,CC]">_</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](tree: scales.utils.collection.Tree[Item,Section,CC])(implicit cbf: scales.utils.TreeCBF[Item,Section,CC])scales.utils.collection.path.Path[Item,Section,CC]" id="scales.utils.collection.path;Paths.top">top</a><span class="delimiter">[</span><a title=" &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]]" id="scales.utils.collection.path;Paths.top;Item">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection.path;Paths.top;Section">Section</a>, <a title="[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="scales.utils.collection.path;Paths.top;CC">CC</a><span class="delimiter">[</span><a title="" id="scales.utils.collection.path;Paths.top;CC;X">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="scales.utils.collection.Tree[Item,Section,CC]" id="scales.utils.collection.path;Paths.top.tree">tree</a>: <a href="../Trees.scala.html#scales.utils.collection;Tree" title="scales.utils.collection.Tree[Item,Section,CC]">Tree</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>
    <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scales.utils.TreeCBF[Item,Section,CC]" id="scales.utils.collection.path;Paths.top.cbf">cbf</a> : <span title="scales.utils.TreeCBF[Item,Section,CC]">TreeCBF</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> : <a href="Paths.scala.html#scales.utils.collection.path;Path" title="scales.utils.collection.path.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> =
    <a href="Paths.scala.html#scales.utils.collection.path;Path" title="(top: scales.utils.EitherLike[scales.utils.collection.path.Top[Item,Section,CC],scales.utils.collection.path.Path[Item,Section,CC]], node: scales.utils.collection.path.Node[Item,Section,CC])(implicit cbf: scala.collection.generic.CanBuildFrom[CC[_],scales.utils.ItemOrTree[Item,Section,CC],CC[scales.utils.ItemOrTree[Item,Section,CC]]])scales.utils.collection.path.Path[Item,Section,CC]">Path</a><a href="#scales.utils.collection.path;Paths.top.cbf" title="scales.utils.TreeCBF[Item,Section,CC]" class="delimiter">(</a><a href="Paths.scala.html#scales.utils.collection.path;Top" title="()scales.utils.collection.path.Top[Item,Section,CC]">Top</a><span class="delimiter">(</span><span class="delimiter">)</span>, <a href="Paths.scala.html#scales.utils.collection.path;Node" title="(index: Int, focus: scales.utils.ItemOrTree[Item,Section,CC])scales.utils.collection.path.Node[Item,Section,CC]">Node</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span>, <a href="#scales.utils.collection.path;Paths.top.tree" title="scales.utils.collection.Tree[Item,Section,CC]">tree</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * positions with tuples (T, Path)
   */</span> 
  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]], T](paths: Iterable[(T, scales.utils.collection.path.Path[Item,Section,CC])])Iterable[(scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC]))]" id="scales.utils.collection.path;Paths.positionsT">positionsT</a><span class="delimiter">[</span><a title=" &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]]" id="scales.utils.collection.path;Paths.positionsT;Item">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection.path;Paths.positionsT;Section">Section</a>, <a title="[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="scales.utils.collection.path;Paths.positionsT;CC">CC</a><span class="delimiter">[</span><a title="" id="scales.utils.collection.path;Paths.positionsT;CC;X">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection.path;Paths.positionsT;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Iterable[(T, scales.utils.collection.path.Path[Item,Section,CC])]" id="scales.utils.collection.path;Paths.positionsT.paths">paths</a>: <span title="Iterable[(T, scales.utils.collection.path.Path[Item,Section,CC])]">Iterable</span><span class="delimiter">[</span><span class="delimiter">(</span>T, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Iterable[(scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC]))]">Iterable</span><span class="delimiter">[</span><span class="delimiter">(</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, <span class="delimiter">(</span>T,Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">]</span> =
    <a href="#scales.utils.collection.path;Paths.positionsT.paths" title="Iterable[(T, scales.utils.collection.path.Path[Item,Section,CC])]">paths</a>.<span title="(f: ((T, scales.utils.collection.path.Path[Item,Section,CC])) =&gt; (scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC])))(implicit bf: scala.collection.generic.CanBuildFrom[Iterable[(T, scales.utils.collection.path.Path[Item,Section,CC])],(scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC])),Iterable[(scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC]))]])Iterable[(scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC]))]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Iterable.Coll,(scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC])),Iterable[(scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC]))]]" class="delimiter">(</span><a title="(T, scales.utils.collection.path.Path[Item,Section,CC])" id="scales.utils.collection.path;Paths.positionsT.$anonfun.x">x</a> =&gt; <span title="(_1: scales.utils.collection.path.Position[Item,Section,CC], _2: (T, scales.utils.collection.path.Path[Item,Section,CC]))(scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC]))" class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.positionsT.$anonfun.x" title="(T, scales.utils.collection.path.Path[Item,Section,CC])">x</a>.<span title="=&gt; scales.utils.collection.path.Path[Item,Section,CC]">_2</span>.<a href="Paths.scala.html#scales.utils.collection.path;Path.position" title="()scales.utils.collection.path.Position[Item,Section,CC]">position</a>, <a href="#scales.utils.collection.path;Paths.positionsT.$anonfun.x" title="(T, scales.utils.collection.path.Path[Item,Section,CC])">x</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Obtain the positions for the paths
   */</span> 
  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](paths: Iterable[scales.utils.collection.path.Path[Item,Section,CC]])Iterable[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])]" id="scales.utils.collection.path;Paths.positions">positions</a><span class="delimiter">[</span><a title=" &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]]" id="scales.utils.collection.path;Paths.positions;Item">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection.path;Paths.positions;Section">Section</a>, <a title="[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="scales.utils.collection.path;Paths.positions;CC">CC</a><span class="delimiter">[</span><a title="" id="scales.utils.collection.path;Paths.positions;CC;X">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="Iterable[scales.utils.collection.path.Path[Item,Section,CC]]" id="scales.utils.collection.path;Paths.positions.paths">paths</a>: <span title="Iterable[scales.utils.collection.path.Path[Item,Section,CC]]">Iterable</span><span class="delimiter">[</span>Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Iterable[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])]">Iterable</span><span class="delimiter">[</span><span class="delimiter">(</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span> =
    <a href="#scales.utils.collection.path;Paths.positions.paths" title="Iterable[scales.utils.collection.path.Path[Item,Section,CC]]">paths</a>.<span title="(f: scales.utils.collection.path.Path[Item,Section,CC] =&gt; (scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC]))(implicit bf: scala.collection.generic.CanBuildFrom[Iterable[scales.utils.collection.path.Path[Item,Section,CC]],(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC]),Iterable[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])]])Iterable[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Iterable.Coll,(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC]),Iterable[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])]]" class="delimiter">(</span><a title="scales.utils.collection.path.Path[Item,Section,CC]" id="scales.utils.collection.path;Paths.positions.$anonfun.x">x</a> =&gt; <span title="(_1: scales.utils.collection.path.Position[Item,Section,CC], _2: scales.utils.collection.path.Path[Item,Section,CC])(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])" class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.positions.$anonfun.x" title="scales.utils.collection.path.Path[Item,Section,CC]">x</a>.<a href="Paths.scala.html#scales.utils.collection.path;Path.position" title="()scales.utils.collection.path.Position[Item,Section,CC]">position</a>, <a href="#scales.utils.collection.path;Paths.positions.$anonfun.x" title="scales.utils.collection.path.Path[Item,Section,CC]">x</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * sortPositions with a  tuple T, Path
   */</span>
  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]], T](paths: Iterable[(T, scales.utils.collection.path.Path[Item,Section,CC])], isDescending: Boolean)(implicit cm: ClassManifest[(scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC]))])Iterable[(scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC]))]" id="scales.utils.collection.path;Paths.sortPositionsT">sortPositionsT</a><span class="delimiter">[</span><a title=" &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]]" id="scales.utils.collection.path;Paths.sortPositionsT$default$2;Item">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection.path;Paths.sortPositionsT$default$2;Section">Section</a>, <a title="[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="scales.utils.collection.path;Paths.sortPositionsT$default$2;CC">CC</a><span class="delimiter">[</span><a title="" id="scales.utils.collection.path;Paths.sortPositionsT$default$2;CC;X">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection.path;Paths.sortPositionsT$default$2;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Iterable[(T, scales.utils.collection.path.Path[Item,Section,CC])]" id="scales.utils.collection.path;Paths.sortPositionsT.paths">paths</a>: <span title="Iterable[(T, scales.utils.collection.path.Path[Item,Section,CC])]">Iterable</span><span class="delimiter">[</span><span class="delimiter">(</span>T,Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span>,
    <a title="Boolean" id="scales.utils.collection.path;Paths.sortPositionsT$default$2">isDescending</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="ClassManifest[(scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC]))]" id="scales.utils.collection.path;Paths.sortPositionsT.cm">cm</a> : <span title="ClassManifest[(scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC]))]">ClassManifest</span><span class="delimiter">[</span><span class="delimiter">(</span>Position<span class="delimiter">[</span>Item,Section,CC<span class="delimiter">]</span>, <span class="delimiter">(</span>T, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Iterable[(scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC]))]">Iterable</span><span class="delimiter">[</span><span class="delimiter">(</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, <span class="delimiter">(</span>T, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">]</span> =
    <span class="comment">// Have to force them anyway</span>
    scala.util.<span title="scala.util.Sorting.type">Sorting</span>.<span title="(a: Seq[(scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC]))], f: ((scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC])), (scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC]))) =&gt; Boolean)(implicit evidence$5: scala.reflect.ClassTag[(scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC]))])Array[(scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC]))]">stableSort</span><span class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.positionsT" title="(paths: Iterable[(T, scales.utils.collection.path.Path[Item,Section,CC])])Iterable[(scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC]))]">positionsT</a><span class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.sortPositionsT.paths" title="Iterable[(T, scales.utils.collection.path.Path[Item,Section,CC])]">paths</a><span class="delimiter">)</span>.<span title="=&gt; Seq[(scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC]))]">toSeq</span>, <span class="delimiter">(</span>p1: <span title="(scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC]))" class="delimiter">(</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, <span class="delimiter">(</span>T,Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span>, p2: <span title="(scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC]))" class="delimiter">(</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, <span class="delimiter">(</span>T,Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span>
      <span class="keyword">val</span> <a href="#scales.utils.collection.path;Paths.sortPositionsT.$anonfun.res" title="(Int, scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Position[Item,Section,CC])" class="delimiter">(</a><a href="#scales.utils.collection.path;Paths.sortPositionsT.$anonfun.x$8" title="Int" id="scales.utils.collection.path;Paths.sortPositionsT.$anonfun.res">res</a>, <a href="#scales.utils.collection.path;Paths.sortPositionsT.$anonfun.x$8" title="scales.utils.collection.path.Position[Item,Section,CC]" id="scales.utils.collection.path;Paths.sortPositionsT.$anonfun.pos1">pos1</a>, <a href="#scales.utils.collection.path;Paths.sortPositionsT.$anonfun.x$8" title="scales.utils.collection.path.Position[Item,Section,CC]" id="scales.utils.collection.path;Paths.sortPositionsT.$anonfun.pos2">pos2</a><span class="delimiter">)</span> = <a href="#scales.utils.collection.path;Paths.comparePathsT" title="(path1: (scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC])), path2: (scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC])))(Int, scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Position[Item,Section,CC])">comparePathsT</a><span title="(Int, scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Position[Item,Section,CC]) @unchecked" class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.sortPositionsT.$anonfun.p1" title="(scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC]))">p1</a>, <a href="#scales.utils.collection.path;Paths.sortPositionsT.$anonfun.p2" title="(scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC]))">p2</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Boolean" id="scales.utils.collection.path;Paths.sortPositionsT.$anonfun.order">order</a> = <span class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.sortPositionsT.$anonfun.res" title="Int">res</a> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span> <span title="(x: Boolean)Boolean">||</span> <a href="#scales.utils.collection.path;Paths.sortPositionsT.$anonfun.res" title="Int">res</a> <span title="(x: Int)Boolean">==</span> <span class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.NotSameRoot" title="=&gt; Int">NotSameRoot</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.sortPositionsT$default$2" title="Boolean">isDescending</a><span class="delimiter">)</span> <a href="#scales.utils.collection.path;Paths.sortPositionsT.$anonfun.order" title="Boolean">order</a> <span class="keyword">else</span> <span title="=&gt; Boolean">!</span><a href="#scales.utils.collection.path;Paths.sortPositionsT.$anonfun.order" title="Boolean">order</a>
    <span class="delimiter">}</span><span class="delimiter">)</span><span title="(xs: Array[(scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC]))])scala.collection.mutable.WrappedArray[(scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC]))]" class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.sortPositionsT.cm" title="ClassManifest[(scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC]))]">cm</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Sorts according to position of each path item, descending or descending based on a depth first then rightwise order.
   */</span>
  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](paths: Iterable[scales.utils.collection.path.Path[Item,Section,CC]], isDescending: Boolean)(implicit cm: ClassManifest[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])])Iterable[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])]" id="scales.utils.collection.path;Paths.sortPositions">sortPositions</a><span class="delimiter">[</span><a title=" &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]]" id="scales.utils.collection.path;Paths.sortPositions$default$2;Item">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection.path;Paths.sortPositions$default$2;Section">Section</a>, <a title="[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="scales.utils.collection.path;Paths.sortPositions$default$2;CC">CC</a><span class="delimiter">[</span><a title="" id="scales.utils.collection.path;Paths.sortPositions$default$2;CC;X">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="Iterable[scales.utils.collection.path.Path[Item,Section,CC]]" id="scales.utils.collection.path;Paths.sortPositions.paths">paths</a>: <span title="Iterable[scales.utils.collection.path.Path[Item,Section,CC]]">Iterable</span><span class="delimiter">[</span>Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>,

    <a title="Boolean" id="scales.utils.collection.path;Paths.sortPositions$default$2">isDescending</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="ClassManifest[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])]" id="scales.utils.collection.path;Paths.sortPositions.cm">cm</a> : <span title="ClassManifest[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])]">ClassManifest</span><span class="delimiter">[</span><span class="delimiter">(</span>Position<span class="delimiter">[</span>Item,Section,CC<span class="delimiter">]</span>, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Iterable[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])]">Iterable</span><span class="delimiter">[</span><span class="delimiter">(</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span> =

    <span class="comment">// Have to force them anyway</span>
    scala.util.<span title="scala.util.Sorting.type">Sorting</span>.<span title="(a: Seq[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])], f: ((scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC]), (scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])) =&gt; Boolean)(implicit evidence$5: scala.reflect.ClassTag[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])])Array[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])]">stableSort</span><span class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.positions" title="(paths: Iterable[scales.utils.collection.path.Path[Item,Section,CC]])Iterable[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])]">positions</a><span class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.sortPositions.paths" title="Iterable[scales.utils.collection.path.Path[Item,Section,CC]]">paths</a><span class="delimiter">)</span>.<span title="=&gt; Seq[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])]">toSeq</span>, <span class="delimiter">(</span>p1: <span title="(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])" class="delimiter">(</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>, p2: <span title="(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])" class="delimiter">(</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span>
      <span class="keyword">val</span> <a href="#scales.utils.collection.path;Paths.sortPositions.$anonfun.res" title="(Int, scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Position[Item,Section,CC])" class="delimiter">(</a><a href="#scales.utils.collection.path;Paths.sortPositions.$anonfun.x$9" title="Int" id="scales.utils.collection.path;Paths.sortPositions.$anonfun.res">res</a>, <a href="#scales.utils.collection.path;Paths.sortPositions.$anonfun.x$9" title="scales.utils.collection.path.Position[Item,Section,CC]" id="scales.utils.collection.path;Paths.sortPositions.$anonfun.pos1">pos1</a>, <a href="#scales.utils.collection.path;Paths.sortPositions.$anonfun.x$9" title="scales.utils.collection.path.Position[Item,Section,CC]" id="scales.utils.collection.path;Paths.sortPositions.$anonfun.pos2">pos2</a><span class="delimiter">)</span> = <a href="#scales.utils.collection.path;Paths.comparePathsP" title="(path1: (scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC]), path2: (scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC]))(Int, scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Position[Item,Section,CC])">comparePathsP</a><span title="(Int, scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Position[Item,Section,CC]) @unchecked" class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.sortPositions.$anonfun.p1" title="(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])">p1</a>, <a href="#scales.utils.collection.path;Paths.sortPositions.$anonfun.p2" title="(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])">p2</a><span class="delimiter">)</span> 
      <span class="keyword">val</span> <a title="Boolean" id="scales.utils.collection.path;Paths.sortPositions.$anonfun.order">order</a> = <span class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.sortPositions.$anonfun.res" title="Int">res</a> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span> <span title="(x: Boolean)Boolean">||</span> <a href="#scales.utils.collection.path;Paths.sortPositions.$anonfun.res" title="Int">res</a> <span title="(x: Int)Boolean">==</span> <span class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.NotSameRoot" title="=&gt; Int">NotSameRoot</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.sortPositions$default$2" title="Boolean">isDescending</a><span class="delimiter">)</span> <a href="#scales.utils.collection.path;Paths.sortPositions.$anonfun.order" title="Boolean">order</a> <span class="keyword">else</span> <span title="=&gt; Boolean">!</span><a href="#scales.utils.collection.path;Paths.sortPositions.$anonfun.order" title="Boolean">order</a>
    <span class="delimiter">}</span><span class="delimiter">)</span><span title="(xs: Array[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])])scala.collection.mutable.WrappedArray[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])]" class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.sortPositions.cm" title="ClassManifest[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])]">cm</a><span class="delimiter">)</span>
   

  <span class="comment">/**
   * Sorts according to position of each path item, descending or descending based on a depth first then rightwise order.
   */</span>
  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](paths: Iterable[scales.utils.collection.path.Path[Item,Section,CC]], isDescending: Boolean)(implicit cm: ClassManifest[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])])Iterable[scales.utils.collection.path.Path[Item,Section,CC]]" id="scales.utils.collection.path;Paths.sort">sort</a><span class="delimiter">[</span><a title=" &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]]" id="scales.utils.collection.path;Paths.sort$default$2;Item">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection.path;Paths.sort$default$2;Section">Section</a>, <a title="[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="scales.utils.collection.path;Paths.sort$default$2;CC">CC</a><span class="delimiter">[</span><a title="" id="scales.utils.collection.path;Paths.sort$default$2;CC;X">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="Iterable[scales.utils.collection.path.Path[Item,Section,CC]]" id="scales.utils.collection.path;Paths.sort.paths">paths</a>: <span title="Iterable[scales.utils.collection.path.Path[Item,Section,CC]]">Iterable</span><span class="delimiter">[</span>Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>,
    <a title="Boolean" id="scales.utils.collection.path;Paths.sort$default$2">isDescending</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="ClassManifest[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])]" id="scales.utils.collection.path;Paths.sort.cm">cm</a> : <span title="ClassManifest[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])]">ClassManifest</span><span class="delimiter">[</span><span class="delimiter">(</span>Position<span class="delimiter">[</span>Item,Section,CC<span class="delimiter">]</span>, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Iterable[scales.utils.collection.path.Path[Item,Section,CC]]">Iterable</span><span class="delimiter">[</span>Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#scales.utils.collection.path;Paths.sortPositions" title="(paths: Iterable[scales.utils.collection.path.Path[Item,Section,CC]], isDescending: Boolean)(implicit cm: ClassManifest[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])])Iterable[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])]">sortPositions</a><a href="#scales.utils.collection.path;Paths.sort.cm" title="ClassManifest[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])]" class="delimiter">(</a><a href="#scales.utils.collection.path;Paths.sort.paths" title="Iterable[scales.utils.collection.path.Path[Item,Section,CC]]">paths</a>, <a href="#scales.utils.collection.path;Paths.sort$default$2" title="Boolean">isDescending</a><span class="delimiter">)</span>.<span title="(f: ((scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])) =&gt; scales.utils.collection.path.Path[Item,Section,CC])(implicit bf: scala.collection.generic.CanBuildFrom[Iterable[(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])],scales.utils.collection.path.Path[Item,Section,CC],Iterable[scales.utils.collection.path.Path[Item,Section,CC]]])Iterable[scales.utils.collection.path.Path[Item,Section,CC]]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Iterable.Coll,scales.utils.collection.path.Path[Item,Section,CC],Iterable[scales.utils.collection.path.Path[Item,Section,CC]]]" class="delimiter">(</span><a title="(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])" id="scales.utils.collection.path;Paths.sort.$anonfun.x">x</a> =&gt; <a href="#scales.utils.collection.path;Paths.sort.$anonfun.x" title="(scales.utils.collection.path.Position[Item,Section,CC], scales.utils.collection.path.Path[Item,Section,CC])">x</a>.<span title="=&gt; scales.utils.collection.path.Path[Item,Section,CC]">_2</span><span class="delimiter">)</span>

  <span class="comment">/**
   * sort with a tuple T, Path
   */</span> 
  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]], T](paths: Iterable[(T, scales.utils.collection.path.Path[Item,Section,CC])], isDescending: Boolean)(implicit cm: ClassManifest[(scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC]))])Iterable[(T, scales.utils.collection.path.Path[Item,Section,CC])]" id="scales.utils.collection.path;Paths.sortT">sortT</a><span class="delimiter">[</span><a title=" &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]]" id="scales.utils.collection.path;Paths.sortT$default$2;Item">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection.path;Paths.sortT$default$2;Section">Section</a>, <a title="[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="scales.utils.collection.path;Paths.sortT$default$2;CC">CC</a><span class="delimiter">[</span><a title="" id="scales.utils.collection.path;Paths.sortT$default$2;CC;X">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection.path;Paths.sortT$default$2;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Iterable[(T, scales.utils.collection.path.Path[Item,Section,CC])]" id="scales.utils.collection.path;Paths.sortT.paths">paths</a>: <span title="Iterable[(T, scales.utils.collection.path.Path[Item,Section,CC])]">Iterable</span><span class="delimiter">[</span><span class="delimiter">(</span>T,Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span>,
    <a title="Boolean" id="scales.utils.collection.path;Paths.sortT$default$2">isDescending</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="ClassManifest[(scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC]))]" id="scales.utils.collection.path;Paths.sortT.cm">cm</a> : <span title="ClassManifest[(scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC]))]">ClassManifest</span><span class="delimiter">[</span><span class="delimiter">(</span>Position<span class="delimiter">[</span>Item,Section,CC<span class="delimiter">]</span>, <span class="delimiter">(</span>T, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Iterable[(T, scales.utils.collection.path.Path[Item,Section,CC])]">Iterable</span><span class="delimiter">[</span><span class="delimiter">(</span>T,Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span> = <a href="#scales.utils.collection.path;Paths.sortPositionsT" title="(paths: Iterable[(T, scales.utils.collection.path.Path[Item,Section,CC])], isDescending: Boolean)(implicit cm: ClassManifest[(scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC]))])Iterable[(scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC]))]">sortPositionsT</a><a href="#scales.utils.collection.path;Paths.sortT.cm" title="ClassManifest[(scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC]))]" class="delimiter">(</a><a href="#scales.utils.collection.path;Paths.sortT.paths" title="Iterable[(T, scales.utils.collection.path.Path[Item,Section,CC])]">paths</a>, <a href="#scales.utils.collection.path;Paths.sortT$default$2" title="Boolean">isDescending</a><span class="delimiter">)</span>.<span title="(f: ((scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC]))) =&gt; (T, scales.utils.collection.path.Path[Item,Section,CC]))(implicit bf: scala.collection.generic.CanBuildFrom[Iterable[(scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC]))],(T, scales.utils.collection.path.Path[Item,Section,CC]),Iterable[(T, scales.utils.collection.path.Path[Item,Section,CC])]])Iterable[(T, scales.utils.collection.path.Path[Item,Section,CC])]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Iterable.Coll,(T, scales.utils.collection.path.Path[Item,Section,CC]),Iterable[(T, scales.utils.collection.path.Path[Item,Section,CC])]]" class="delimiter">(</span><a title="(scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC]))" id="scales.utils.collection.path;Paths.sortT.$anonfun.x">x</a> =&gt; <a href="#scales.utils.collection.path;Paths.sortT.$anonfun.x" title="(scales.utils.collection.path.Position[Item,Section,CC], (T, scales.utils.collection.path.Path[Item,Section,CC]))">x</a>.<span title="=&gt; (T, scales.utils.collection.path.Path[Item,Section,CC])">_2</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Deepest last child
   */</span> 
  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](path: scales.utils.collection.path.Path[Item,Section,CC])scales.utils.collection.path.Path[Item,Section,CC]" id="scales.utils.collection.path;Paths.deepestLast">deepestLast</a><span class="delimiter">[</span><a title=" &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]]" id="scales.utils.collection.path;Paths.deepestLast;Item">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection.path;Paths.deepestLast;Section">Section</a>, <a title="[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="scales.utils.collection.path;Paths.deepestLast;CC">CC</a><span class="delimiter">[</span><a title="" id="scales.utils.collection.path;Paths.deepestLast;CC;X">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="scales.utils.collection.path.Path[Item,Section,CC]" id="scales.utils.collection.path;Paths.deepestLast.path">path</a> : <a href="Paths.scala.html#scales.utils.collection.path;Path" title="scales.utils.collection.path.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> : <a href="Paths.scala.html#scales.utils.collection.path;Path" title="scales.utils.collection.path.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span title="scales.utils.collection.path.Path[Item,Section,CC]" class="keyword">if</span> <span class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.deepestLast.path" title="scales.utils.collection.path.Path[Item,Section,CC]">path</a>.<a href="Paths.scala.html#scales.utils.collection.path;Path.hasChildren" title="=&gt; Boolean">hasChildren</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="scales.utils.collection.path.Path[Item,Section,CC]" id="scales.utils.collection.path;Paths.deepestLast.npath">npath</a> = <a href="#scales.utils.collection.path;Paths.deepestLast.path" title="scales.utils.collection.path.Path[Item,Section,CC]">path</a>.<a href="Paths.scala.html#scales.utils.collection.path;Path.lastChild" title="()Option[scales.utils.collection.path.Path[Item,Section,CC]]">lastChild</a>.<span title="=&gt; scales.utils.collection.path.Path[Item,Section,CC]">get</span>
      <span title="scales.utils.collection.path.Path[Item,Section,CC]" class="keyword">if</span> <span class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.deepestLast.npath" title="scales.utils.collection.path.Path[Item,Section,CC]">npath</a>.<a href="Paths.scala.html#scales.utils.collection.path;Path.isItem" title="=&gt; Boolean">isItem</a><span class="delimiter">)</span>
	<a href="#scales.utils.collection.path;Paths.deepestLast.npath" title="scales.utils.collection.path.Path[Item,Section,CC]">npath</a>
      <span class="keyword">else</span>
	<a href="#scales.utils.collection.path;Paths.deepestLast" title="(path: scales.utils.collection.path.Path[Item,Section,CC])scales.utils.collection.path.Path[Item,Section,CC]">deepestLast</a><span class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.deepestLast.npath" title="scales.utils.collection.path.Path[Item,Section,CC]">npath</a><span class="delimiter">)</span> <span class="comment">// keep going in </span>
    <span class="delimiter">}</span> <span class="keyword">else</span> 
      <a href="#scales.utils.collection.path;Paths.deepestLast.path" title="scales.utils.collection.path.Path[Item,Section,CC]">path</a>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * gets the next preceding:: sibling equivalent in document order, unlike XPath preceding:: it does not exclude parents 
   */</span>
  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](path: scales.utils.collection.path.Path[Item,Section,CC])Option[scales.utils.collection.path.Path[Item,Section,CC]]" id="scales.utils.collection.path;Paths.preceding">preceding</a><span class="delimiter">[</span><a title=" &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]]" id="scales.utils.collection.path;Paths.preceding;Item">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection.path;Paths.preceding;Section">Section</a>, <a title="[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="scales.utils.collection.path;Paths.preceding;CC">CC</a><span class="delimiter">[</span><a title="" id="scales.utils.collection.path;Paths.preceding;CC;X">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span> <a title="scales.utils.collection.path.Path[Item,Section,CC]" id="scales.utils.collection.path;Paths.preceding.path">path</a> : <a href="Paths.scala.html#scales.utils.collection.path;Path" title="scales.utils.collection.path.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> <span class="delimiter">)</span> : <span title="Option[scales.utils.collection.path.Path[Item,Section,CC]]">Option</span><span class="delimiter">[</span>Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span> =
    <span title="Option[scales.utils.collection.path.Path[Item,Section,CC]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.preceding.path" title="scales.utils.collection.path.Path[Item,Section,CC]">path</a>.<a href="Paths.scala.html#scales.utils.collection.path;Path.hasPreviousSibling" title="=&gt; Boolean">hasPreviousSibling</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="scales.utils.collection.path.Path[Item,Section,CC]" id="scales.utils.collection.path;Paths.preceding.t">t</a> = <a href="#scales.utils.collection.path;Paths.preceding.path" title="scales.utils.collection.path.Path[Item,Section,CC]">path</a>.<a href="Paths.scala.html#scales.utils.collection.path;Path.previousSibling" title="=&gt; scales.utils.collection.path.Path[Item,Section,CC]">previousSibling</a>
      <span title="(x: scales.utils.collection.path.Path[Item,Section,CC])Some[scales.utils.collection.path.Path[Item,Section,CC]]">Some</span><span class="delimiter">(</span>
	<span title="scales.utils.collection.path.Path[Item,Section,CC]" class="keyword">if</span> <span class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.preceding.t" title="scales.utils.collection.path.Path[Item,Section,CC]">t</a>.<a href="Paths.scala.html#scales.utils.collection.path;Path.isItem" title="=&gt; Boolean">isItem</a><span class="delimiter">)</span>
          <a href="#scales.utils.collection.path;Paths.preceding.t" title="scales.utils.collection.path.Path[Item,Section,CC]">t</a>
	<span class="keyword">else</span>
	  <a href="#scales.utils.collection.path;Paths.deepestLast" title="(path: scales.utils.collection.path.Path[Item,Section,CC])scales.utils.collection.path.Path[Item,Section,CC]">deepestLast</a><span class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.preceding.t" title="scales.utils.collection.path.Path[Item,Section,CC]">t</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> <span class="keyword">else</span>
      <span title="Option[scales.utils.collection.path.Path[Item,Section,CC]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.preceding.path" title="scales.utils.collection.path.Path[Item,Section,CC]">path</a>.<a href="Paths.scala.html#scales.utils.collection.path;Path.top" title="=&gt; scales.utils.EitherLike[scales.utils.collection.path.Top[Item,Section,CC],scales.utils.collection.path.Path[Item,Section,CC]]">top</a>.<a href="../../EitherLike.scala.html#scales.utils;EitherLike.isLeft" title="=&gt; Boolean">isLeft</a><span class="delimiter">)</span>
	<span title="None.type">None</span>
      <span class="keyword">else</span>
	<a href="#scales.utils.collection.path;Paths.preceding" title="(path: scales.utils.collection.path.Path[Item,Section,CC])Option[scales.utils.collection.path.Path[Item,Section,CC]]">preceding</a><span class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.preceding.path" title="scales.utils.collection.path.Path[Item,Section,CC]">path</a>.<a href="Paths.scala.html#scales.utils.collection.path;Path.top" title="=&gt; scales.utils.EitherLike[scales.utils.collection.path.Top[Item,Section,CC],scales.utils.collection.path.Path[Item,Section,CC]]">top</a>.<a href="../../EitherLike.scala.html#scales.utils;EitherLike.getRight" title="=&gt; scales.utils.collection.path.Path[Item,Section,CC]">getRight</a><span class="delimiter">)</span> <span class="comment">// move up</span>

  <span class="comment">/**
   * gets the next following:: sibling in document order 
   */</span> 
  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](path: scales.utils.collection.path.Path[Item,Section,CC])Option[scales.utils.collection.path.Path[Item,Section,CC]]" id="scales.utils.collection.path;Paths.following">following</a><span class="delimiter">[</span><a title=" &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]]" id="scales.utils.collection.path;Paths.following;Item">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection.path;Paths.following;Section">Section</a>, <a title="[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="scales.utils.collection.path;Paths.following;CC">CC</a><span class="delimiter">[</span><a title="" id="scales.utils.collection.path;Paths.following;CC;X">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span> <a title="scales.utils.collection.path.Path[Item,Section,CC]" id="scales.utils.collection.path;Paths.following.path">path</a> : <a href="Paths.scala.html#scales.utils.collection.path;Path" title="scales.utils.collection.path.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> <span class="delimiter">)</span> : <span title="Option[scales.utils.collection.path.Path[Item,Section,CC]]">Option</span><span class="delimiter">[</span>Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span> =
    <span title="Option[scales.utils.collection.path.Path[Item,Section,CC]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.following.path" title="scales.utils.collection.path.Path[Item,Section,CC]">path</a>.<a href="Paths.scala.html#scales.utils.collection.path;Path.hasNextSibling" title="=&gt; Boolean">hasNextSibling</a><span class="delimiter">)</span>
      <span title="(x: scales.utils.collection.path.Path[Item,Section,CC])Some[scales.utils.collection.path.Path[Item,Section,CC]]">Some</span><span class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.following.path" title="scales.utils.collection.path.Path[Item,Section,CC]">path</a>.<a href="Paths.scala.html#scales.utils.collection.path;Path.nextSibling" title="=&gt; scales.utils.collection.path.Path[Item,Section,CC]">nextSibling</a><span class="delimiter">)</span>
    <span class="keyword">else</span>
      <span title="Option[scales.utils.collection.path.Path[Item,Section,CC]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.following.path" title="scales.utils.collection.path.Path[Item,Section,CC]">path</a>.<a href="Paths.scala.html#scales.utils.collection.path;Path.top" title="=&gt; scales.utils.EitherLike[scales.utils.collection.path.Top[Item,Section,CC],scales.utils.collection.path.Path[Item,Section,CC]]">top</a>.<a href="../../EitherLike.scala.html#scales.utils;EitherLike.isLeft" title="=&gt; Boolean">isLeft</a><span class="delimiter">)</span>
	<span title="None.type">None</span>
      <span class="keyword">else</span>
	<a href="#scales.utils.collection.path;Paths.following" title="(path: scales.utils.collection.path.Path[Item,Section,CC])Option[scales.utils.collection.path.Path[Item,Section,CC]]">following</a><span class="delimiter">(</span><a href="#scales.utils.collection.path;Paths.following.path" title="scales.utils.collection.path.Path[Item,Section,CC]">path</a>.<a href="Paths.scala.html#scales.utils.collection.path;Path.top" title="=&gt; scales.utils.EitherLike[scales.utils.collection.path.Top[Item,Section,CC],scales.utils.collection.path.Path[Item,Section,CC]]">top</a>.<a href="../../EitherLike.scala.html#scales.utils;EitherLike.getRight" title="=&gt; scales.utils.collection.path.Path[Item,Section,CC]">getRight</a><span class="delimiter">)</span> <span class="comment">// move up</span>

<span class="delimiter">}</span>

        </pre>
    </body>
</html>
