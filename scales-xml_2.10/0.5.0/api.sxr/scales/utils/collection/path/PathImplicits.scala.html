<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>scales\utils\collection\path\PathImplicits.scala</title>
        <script type="text/javascript" src="../../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> scales.utils.collection.path

<span class="keyword">import</span> scala.collection.immutable.Stack
<span class="keyword">import</span> scala.collection.IndexedSeqLike
<span class="keyword">import</span> scala.collection.generic.CanBuildFrom

<span class="keyword">import</span> scales.utils.collection.Tree
<span class="keyword">import</span> scales.utils.<span class="delimiter">{</span>PathFoldR, FoldR, LeftLike, deepestLast<span class="delimiter">}</span>

<span class="keyword">import</span> scalaz._
<span class="keyword">import</span> <span title="scalaz.Scalaz.type">Scalaz</span>._

<span class="comment">/**
 * Provide &amp; combinator to pass the result of one fold onto the other,
 * in the case of failure no further joined functions will be called.
 *
 * And provides | which allows NoPaths failures, allowing the use site to decide
 * how to combine
 */</span>
<span class="keyword">class</span> <a title="class PathFoldCombiner[Item &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]] extends AnyRef" id="scales.utils.collection.path;PathFoldCombiner">PathFoldCombiner</a><span class="delimiter">[</span><a title=" &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]]" id="scales.utils.collection.path;PathFoldCombiner;Item">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection.path;PathFoldCombiner;Section">Section</a>, <a title="[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="scales.utils.collection.path;PathFoldCombiner;CC">CC</a><span class="delimiter">[</span><a title="" id="scales.utils.collection.path;PathFoldCombiner;CC;X">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><a href="#scales.utils.collection.path;PathFoldCombiner" title="scales.utils.collection.path.PathFoldCombiner[Item,Section,CC]" class="delimiter">(</a><a title="scales.utils.collection.path.Path[Item,Section,CC] =&gt; scales.utils.FoldR[Item,Section,CC]" id="scales.utils.collection.path;PathFoldCombiner.f">f</a>: <span title="scales.utils.collection.path.Path[Item,Section,CC] =&gt; scales.utils.FoldR[Item,Section,CC]">PathFoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(next: scales.utils.collection.path.Path[Item,Section,CC] =&gt; scales.utils.FoldR[Item,Section,CC], orOnFail: (scales.utils.collection.path.Path[Item,Section,CC], scales.utils.collection.path.FoldError) =&gt; scales.utils.FoldR[Item,Section,CC])scales.utils.collection.path.Path[Item,Section,CC] =&gt; scales.utils.FoldR[Item,Section,CC]" id="scales.utils.collection.path;PathFoldCombiner.onSuccess">onSuccess</a><span class="delimiter">(</span><a title="scales.utils.collection.path.Path[Item,Section,CC] =&gt; scales.utils.FoldR[Item,Section,CC]" id="scales.utils.collection.path;PathFoldCombiner.onSuccess.next">next</a>: <span title="scales.utils.collection.path.Path[Item,Section,CC] =&gt; scales.utils.FoldR[Item,Section,CC]">PathFoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, <a title="(scales.utils.collection.path.Path[Item,Section,CC], scales.utils.collection.path.FoldError) =&gt; scales.utils.FoldR[Item,Section,CC]" id="scales.utils.collection.path;PathFoldCombiner.onSuccess$default$2">orOnFail</a>: <span class="delimiter">(</span>Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, FoldError<span class="delimiter">)</span> =&gt; FoldR<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> = <span class="delimiter">(</span><a title="scales.utils.collection.path.Path[Item,Section,CC]" id="scales.utils.collection.path;PathFoldCombiner.onSuccess$default$2.$anonfun.a">a</a>, <a title="scales.utils.collection.path.FoldError" id="scales.utils.collection.path;PathFoldCombiner.onSuccess$default$2.$anonfun.b">b</a><a href="PathFolds.scala.html#scales.utils.collection.path;FoldError" title="scales.utils.collection.path.FoldError" class="delimiter">)</a> =&gt; <span title="(b: scales.utils.collection.path.FoldError)scala.util.Right[Nothing,scales.utils.collection.path.FoldError]">Right</span><span class="delimiter">(</span><a href="#scales.utils.collection.path;PathFoldCombiner.onSuccess$default$2.$anonfun.b" title="scales.utils.collection.path.FoldError">b</a><span class="delimiter">)</span><span class="delimiter">)</span>: <span title="scales.utils.collection.path.Path[Item,Section,CC] =&gt; scales.utils.FoldR[Item,Section,CC]">PathFoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> =
    <span class="delimiter">(</span>path: <a href="Paths.scala.html#scales.utils.collection.path;Path" title="scales.utils.collection.path.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> =&gt;
      <span class="comment">// modify back in (allows changes), or pass on the error</span>
      <a href="#scales.utils.collection.path;PathFoldCombiner.f" title="(v1: scales.utils.collection.path.Path[Item,Section,CC])scales.utils.FoldR[Item,Section,CC]">f</a><span class="delimiter">(</span><a href="#scales.utils.collection.path;PathFoldCombiner.onSuccess.$anonfun.path" title="scales.utils.collection.path.Path[Item,Section,CC]">path</a><span class="delimiter">)</span>.<span title="(fa: scales.utils.collection.path.Path[Item,Section,CC] =&gt; scales.utils.FoldR[Item,Section,CC], fb: scales.utils.collection.path.FoldError =&gt; scales.utils.FoldR[Item,Section,CC])scales.utils.FoldR[Item,Section,CC]">fold</span><span class="delimiter">(</span><a title="scales.utils.collection.path.Path[Item,Section,CC]" id="scales.utils.collection.path;PathFoldCombiner.onSuccess.$anonfun.$anonfun.fres">fres</a> =&gt;
        <a href="#scales.utils.collection.path;PathFoldCombiner.onSuccess.next" title="(v1: scales.utils.collection.path.Path[Item,Section,CC])scales.utils.FoldR[Item,Section,CC]">next</a><span class="delimiter">(</span><a href="#scales.utils.collection.path;PathFoldCombiner.onSuccess.$anonfun.path" title="scales.utils.collection.path.Path[Item,Section,CC]">path</a>.<a href="Paths.scala.html#scales.utils.collection.path;Path.modify" title="(newFocus: scales.utils.ItemOrTree[Item,Section,CC] =&gt; scales.utils.ItemOrTree[Item,Section,CC])scales.utils.collection.path.Path[Item,Section,CC]">modify</a><span class="delimiter">(</span><a title="scales.utils.ItemOrTree[Item,Section,CC]" id="scales.utils.collection.path;PathFoldCombiner.onSuccess.$anonfun.$anonfun.$anonfun.x$1">_</a> =&gt; <a href="#scales.utils.collection.path;PathFoldCombiner.onSuccess.$anonfun.$anonfun.fres" title="scales.utils.collection.path.Path[Item,Section,CC]">fres</a>.<a href="Paths.scala.html#scales.utils.collection.path;Path.tree" title="()scales.utils.collection.Tree[Item,Section,CC]">tree</a><span class="delimiter">)</span><span class="delimiter">)</span>,
	    <a href="#scales.utils.collection.path;PathFoldCombiner.onSuccess$default$2" title="(v1: scales.utils.collection.path.Path[Item,Section,CC], v2: scales.utils.collection.path.FoldError)scales.utils.FoldR[Item,Section,CC]">orOnFail</a><span class="delimiter">(</span><a href="#scales.utils.collection.path;PathFoldCombiner.onSuccess.$anonfun.path" title="scales.utils.collection.path.Path[Item,Section,CC]">path</a>, <a href="#scales.utils.collection.path;PathFoldCombiner.onSuccess.$anonfun.$anonfun.x$2" title="scales.utils.collection.path.FoldError">_</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Combine with next, but only when this PathFoldR has not failed
   */</span> 
  <span class="keyword">def</span> <a title="(next: scales.utils.collection.path.Path[Item,Section,CC] =&gt; scales.utils.FoldR[Item,Section,CC])scales.utils.collection.path.Path[Item,Section,CC] =&gt; scales.utils.FoldR[Item,Section,CC]" id="scales.utils.collection.path;PathFoldCombiner.&">&amp;</a><span class="delimiter">(</span><a title="scales.utils.collection.path.Path[Item,Section,CC] =&gt; scales.utils.FoldR[Item,Section,CC]" id="scales.utils.collection.path;PathFoldCombiner.&.next">next</a>: <span title="scales.utils.collection.path.Path[Item,Section,CC] =&gt; scales.utils.FoldR[Item,Section,CC]">PathFoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scales.utils.collection.path.Path[Item,Section,CC] =&gt; scales.utils.FoldR[Item,Section,CC]">PathFoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> =
    <a href="#scales.utils.collection.path;PathFoldCombiner.onSuccess" title="(next: scales.utils.collection.path.Path[Item,Section,CC] =&gt; scales.utils.FoldR[Item,Section,CC], orOnFail: (scales.utils.collection.path.Path[Item,Section,CC], scales.utils.collection.path.FoldError) =&gt; scales.utils.FoldR[Item,Section,CC])scales.utils.collection.path.Path[Item,Section,CC] =&gt; scales.utils.FoldR[Item,Section,CC]">onSuccess</a><span class="delimiter">(</span><a href="#scales.utils.collection.path;PathFoldCombiner.&.next" title="scales.utils.collection.path.Path[Item,Section,CC] =&gt; scales.utils.FoldR[Item,Section,CC]">next</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Combine with next, and allow next to be used if this PathFoldR returns NoPaths
   */</span> 
  <span class="keyword">def</span> <a title="(next: scales.utils.collection.path.Path[Item,Section,CC] =&gt; scales.utils.FoldR[Item,Section,CC])scales.utils.collection.path.Path[Item,Section,CC] =&gt; scales.utils.FoldR[Item,Section,CC]" id="scales.utils.collection.path;PathFoldCombiner.|">|</a><span class="delimiter">(</span><a title="scales.utils.collection.path.Path[Item,Section,CC] =&gt; scales.utils.FoldR[Item,Section,CC]" id="scales.utils.collection.path;PathFoldCombiner.|.next">next</a>: <span title="scales.utils.collection.path.Path[Item,Section,CC] =&gt; scales.utils.FoldR[Item,Section,CC]">PathFoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scales.utils.collection.path.Path[Item,Section,CC] =&gt; scales.utils.FoldR[Item,Section,CC]">PathFoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> =
    <a href="#scales.utils.collection.path;PathFoldCombiner.onSuccess" title="(next: scales.utils.collection.path.Path[Item,Section,CC] =&gt; scales.utils.FoldR[Item,Section,CC], orOnFail: (scales.utils.collection.path.Path[Item,Section,CC], scales.utils.collection.path.FoldError) =&gt; scales.utils.FoldR[Item,Section,CC])scales.utils.collection.path.Path[Item,Section,CC] =&gt; scales.utils.FoldR[Item,Section,CC]">onSuccess</a><span class="delimiter">(</span><a href="#scales.utils.collection.path;PathFoldCombiner.|.next" title="scales.utils.collection.path.Path[Item,Section,CC] =&gt; scales.utils.FoldR[Item,Section,CC]">next</a>, orOnFail = <span class="delimiter">(</span><a title="scales.utils.collection.path.Path[Item,Section,CC]" id="scales.utils.collection.path;PathFoldCombiner.|.$anonfun.path">path</a>, <a title="scales.utils.collection.path.FoldError" id="scales.utils.collection.path;PathFoldCombiner.|.$anonfun.res">res</a><a href="PathFolds.scala.html#scales.utils.collection.path;FoldError" title="scales.utils.collection.path.FoldError" class="delimiter">)</a> =&gt;
      <span title="scales.utils.FoldR[Item,Section,CC]" class="keyword">if</span> <span class="delimiter">(</span><a href="#scales.utils.collection.path;PathFoldCombiner.|.$anonfun.res" title="scales.utils.collection.path.FoldError">res</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="PathFolds.scala.html#scales.utils.collection.path.NoPaths" title="scales.utils.collection.path.NoPaths.type">NoPaths</a><span class="delimiter">)</span>
        <a href="#scales.utils.collection.path;PathFoldCombiner.|.next" title="(v1: scales.utils.collection.path.Path[Item,Section,CC])scales.utils.FoldR[Item,Section,CC]">next</a><span class="delimiter">(</span><a href="#scales.utils.collection.path;PathFoldCombiner.|.$anonfun.path" title="scales.utils.collection.path.Path[Item,Section,CC]">path</a><span class="delimiter">)</span>
      <span class="keyword">else</span>
        <span title="(b: scales.utils.collection.path.FoldError)scala.util.Right[Nothing,scales.utils.collection.path.FoldError]">Right</span><span class="delimiter">(</span><a href="#scales.utils.collection.path;PathFoldCombiner.|.$anonfun.res" title="scales.utils.collection.path.FoldError">res</a><span class="delimiter">)</span><span class="delimiter">)</span>
<span class="delimiter">}</span>


<span title="AnyRef" class="keyword">trait</span> <a title="trait PathImplicits extends AnyRef" id="scales.utils.collection.path;PathImplicits">PathImplicits</a> <span title="Unit" class="delimiter">{</span>
  <span class="comment">/**
   * Provide &amp; combinator to pass the result of one fold onto the other,
   * in the case of failure no further joined functions will be called.
   *
   * And provides | which allows NoPaths failures, allowing the use site to decide
   * how to combine
   */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](f: scales.utils.collection.path.Path[Item,Section,CC] =&gt; scales.utils.FoldR[Item,Section,CC])scales.utils.collection.path.PathFoldCombiner[Item,Section,CC]" id="scales.utils.collection.path;PathImplicits.fToFoldRToCombine">fToFoldRToCombine</a><span class="delimiter">[</span><a title=" &lt;: scales.utils.LeftLike[Item,scales.utils.collection.Tree[Item,Section,CC]]" id="scales.utils.collection.path;PathImplicits.fToFoldRToCombine;Item">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="scales.utils.collection.path;PathImplicits.fToFoldRToCombine;Section">Section</a>, <a title="[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="scales.utils.collection.path;PathImplicits.fToFoldRToCombine;CC">CC</a><span class="delimiter">[</span><a title="" id="scales.utils.collection.path;PathImplicits.fToFoldRToCombine;CC;X">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="scales.utils.collection.path.Path[Item,Section,CC] =&gt; scales.utils.FoldR[Item,Section,CC]" id="scales.utils.collection.path;PathImplicits.fToFoldRToCombine.f">f</a>: <span title="scales.utils.collection.path.Path[Item,Section,CC] =&gt; scales.utils.FoldR[Item,Section,CC]">PathFoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> = <span title="scales.utils.collection.path.PathFoldCombiner[Item,Section,CC]" class="keyword">new</span> <a href="#scales.utils.collection.path;PathFoldCombiner" title="scales.utils.collection.path.PathFoldCombiner[Item,Section,CC]">PathFoldCombiner</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">(</span><a href="#scales.utils.collection.path;PathImplicits.fToFoldRToCombine.f" title="scales.utils.collection.path.Path[Item,Section,CC] =&gt; scales.utils.FoldR[Item,Section,CC]">f</a><span class="delimiter">)</span>

<span class="delimiter">}</span>

        </pre>
    </body>
</html>
