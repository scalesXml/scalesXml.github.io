<?xml version="1.0" encoding="utf-8"?>
			<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>scales\utils\Paths.scala</title>
        <script type="text/javascript" src="../../jquery-all.js"></script>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style"></link>
    
<style id="linesStyle">
.lineHighlight {
  background-color: #a5a5a5;
}
</style>
<script type="text/javascript">
function selectedLine() {
    var loca = /^.*#l(.*)/.exec(location.href);
    return loca ? loca[1] : '0';
}

function highlightLine(ln){
  $('#l'+ln).toggleClass('lineHighlight');
}

function gotoLine(ln){
  $('#l'+ln).focus();
}

$(function(){
  var line = selectedLine();
  if (line != '0') highlightLine(line)
});
</script></head>
    <body>
        <pre>
<!-- SXR_LINES --><a href="l1"></a><span id="l1"><span class="keyword">package</span> scales.utils</span>
<a href="l2"></a><span id="l2"></span>
<a href="l3"></a><span id="l3"><span class="keyword">import</span> scales.utils._</span>
<a href="l4"></a><span id="l4"></span>
<a href="l5"></a><span id="l5"><span class="keyword">import</span> scala.collection.immutable.Stack</span>
<a href="l6"></a><span id="l6"><span class="keyword">import</span> scala.collection.IndexedSeqLike</span>
<a href="l7"></a><span id="l7"><span class="keyword">import</span> scala.collection.generic.CanBuildFrom</span>
<a href="l8"></a><span id="l8"></span>
<a href="l9"></a><span id="l9"><span class="keyword">trait</span> <a title="trait Paths extends java.lang.Object with ScalaObject" id="9069">Paths</a> <span title="ScalaObject" class="delimiter">{</span></span>
<a href="l10"></a><span id="l10">  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](implicit cbf: scales.utils.package.TreeCBF[Item,Section,CC])scales.utils.Path[Item,Section,CC]" id="10765">noPath</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="10769">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="10770">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="10771">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="78860">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span></span>
<a href="l11"></a><span id="l11">    <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scales.utils.package.TreeCBF[Item,Section,CC]" id="78856">cbf</a> : <span title="scales.utils.package.TreeCBF[Item,Section,CC]">TreeCBF</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>  = <a href="#78859" title="scales.utils.Path[Item,Section,CC]" class="keyword">new</a> <a title="anonymous class $anon extends scales.utils.Path[Item,Section,CC]" id="78859">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">(</span><a href="#84097" title="()scales.utils.Top[Item,Section,CC]">Top</a><span class="delimiter">(</span><span class="delimiter">)</span>, <a href="#84077" title="(index: Int, focus: scales.utils.package.ItemOrTree[Item,Section,CC])scales.utils.Node[Item,Section,CC]">Node</a><span class="delimiter">(</span>-<span title="Int(-1)" class="int">1</span>, <span title="Null(null)" class="keyword">null</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="scales.utils.package.ItemOrTree[Item,Section,CC]" class="delimiter">[</span><a href="EitherLike.scala.html#8884" title="scales.utils.package.ItemOrTree[Item,Section,CC]">ItemOrTree</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span></span>
<a href="l12"></a><span id="l12">  <span class="delimiter">}</span></span>
<a href="l13"></a><span id="l13"></span>
<a href="l14"></a><span id="l14">  <span class="comment">/**</span>
<a href="l15"></a><span id="l15">   * Returns the root path for its input, uses zipUp to ensure changes are kept</span>
<a href="l16"></a><span id="l16">   */</span></span>
<a href="l17"></a><span id="l17">  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](path: scales.utils.Path[Item,Section,CC])scales.utils.Path[Item,Section,CC]" id="10772">rootPath</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="10776">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="10777">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="10778">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="78952">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC]" id="78951">path</a>: <a href="#84069" title="scales.utils.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#84069" title="scales.utils.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> = <span class="delimiter">{</span></span>
<a href="l18"></a><span id="l18">    <span class="keyword">var</span> <a title="scales.utils.Path[Item,Section,CC]" id="78955">newPath</a> = <a href="#78951" title="scales.utils.Path[Item,Section,CC]">path</a></span>
<a href="l19"></a><span id="l19">    <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#78955" title="scales.utils.Path[Item,Section,CC]">newPath</a>.<a href="#67569" title="=&gt; scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]]">top</a>.<a href="EitherLike.scala.html#38076" title="=&gt; Boolean">isLeft</a><span class="delimiter">)</span></span>
<a href="l20"></a><span id="l20">      <a href="#78955" title="scales.utils.Path[Item,Section,CC]">newPath</a> = <a href="#78955" title="scales.utils.Path[Item,Section,CC]">newPath</a>.<a href="#38058" title="()scales.utils.Path[Item,Section,CC]">zipUp</a></span>
<a href="l21"></a><span id="l21">    <a href="#78955" title="scales.utils.Path[Item,Section,CC]">newPath</a></span>
<a href="l22"></a><span id="l22">  <span class="delimiter">}</span></span>
<a href="l23"></a><span id="l23"></span>
<a href="l24"></a><span id="l24">  <span class="comment">/**</span>
<a href="l25"></a><span id="l25">   * Navigates the path until the new position is reached, throws if either its a new root or the position is not reachable</span>
<a href="l26"></a><span id="l26">   */</span></span>
<a href="l27"></a><span id="l27">  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](path: scales.utils.Path[Item,Section,CC], newPos: scales.utils.Position[Item,Section,CC])(implicit cbf: scales.utils.package.TreeCBF[Item,Section,CC])scales.utils.Path[Item,Section,CC]" id="10779">moveTo</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="10783">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="10784">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="10785">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="78963">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC]" id="78960">path</a>: <a href="#84069" title="scales.utils.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, <a title="scales.utils.Position[Item,Section,CC]" id="78961">newPos</a>: <a href="#9077" title="scales.utils.Position[Item,Section,CC]">Position</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span></span>
<a href="l28"></a><span id="l28">    <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scales.utils.package.TreeCBF[Item,Section,CC]" id="78962">cbf</a> : <span title="scales.utils.package.TreeCBF[Item,Section,CC]">TreeCBF</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> : <a href="#84069" title="scales.utils.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> = <span class="delimiter">{</span></span>
<a href="l29"></a><span id="l29"></span>
<a href="l30"></a><span id="l30">    <span class="keyword">val</span> <a title="scales.utils.Path[Item,Section,CC]" id="78968">root</a> = <a href="#10772" title="(path: scales.utils.Path[Item,Section,CC])scales.utils.Path[Item,Section,CC]">rootPath</a><span class="delimiter">(</span><a href="#78960" title="scales.utils.Path[Item,Section,CC]">path</a><span class="delimiter">)</span></span>
<a href="l31"></a><span id="l31">    <span class="comment">// cheaty way, crap but quick enough</span></span>
<a href="l32"></a><span id="l32">    <span class="comment">// TODO come back to this and properly move,</span></span>
<a href="l33"></a><span id="l33">    <a href="#78961" title="scales.utils.Position[Item,Section,CC]">newPos</a>.<a href="#37834" title="=&gt; scala.collection.immutable.Stack[Int]">position</a>.<span title="=&gt; scala.collection.immutable.Stack[Int]">pop</span>.<span title="(z: scales.utils.Path[Item,Section,CC])(f: (scales.utils.Path[Item,Section,CC], Int) =&gt; scales.utils.Path[Item,Section,CC])scales.utils.Path[Item,Section,CC]">foldLeft</span><span class="delimiter">(</span><a href="#78968" title="scales.utils.Path[Item,Section,CC]">root</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC]" id="79091">path</a>, <a title="Int" id="79092">pos</a><span class="delimiter">)</span> =&gt;</span>
<a href="l34"></a><span id="l34">      <a href="#84069" title="(top: scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]], node: scales.utils.Node[Item,Section,CC])(implicit cbf: scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]])scales.utils.Path[Item,Section,CC]">Path</a><a href="#78962" title="scales.utils.package.TreeCBF[Item,Section,CC]" class="delimiter">(</a><a href="#79091" title="scales.utils.Path[Item,Section,CC]">path</a>, <a href="#84077" title="(index: Int, focus: scales.utils.package.ItemOrTree[Item,Section,CC])scales.utils.Node[Item,Section,CC]">Node</a><span class="delimiter">(</span><a href="#79092" title="Int">pos</a>, <a href="#79091" title="scales.utils.Path[Item,Section,CC]">path</a>.<a href="#38048" title="(idx: Int)scales.utils.package.ItemOrTree[Item,Section,CC]">children</a><span class="delimiter">(</span><a href="#79092" title="Int">pos</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l35"></a><span id="l35">    <span class="delimiter">}</span></span>
<a href="l36"></a><span id="l36">  <span class="delimiter">}</span></span>
<a href="l37"></a><span id="l37"></span>
<a href="l38"></a><span id="l38">  <span class="keyword">type</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]]Either[scales.utils.Path[Item,Section,CC],scales.utils.FoldError]" id="10786">FoldR</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="10787">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="10788">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="10789">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="67696">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> = <span title="Either[scales.utils.Path[Item,Section,CC],scales.utils.FoldError]">Either</span><span class="delimiter">[</span>Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, FoldError<span class="delimiter">]</span></span>
<a href="l39"></a><span id="l39"></span>
<a href="l40"></a><span id="l40">  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](base: scales.utils.Position[Item,Section,CC], x: scales.utils.Position[Item,Section,CC], by: Int)scales.utils.Position[Item,Section,CC]" id="10790">shiftWithBase</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="10794">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="10795">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="10796">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="79159">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="scales.utils.Position[Item,Section,CC]" id="79156">base</a>: <a href="#9077" title="scales.utils.Position[Item,Section,CC]">Position</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, <a title="scales.utils.Position[Item,Section,CC]" id="79157">x</a>: <a href="#9077" title="scales.utils.Position[Item,Section,CC]">Position</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, <a title="Int" id="79158">by</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#9077" title="scales.utils.Position[Item,Section,CC]">Position</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> = <span class="delimiter">{</span></span>
<a href="l41"></a><span id="l41">    <span class="keyword">val</span> <a title="scala.collection.immutable.Stack[Int]" id="79164">up</a> = <a href="#79156" title="scales.utils.Position[Item,Section,CC]">base</a>.<a href="#37834" title="=&gt; scala.collection.immutable.Stack[Int]">position</a>.<span title="=&gt; scala.collection.immutable.Stack[Int]">reverse</span>.<span title="=&gt; scala.collection.immutable.Stack[Int]">pop</span>.<span title="=&gt; scala.collection.immutable.Stack[Int]">reverse</span> <span class="comment">// stack needs to be flipped to get parent</span></span>
<a href="l42"></a><span id="l42">    <span title="scales.utils.Position[Item,Section,CC]" class="keyword">if</span> <span class="delimiter">(</span><a href="StackUtils.scala.html#10657" title="(test: scala.collection.immutable.Stack[Int], against: scala.collection.immutable.Stack[Int])Boolean">sameBase</a><span class="delimiter">(</span><a href="#79164" title="scala.collection.immutable.Stack[Int]">up</a>, <a href="#79157" title="scales.utils.Position[Item,Section,CC]">x</a>.<a href="#37834" title="=&gt; scala.collection.immutable.Stack[Int]">position</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span></span>
<a href="l43"></a><span id="l43">      <span class="keyword">val</span> <a href="#79193" title="(scala.collection.immutable.Stack[Int], scala.collection.immutable.Stack[Int])" class="delimiter">(</a><a href="#79192" title="scala.collection.immutable.Stack[Int]" id="79193">above</a>, <a href="#79192" title="scala.collection.immutable.Stack[Int]" id="79194">below</a><span class="delimiter">)</span> = <a href="#79157" title="scales.utils.Position[Item,Section,CC]">x</a>.<a href="#37834" title="=&gt; scala.collection.immutable.Stack[Int]">position</a>.<span title="(n: Int)(scala.collection.immutable.Stack[Int], scala.collection.immutable.Stack[Int])">splitAt</span><span title="(scala.collection.immutable.Stack[Int], scala.collection.immutable.Stack[Int]) @unchecked" class="delimiter">(</span><a href="#79164" title="scala.collection.immutable.Stack[Int]">up</a>.<span title="=&gt; Int">size</span><span class="delimiter">)</span></span>
<a href="l44"></a><span id="l44">      <span class="keyword">val</span> <a title="Int" id="79195">oldv</a> = <a href="#79194" title="scala.collection.immutable.Stack[Int]">below</a>.<span title="=&gt; Int">top</span></span>
<a href="l45"></a><span id="l45">      <span class="keyword">val</span> <a title="scala.collection.immutable.Stack[Int]" id="79196">old</a> = <a href="#79194" title="scala.collection.immutable.Stack[Int]">below</a>.<span title="=&gt; scala.collection.immutable.Stack[Int]">pop</span></span>
<a href="l46"></a><span id="l46">      <span class="keyword">val</span> <a title="scala.collection.immutable.Stack[Int]" id="79197">newpos</a> = <a href="#79193" title="scala.collection.immutable.Stack[Int]">above</a> <span title="(that: scala.collection.GenTraversableOnce[Int])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stack[Int],Int,scala.collection.immutable.Stack[Int]])scala.collection.immutable.Stack[Int]">++</span> <span class="delimiter">(</span><a href="#79196" title="scala.collection.immutable.Stack[Int]">old</a>.<span title="(elem: Int)scala.collection.immutable.Stack[Int]">push</span><span class="delimiter">(</span><a href="#79195" title="Int">oldv</a> <span title="(x: Int)Int">+</span> <a href="#79158" title="Int">by</a><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l47"></a><span id="l47">      <span title="scales.utils.PositionImpl[Item,Section,CC]" class="keyword">new</span> <a href="#84091" title="scales.utils.PositionImpl[Item,Section,CC]">PositionImpl</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">(</span></span>
<a href="l48"></a><span id="l48">        <a href="#79197" title="scala.collection.immutable.Stack[Int]">newpos</a>,</span>
<a href="l49"></a><span id="l49">        <a href="#79157" title="scales.utils.Position[Item,Section,CC]">x</a>.<a href="#37833" title="=&gt; scales.utils.Path[Item,Section,CC]">root</a><span class="delimiter">)</span></span>
<a href="l50"></a><span id="l50">    <span class="delimiter">}</span> <span class="keyword">else</span> <a href="#79157" title="scales.utils.Position[Item,Section,CC]">x</a></span>
<a href="l51"></a><span id="l51">  <span class="delimiter">}</span></span>
<a href="l52"></a><span id="l52"></span>
<a href="l53"></a><span id="l53">  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](positions: Seq[scales.utils.Position[Item,Section,CC]])Seq[scales.utils.Position[Item,Section,CC]]" id="10797">cleanBelow</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="10801">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="10802">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="10803">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="79495">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[scales.utils.Position[Item,Section,CC]]" id="79494">positions</a>: <span title="Seq[scales.utils.Position[Item,Section,CC]]">Seq</span><span class="delimiter">[</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Seq[scales.utils.Position[Item,Section,CC]]">Seq</span><span class="delimiter">[</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#79494" title="Seq[scales.utils.Position[Item,Section,CC]]">positions</a>.<span title="(p: (scales.utils.Position[Item,Section,CC]) =&gt; Boolean)Seq[scales.utils.Position[Item,Section,CC]]">dropWhile</span> <span class="delimiter">{</span> <a title="scales.utils.Position[Item,Section,CC]" id="79501">x</a> =&gt;</span>
<a href="l54"></a><span id="l54">    <a href="StackUtils.scala.html#10657" title="(test: scala.collection.immutable.Stack[Int], against: scala.collection.immutable.Stack[Int])Boolean">sameBase</a><span class="delimiter">(</span><a href="#79494" title="Seq[scales.utils.Position[Item,Section,CC]]">positions</a>.<span title="=&gt; scales.utils.Position[Item,Section,CC]">head</span>.<a href="#37834" title="=&gt; scala.collection.immutable.Stack[Int]">position</a>, <a href="#79501" title="scales.utils.Position[Item,Section,CC]">x</a>.<a href="#37834" title="=&gt; scala.collection.immutable.Stack[Int]">position</a><span class="delimiter">)</span></span>
<a href="l55"></a><span id="l55">  <span class="delimiter">}</span></span>
<a href="l56"></a><span id="l56"></span>
<a href="l57"></a><span id="l57">  <span class="keyword">type</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](scales.utils.Path[Item,Section,CC]) =&gt; Paths.this.FoldR[Item,Section,CC]" id="10804">PathFoldR</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="10805">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="10806">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="10807">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="67474">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">(</span>Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; FoldR<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span></span>
<a href="l58"></a><span id="l58"></span>
<a href="l59"></a><span id="l59">  <span class="comment">/**</span>
<a href="l60"></a><span id="l60">   * Folds over positions within a single path, for example all given children.  As such positions must be calculated.</span>
<a href="l61"></a><span id="l61">   *</span>
<a href="l62"></a><span id="l62">   * Takes the first root, returning Right(NoSingleRoot) if any of the subsequent roots don't match.</span>
<a href="l63"></a><span id="l63">   *</span>
<a href="l64"></a><span id="l64">   * folder retrieves the current path</span>
<a href="l65"></a><span id="l65">   *</span>
<a href="l66"></a><span id="l66">   * Each iteration folds the resulting tree back into the path. As this function must maintain the Path it does not expose the new path root until the result.</span>
<a href="l67"></a><span id="l67">   */</span></span>
<a href="l68"></a><span id="l68">  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]], ACC](locations: Iterable[scales.utils.Path[Item,Section,CC]], accumulator: ACC)(folder: (ACC, scales.utils.Path[Item,Section,CC]) =&gt; (ACC, scales.utils.FoldOperation[Item,Section,CC]))(implicit cbf: scales.utils.package.TreeCBF[Item,Section,CC])Either[(ACC, scales.utils.Path[Item,Section,CC]),scales.utils.FoldError]" id="10808">foldPositions</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="10813">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="10814">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="10815">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="38030">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="10816">ACC</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Iterable[scales.utils.Path[Item,Section,CC]]" id="38026">locations</a>: <span title="Iterable[scales.utils.Path[Item,Section,CC]]">Iterable</span><span class="delimiter">[</span>Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="ACC" id="38027">accumulator</a>: <a href="#10816" title="ACC">ACC</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(ACC, scales.utils.Path[Item,Section,CC]) =&gt; (ACC, scales.utils.FoldOperation[Item,Section,CC])" id="38028">folder</a>: <span class="delimiter">(</span>ACC, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; <span class="delimiter">(</span>ACC, FoldOperation<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scales.utils.package.TreeCBF[Item,Section,CC]" id="38029">cbf</a> : <span title="scales.utils.package.TreeCBF[Item,Section,CC]">TreeCBF</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>  : <span title="Either[(ACC, scales.utils.Path[Item,Section,CC]),scales.utils.FoldError]">Either</span><span class="delimiter">[</span><span class="delimiter">(</span>ACC, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>, FoldError<span class="delimiter">]</span> = <span class="delimiter">{</span></span>
<a href="l69"></a><span id="l69">    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#38026" title="Iterable[scales.utils.Path[Item,Section,CC]]">locations</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <span title="(b: scales.utils.NoPaths.type)Right[Nothing,scales.utils.NoPaths.type]">Right</span><span class="delimiter">(</span><a href="#83944" title="object scales.utils.NoPaths">NoPaths</a><span class="delimiter">)</span></span>
<a href="l70"></a><span id="l70"></span>
<a href="l71"></a><span id="l71">    <span class="keyword">val</span> <a title="Iterable[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])]" id="79513">sorted</a> = <a href="#10861" title="(paths: Iterable[scales.utils.Path[Item,Section,CC]], isDescending: Boolean)Iterable[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])]">sortPositions</a><span class="delimiter">(</span><a href="#38026" title="Iterable[scales.utils.Path[Item,Section,CC]]">locations</a><span class="delimiter">)</span></span>
<a href="l72"></a><span id="l72"></span>
<a href="l73"></a><span id="l73">    <span class="keyword">val</span> <a title="(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])" id="79514">head</a> = <a href="#79513" title="Iterable[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])]">sorted</a>.<span title="=&gt; (scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])">head</span></span>
<a href="l74"></a><span id="l74">    <span class="keyword">var</span> <a title="ACC" id="79515">accum</a> = <a href="#38027" title="ACC">accumulator</a></span>
<a href="l75"></a><span id="l75"></span>
<a href="l76"></a><span id="l76">    <span class="keyword">val</span> <a title="scales.utils.Position[Item,Section,CC]" id="79516">rootPosition</a> = <a href="#79514" title="(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])">head</a>.<span title="=&gt; scales.utils.Position[Item,Section,CC]">_1</span></span>
<a href="l77"></a><span id="l77">    <span class="keyword">val</span> <a title="Boolean" id="79517">differentRoot</a> = <a href="#79513" title="Iterable[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])]">sorted</a>.<span title="(p: ((scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])) =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><a title="(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])" id="79572">p</a> =&gt; <a href="#79572" title="(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])">p</a>.<span title="=&gt; scales.utils.Position[Item,Section,CC]">_1</span>.<a href="#37833" title="=&gt; scales.utils.Path[Item,Section,CC]">root</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#79516" title="scales.utils.Position[Item,Section,CC]">rootPosition</a>.<a href="#37833" title="=&gt; scales.utils.Path[Item,Section,CC]">root</a><span class="delimiter">)</span></span>
<a href="l78"></a><span id="l78">    <span title="Either[(ACC, scales.utils.Path[Item,Section,CC]),scales.utils.FoldError]" class="keyword">if</span> <span class="delimiter">(</span><a href="#79517" title="Boolean">differentRoot</a><span class="delimiter">)</span></span>
<a href="l79"></a><span id="l79">      <span title="(b: scales.utils.NoSingleRoot.type)Right[Nothing,scales.utils.NoSingleRoot.type]">Right</span><span class="delimiter">(</span><a href="#83959" title="object scales.utils.NoSingleRoot">NoSingleRoot</a><span class="delimiter">)</span></span>
<a href="l80"></a><span id="l80">    <span class="keyword">else</span> <span class="delimiter">{</span></span>
<a href="l81"></a><span id="l81"></span>
<a href="l82"></a><span id="l82">      <span class="comment">// fold over positions, with the path from head, let each foldop decide what the next position sequence looks like</span></span>
<a href="l83"></a><span id="l83">      <span class="keyword">var</span> <a title="Seq[scales.utils.Position[Item,Section,CC]]" id="79581">positions</a> = <a href="#79513" title="Iterable[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])]">sorted</a>.<span title="(f: ((scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])) =&gt; scales.utils.Position[Item,Section,CC])(implicit bf: scala.collection.generic.CanBuildFrom[Iterable[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])],scales.utils.Position[Item,Section,CC],Iterable[scales.utils.Position[Item,Section,CC]]])Iterable[scales.utils.Position[Item,Section,CC]]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Iterable.Coll,scales.utils.Position[Item,Section,CC],Iterable[scales.utils.Position[Item,Section,CC]]]" class="delimiter">(</span><a href="#79600" title="(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])">_</a>.<span title="=&gt; scales.utils.Position[Item,Section,CC]">_1</span><span class="delimiter">)</span>.<span title="=&gt; Seq[scales.utils.Position[Item,Section,CC]]">toSeq</span></span>
<a href="l84"></a><span id="l84">      <span class="keyword">var</span> <a title="scales.utils.Path[Item,Section,CC]" id="79582">path</a> = <a href="#79514" title="(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])">head</a>.<span title="=&gt; scales.utils.Path[Item,Section,CC]">_2</span></span>
<a href="l85"></a><span id="l85">      <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#79581" title="Seq[scales.utils.Position[Item,Section,CC]]">positions</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#79583" title="()Unit" class="delimiter">{</a></span>
<a href="l86"></a><span id="l86"></span>
<a href="l87"></a><span id="l87">        <span class="keyword">val</span> <a href="#79673" title="(ACC, scales.utils.FoldOperation[Item,Section,CC])" class="delimiter">(</a><a href="#79672" title="ACC" id="79673">accf</a>, <a href="#79672" title="scales.utils.FoldOperation[Item,Section,CC]" id="79674">res</a><span class="delimiter">)</span> = <a href="#38028" title="(v1: ACC, v2: scales.utils.Path[Item,Section,CC])(ACC, scales.utils.FoldOperation[Item,Section,CC])">folder</a><span title="(ACC, scales.utils.FoldOperation[Item,Section,CC]) @unchecked" class="delimiter">(</span><a href="#79515" title="ACC">accum</a>, <a href="#79582" title="scales.utils.Path[Item,Section,CC]">path</a><span class="delimiter">)</span></span>
<a href="l88"></a><span id="l88">        <a href="#79515" title="ACC">accum</a> = <a href="#79673" title="ACC">accf</a></span>
<a href="l89"></a><span id="l89">        <span class="keyword">val</span> <a title="scales.utils.package.FoldR[Item,Section,CC]" id="79675">matched</a> = <a href="#79674" title="scales.utils.FoldOperation[Item,Section,CC]">res</a>.<a href="#79511" title="(path: scales.utils.Path[Item,Section,CC])scales.utils.package.FoldR[Item,Section,CC]">perform</a><span class="delimiter">(</span><a href="#79582" title="scales.utils.Path[Item,Section,CC]">path</a><span class="delimiter">)</span> <span class="comment">//matchIt( res, path )</span></span>
<a href="l90"></a><span id="l90"></span>
<a href="l91"></a><span id="l91">        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#79675" title="scales.utils.package.FoldR[Item,Section,CC]">matched</a>.<span title="=&gt; Boolean">isLeft</span><span class="delimiter">)</span> <span class="delimiter">{</span></span>
<a href="l92"></a><span id="l92">          <a href="#79582" title="scales.utils.Path[Item,Section,CC]">path</a> = <a href="#79675" title="scales.utils.package.FoldR[Item,Section,CC]">matched</a>.<span title="=&gt; Either.LeftProjection[scales.utils.Path[Item,Section,CC],scales.utils.FoldError]">left</span>.<span title="=&gt; scales.utils.Path[Item,Section,CC]">get</span></span>
<a href="l93"></a><span id="l93">          <a href="#79581" title="Seq[scales.utils.Position[Item,Section,CC]]">positions</a> = <a href="#79674" title="scales.utils.FoldOperation[Item,Section,CC]">res</a>.<a href="#79510" title="(positions: Seq[scales.utils.Position[Item,Section,CC]])Seq[scales.utils.Position[Item,Section,CC]]">adjust</a><span class="delimiter">(</span><a href="#79581" title="Seq[scales.utils.Position[Item,Section,CC]]">positions</a><span class="delimiter">)</span></span>
<a href="l94"></a><span id="l94">          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#79581" title="Seq[scales.utils.Position[Item,Section,CC]]">positions</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span class="delimiter">{</span></span>
<a href="l95"></a><span id="l95">            <a href="#79582" title="scales.utils.Path[Item,Section,CC]">path</a> = <a href="#10779" title="(path: scales.utils.Path[Item,Section,CC], newPos: scales.utils.Position[Item,Section,CC])(implicit cbf: scales.utils.package.TreeCBF[Item,Section,CC])scales.utils.Path[Item,Section,CC]">moveTo</a><a href="#38029" title="scales.utils.package.TreeCBF[Item,Section,CC]" class="delimiter">(</a><a href="#79582" title="scales.utils.Path[Item,Section,CC]">path</a>, <a href="#79581" title="Seq[scales.utils.Position[Item,Section,CC]]">positions</a>.<span title="=&gt; scales.utils.Position[Item,Section,CC]">head</span><span class="delimiter">)</span> <span class="comment">// else nothing we keep path to call root</span></span>
<a href="l96"></a><span id="l96">          <span class="delimiter">}</span></span>
<a href="l97"></a><span id="l97">        <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Nothing" class="keyword">return</span> <span title="(b: scales.utils.FoldError)Right[Nothing,scales.utils.FoldError]">Right</span><span class="delimiter">(</span><a href="#79675" title="scales.utils.package.FoldR[Item,Section,CC]">matched</a>.<span title="=&gt; Either.RightProjection[scales.utils.Path[Item,Section,CC],scales.utils.FoldError]">right</span>.<span title="=&gt; scales.utils.FoldError">get</span><span class="delimiter">)</span></span>
<a href="l98"></a><span id="l98">      <span class="delimiter">}</span></span>
<a href="l99"></a><span id="l99">      <span title="(a: (ACC, scales.utils.Path[Item,Section,CC]))Left[(ACC, scales.utils.Path[Item,Section,CC]),Nothing]">Left</span><span class="delimiter">(</span><span title="(_1: ACC, _2: scales.utils.Path[Item,Section,CC])(ACC, scales.utils.Path[Item,Section,CC])" class="delimiter">(</span><a href="#79515" title="ACC">accum</a>, <a href="#10772" title="(path: scales.utils.Path[Item,Section,CC])scales.utils.Path[Item,Section,CC]">rootPath</a><span class="delimiter">(</span><a href="#79582" title="scales.utils.Path[Item,Section,CC]">path</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l100"></a><span id="l100">    <span class="delimiter">}</span></span>
<a href="l101"></a><span id="l101">  <span class="delimiter">}</span></span>
<a href="l102"></a><span id="l102"></span>
<a href="l103"></a><span id="l103">  <span class="comment">/**</span>
<a href="l104"></a><span id="l104">   * Folds over positions within a single path, for example all given children.  As such positions must be calculated.</span>
<a href="l105"></a><span id="l105">   *</span>
<a href="l106"></a><span id="l106">   * Takes the first root, returning Right(NoSingleRoot) if any of the subsequent roots don't match.</span>
<a href="l107"></a><span id="l107">   *</span>
<a href="l108"></a><span id="l108">   * folder retrieves the current path</span>
<a href="l109"></a><span id="l109">   *</span>
<a href="l110"></a><span id="l110">   * Each iteration folds the resulting tree back into the path. As this function must maintain the Path it does not expose the new path root until the result.</span>
<a href="l111"></a><span id="l111">   */</span></span>
<a href="l112"></a><span id="l112">  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](locations: Iterable[scales.utils.Path[Item,Section,CC]])(folder: (scales.utils.Path[Item,Section,CC]) =&gt; scales.utils.FoldOperation[Item,Section,CC])(implicit cbf: scales.utils.package.TreeCBF[Item,Section,CC])Paths.this.FoldR[Item,Section,CC]" id="10817">foldPositions</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="10821">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="10822">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="10823">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="38017">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="Iterable[scales.utils.Path[Item,Section,CC]]" id="37845">locations</a>: <span title="Iterable[scales.utils.Path[Item,Section,CC]]">Iterable</span><span class="delimiter">[</span>Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(scales.utils.Path[Item,Section,CC]) =&gt; scales.utils.FoldOperation[Item,Section,CC]" id="37846">folder</a>: <span class="delimiter">(</span>Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; FoldOperation<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scales.utils.package.TreeCBF[Item,Section,CC]" id="37847">cbf</a> : <span title="scales.utils.package.TreeCBF[Item,Section,CC]">TreeCBF</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> : <span title="Paths.this.FoldR[Item,Section,CC]">FoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> =</span>
<a href="l113"></a><span id="l113">    <a href="#10808" title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]], ACC](locations: Iterable[scales.utils.Path[Item,Section,CC]], accumulator: ACC)(folder: (ACC, scales.utils.Path[Item,Section,CC]) =&gt; (ACC, scales.utils.FoldOperation[Item,Section,CC]))(implicit cbf: scales.utils.package.TreeCBF[Item,Section,CC])Either[(ACC, scales.utils.Path[Item,Section,CC]),scales.utils.FoldError]">foldPositions</a><span title="(locations: Iterable[scales.utils.Path[Item,Section,CC]], accumulator: Unit)(folder: (Unit, scales.utils.Path[Item,Section,CC]) =&gt; (Unit, scales.utils.FoldOperation[Item,Section,CC]))(implicit cbf: scales.utils.package.TreeCBF[Item,Section,CC])Either[(Unit, scales.utils.Path[Item,Section,CC]),scales.utils.FoldError]" class="delimiter">[</span><a href="#10821" title="Item">Item</a>, <a href="#10822" title="Section">Section</a>, <a href="#10823" title="CC">CC</a>, <span title="Unit">Unit</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#37845" title="Iterable[scales.utils.Path[Item,Section,CC]]">locations</a>, <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><a href="#37847" title="scales.utils.package.TreeCBF[Item,Section,CC]" class="delimiter">(</a><span class="delimiter">(</span><a title="Unit" id="79825">u</a>, <a title="scales.utils.Path[Item,Section,CC]" id="79826">p</a><span class="delimiter">)</span> =&gt; <span title="(_1: Unit, _2: scales.utils.FoldOperation[Item,Section,CC])(Unit, scales.utils.FoldOperation[Item,Section,CC])" class="delimiter">(</span><span title="Unit" class="delimiter">(</span><span class="delimiter">)</span>, <a href="#37846" title="(v1: scales.utils.Path[Item,Section,CC])scales.utils.FoldOperation[Item,Section,CC]">folder</a><span class="delimiter">(</span><a href="#79826" title="scales.utils.Path[Item,Section,CC]">p</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>.</span>
<a href="l114"></a><span id="l114">      <span title="(fa: ((Unit, scales.utils.Path[Item,Section,CC])) =&gt; Product with Serializable with Either[scales.utils.Path[Item,Section,CC],scales.utils.FoldError], fb: (scales.utils.FoldError) =&gt; Product with Serializable with Either[scales.utils.Path[Item,Section,CC],scales.utils.FoldError])Product with Serializable with Either[scales.utils.Path[Item,Section,CC],scales.utils.FoldError]">fold</span><span class="delimiter">(</span><a title="(Unit, scales.utils.Path[Item,Section,CC])" id="79846">x</a> =&gt; <span title="(a: scales.utils.Path[Item,Section,CC])Left[scales.utils.Path[Item,Section,CC],Nothing]">Left</span><span class="delimiter">(</span><a href="#79846" title="(Unit, scales.utils.Path[Item,Section,CC])">x</a>.<span title="=&gt; scales.utils.Path[Item,Section,CC]">_2</span><span class="delimiter">)</span>, <span title="(b: scales.utils.FoldError)Right[Nothing,scales.utils.FoldError]">Right</span><span class="delimiter">(</span><a href="#79859" title="scales.utils.FoldError">_</a><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l115"></a><span id="l115"></span>
<a href="l116"></a><span id="l116">  <span class="keyword">val</span> <a title="Int" id="10824">NotSameRoot</a> = <span title="Int(1000)" class="int">1000</span></span>
<a href="l117"></a><span id="l117"></span>
<a href="l118"></a><span id="l118">  <span class="comment">/**</span>
<a href="l119"></a><span id="l119">   * When paths are not in the same root, they are compared based on the identity hash of the given roots.  Of course this relies on that function</span>
<a href="l120"></a><span id="l120">   * having a decent vm implementation.</span>
<a href="l121"></a><span id="l121">   *</span>
<a href="l122"></a><span id="l122">   * @param path1</span>
<a href="l123"></a><span id="l123">   * @param path2</span>
<a href="l124"></a><span id="l124">   * @return 1 if path1 is before path2, -1 if path2 is before path1, 0 if they are the same and NotSameRoot+-1 if they are not in the same root</span>
<a href="l125"></a><span id="l125">   */</span></span>
<a href="l126"></a><span id="l126">  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](path1: scales.utils.Position[Item,Section,CC], path2: scales.utils.Position[Item,Section,CC])Int" id="10826">comparePathPositions</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="10830">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="10831">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="10832">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="79883">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="scales.utils.Position[Item,Section,CC]" id="79880">path1</a>: <a href="#9077" title="scales.utils.Position[Item,Section,CC]">Position</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, <a title="scales.utils.Position[Item,Section,CC]" id="79881">path2</a>: <a href="#9077" title="scales.utils.Position[Item,Section,CC]">Position</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <span class="delimiter">{</span></span>
<a href="l127"></a><span id="l127"></span>
<a href="l128"></a><span id="l128">    <span title="Int" class="keyword">if</span> <span class="delimiter">(</span><a href="#79880" title="scales.utils.Position[Item,Section,CC]">path1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#79881" title="scales.utils.Position[Item,Section,CC]">path2</a><span class="delimiter">)</span> <span title="Int(0)" class="int">0</span></span>
<a href="l129"></a><span id="l129">    <span class="keyword">else</span> <span class="delimiter">{</span></span>
<a href="l130"></a><span id="l130">      <span title="Int" class="keyword">if</span> <span class="delimiter">(</span><a href="#79880" title="scales.utils.Position[Item,Section,CC]">path1</a>.<a href="#37833" title="=&gt; scales.utils.Path[Item,Section,CC]">root</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#79881" title="scales.utils.Position[Item,Section,CC]">path2</a>.<a href="#37833" title="=&gt; scales.utils.Path[Item,Section,CC]">root</a><span class="delimiter">)</span> <span class="delimiter">{</span></span>
<a href="l131"></a><span id="l131">        <span class="keyword">val</span> <a title="Int" id="79888">p1R</a> = <span title="object java.lang.System">System</span>.<span title="(x$1: Any)Int">identityHashCode</span><span class="delimiter">(</span><a href="#79880" title="scales.utils.Position[Item,Section,CC]">path1</a>.<a href="#37833" title="=&gt; scales.utils.Path[Item,Section,CC]">root</a><span class="delimiter">)</span></span>
<a href="l132"></a><span id="l132">        <span class="keyword">val</span> <a title="Int" id="79889">p2R</a> = <span title="object java.lang.System">System</span>.<span title="(x$1: Any)Int">identityHashCode</span><span class="delimiter">(</span><a href="#79881" title="scales.utils.Position[Item,Section,CC]">path2</a>.<a href="#37833" title="=&gt; scales.utils.Path[Item,Section,CC]">root</a><span class="delimiter">)</span></span>
<a href="l133"></a><span id="l133">        <a href="#10824" title="=&gt; Int">NotSameRoot</a> <span title="(x: Int)Int">+</span> <span class="delimiter">(</span><span title="Int" class="keyword">if</span> <span class="delimiter">(</span><a href="#79888" title="Int">p1R</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#79889" title="Int">p2R</a><span class="delimiter">)</span> <span title="Int(1)" class="int">1</span> <span class="keyword">else</span> -<span title="Int(-1)" class="int">1</span><span class="delimiter">)</span></span>
<a href="l134"></a><span id="l134">      <span class="delimiter">}</span> <span class="keyword">else</span></span>
<a href="l135"></a><span id="l135">        <a href="StackUtils.scala.html#10656" title="(p1: scala.collection.immutable.Stack[Int], p2: scala.collection.immutable.Stack[Int])Int">compareStack</a><span class="delimiter">(</span><a href="#79880" title="scales.utils.Position[Item,Section,CC]">path1</a>.<a href="#37834" title="=&gt; scala.collection.immutable.Stack[Int]">position</a>, <a href="#79881" title="scales.utils.Position[Item,Section,CC]">path2</a>.<a href="#37834" title="=&gt; scala.collection.immutable.Stack[Int]">position</a><span class="delimiter">)</span></span>
<a href="l136"></a><span id="l136">    <span class="delimiter">}</span></span>
<a href="l137"></a><span id="l137">  <span class="delimiter">}</span></span>
<a href="l138"></a><span id="l138"></span>
<a href="l139"></a><span id="l139">  <span class="comment">/**</span>
<a href="l140"></a><span id="l140">   * When paths are not in the same root, they are compared based on the identity hash of the given roots.  Of course this relies on that function</span>
<a href="l141"></a><span id="l141">   * having a decent vm implementation. See http://www.w3.org/TR/2007/REC-xpath20-20070123/#dt-document-order, tree order must remain constant.  Its</span>
<a href="l142"></a><span id="l142">   * also a pretty sensible approach for non xml trees.</span>
<a href="l143"></a><span id="l143">   *</span>
<a href="l144"></a><span id="l144">   * @param path1</span>
<a href="l145"></a><span id="l145">   * @param path2</span>
<a href="l146"></a><span id="l146">   * @return 1 if path1 is before path2, -1 if path2 is before path1, 0 if they are the same and NotSameRoot+-1 if they are not in the same root</span>
<a href="l147"></a><span id="l147">   */</span></span>
<a href="l148"></a><span id="l148">  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](path1: scales.utils.Path[Item,Section,CC], path2: scales.utils.Path[Item,Section,CC])(Int, scales.utils.Position[Item,Section,CC], scales.utils.Position[Item,Section,CC])" id="10833">comparePaths</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="10837">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="10838">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="10839">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="37839">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC]" id="37837">path1</a>: <a href="#84069" title="scales.utils.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, <a title="scales.utils.Path[Item,Section,CC]" id="37838">path2</a>: <a href="#84069" title="scales.utils.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(Int, scales.utils.Position[Item,Section,CC], scales.utils.Position[Item,Section,CC])" class="delimiter">(</span>Int, Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> =</span>
<a href="l149"></a><span id="l149">    <a href="#10840" title="(path1: (scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC]), path2: (scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC]))(Int, scales.utils.Position[Item,Section,CC], scales.utils.Position[Item,Section,CC])">comparePaths</a><span class="delimiter">(</span><span title="(_1: scales.utils.Position[Item,Section,CC], _2: scales.utils.Path[Item,Section,CC])(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])" class="delimiter">(</span><a href="#37837" title="scales.utils.Path[Item,Section,CC]">path1</a>.<a href="#38061" title="()scales.utils.Position[Item,Section,CC]">position</a>, <a href="#37837" title="scales.utils.Path[Item,Section,CC]">path1</a><span class="delimiter">)</span>, <span title="(_1: scales.utils.Position[Item,Section,CC], _2: scales.utils.Path[Item,Section,CC])(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])" class="delimiter">(</span><a href="#37838" title="scales.utils.Path[Item,Section,CC]">path2</a>.<a href="#38061" title="()scales.utils.Position[Item,Section,CC]">position</a>, <a href="#37838" title="scales.utils.Path[Item,Section,CC]">path2</a><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l150"></a><span id="l150"></span>
<a href="l151"></a><span id="l151">  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](path1: (scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC]), path2: (scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC]))(Int, scales.utils.Position[Item,Section,CC], scales.utils.Position[Item,Section,CC])" id="10840">comparePaths</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="10844">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="10845">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="10846">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="37831">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])" id="37829">path1</a>: <span title="(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])" class="delimiter">(</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>, <a title="(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])" id="37830">path2</a>: <span title="(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])" class="delimiter">(</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span>: <span title="(Int, scales.utils.Position[Item,Section,CC], scales.utils.Position[Item,Section,CC])" class="delimiter">(</span>Int, Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span></span>
<a href="l152"></a><span id="l152">    <span title="(Int, scales.utils.Position[Item,Section,CC], scales.utils.Position[Item,Section,CC])" class="keyword">if</span> <span class="delimiter">(</span><a href="#37829" title="(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])">path1</a>.<span title="=&gt; scales.utils.Path[Item,Section,CC]">_2</span> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#37830" title="(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])">path2</a>.<span title="=&gt; scales.utils.Path[Item,Section,CC]">_2</span><span class="delimiter">)</span> <span class="delimiter">{</span></span>
<a href="l153"></a><span id="l153">      <span class="keyword">val</span> <a title="scales.utils.Position[Item,Section,CC]" id="80206">pos</a> = <a href="#37829" title="(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])">path1</a>.<span title="=&gt; scales.utils.Position[Item,Section,CC]">_1</span></span>
<a href="l154"></a><span id="l154">      <span title="(_1: Int, _2: scales.utils.Position[Item,Section,CC], _3: scales.utils.Position[Item,Section,CC])(Int, scales.utils.Position[Item,Section,CC], scales.utils.Position[Item,Section,CC])" class="delimiter">(</span><span title="Int(0)" class="int">0</span>, <a href="#80206" title="scales.utils.Position[Item,Section,CC]">pos</a>, <a href="#80206" title="scales.utils.Position[Item,Section,CC]">pos</a><span class="delimiter">)</span></span>
<a href="l155"></a><span id="l155">    <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span></span>
<a href="l156"></a><span id="l156">      <span class="keyword">val</span> <a href="#80218" title="(scales.utils.Position[Item,Section,CC], scales.utils.Position[Item,Section,CC])" class="delimiter">(</a><a href="#80217" title="scales.utils.Position[Item,Section,CC]" id="80218">pos1</a>, <a href="#80217" title="scales.utils.Position[Item,Section,CC]" id="80219">pos2</a><span class="delimiter">)</span> = <span title="(_1: scales.utils.Position[Item,Section,CC], _2: scales.utils.Position[Item,Section,CC])(scales.utils.Position[Item,Section,CC], scales.utils.Position[Item,Section,CC])" class="delimiter">(</span><a href="#37829" title="(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])">path1</a>.<span title="=&gt; scales.utils.Position[Item,Section,CC]">_1</span>, <a href="#37830" title="(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])">path2</a>.<span title="=&gt; scales.utils.Position[Item,Section,CC]">_1</span><span class="delimiter">)</span></span>
<a href="l157"></a><span id="l157">      <span title="(_1: Int, _2: scales.utils.Position[Item,Section,CC], _3: scales.utils.Position[Item,Section,CC])(Int, scales.utils.Position[Item,Section,CC], scales.utils.Position[Item,Section,CC])" class="delimiter">(</span><a href="#10826" title="(path1: scales.utils.Position[Item,Section,CC], path2: scales.utils.Position[Item,Section,CC])Int">comparePathPositions</a><span class="delimiter">(</span><a href="#80218" title="scales.utils.Position[Item,Section,CC]">pos1</a>, <a href="#80219" title="scales.utils.Position[Item,Section,CC]">pos2</a><span class="delimiter">)</span>, <a href="#80218" title="scales.utils.Position[Item,Section,CC]">pos1</a>, <a href="#80219" title="scales.utils.Position[Item,Section,CC]">pos2</a><span class="delimiter">)</span></span>
<a href="l158"></a><span id="l158">    <span class="delimiter">}</span></span>
<a href="l159"></a><span id="l159">  <span class="delimiter">}</span></span>
<a href="l160"></a><span id="l160"></span>
<a href="l161"></a><span id="l161">  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](tree: scales.utils.Tree[Item,Section,CC])(implicit cbf: scales.utils.package.TreeCBF[Item,Section,CC])scales.utils.Path[Item,Section,CC]" id="10847">top</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="10851">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="10852">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="10853">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="80266">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="scales.utils.Tree[Item,Section,CC]" id="80264">tree</a>: <a href="Trees.scala.html#9220" title="scales.utils.Tree[Item,Section,CC]">Tree</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span></span>
<a href="l162"></a><span id="l162">    <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scales.utils.package.TreeCBF[Item,Section,CC]" id="80265">cbf</a> : <span title="scales.utils.package.TreeCBF[Item,Section,CC]">TreeCBF</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> : <a href="#84069" title="scales.utils.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> =</span>
<a href="l163"></a><span id="l163">    <a href="#84069" title="(top: scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]], node: scales.utils.Node[Item,Section,CC])(implicit cbf: scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]])scales.utils.Path[Item,Section,CC]">Path</a><a href="#80265" title="scales.utils.package.TreeCBF[Item,Section,CC]" class="delimiter">(</a><a href="#84097" title="()scales.utils.Top[Item,Section,CC]">Top</a><span class="delimiter">(</span><span class="delimiter">)</span>, <a href="#84077" title="(index: Int, focus: scales.utils.package.ItemOrTree[Item,Section,CC])scales.utils.Node[Item,Section,CC]">Node</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span>, <a href="#80264" title="scales.utils.Tree[Item,Section,CC]">tree</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="comment">//Right(tree)))</span></span>
<a href="l164"></a><span id="l164"></span>
<a href="l165"></a><span id="l165">  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](paths: Iterable[scales.utils.Path[Item,Section,CC]])Iterable[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])]" id="10854">positions</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="10858">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="10859">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="10860">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="80337">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="Iterable[scales.utils.Path[Item,Section,CC]]" id="80336">paths</a>: <span title="Iterable[scales.utils.Path[Item,Section,CC]]">Iterable</span><span class="delimiter">[</span>Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Iterable[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])]">Iterable</span><span class="delimiter">[</span><span class="delimiter">(</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span> =</span>
<a href="l166"></a><span id="l166">    <a href="#80336" title="Iterable[scales.utils.Path[Item,Section,CC]]">paths</a>.<span title="(f: (scales.utils.Path[Item,Section,CC]) =&gt; (scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC]))(implicit bf: scala.collection.generic.CanBuildFrom[Iterable[scales.utils.Path[Item,Section,CC]],(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC]),Iterable[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])]])Iterable[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Iterable.Coll,(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC]),Iterable[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])]]" class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC]" id="80362">x</a> =&gt; <span title="(_1: scales.utils.Position[Item,Section,CC], _2: scales.utils.Path[Item,Section,CC])(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])" class="delimiter">(</span><a href="#80362" title="scales.utils.Path[Item,Section,CC]">x</a>.<a href="#38061" title="()scales.utils.Position[Item,Section,CC]">position</a>, <a href="#80362" title="scales.utils.Path[Item,Section,CC]">x</a><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l167"></a><span id="l167"></span>
<a href="l168"></a><span id="l168">  <span class="comment">/**</span>
<a href="l169"></a><span id="l169">   * Sorts according to position of each path item, descending or descending based on a depth first then rightwise order.</span>
<a href="l170"></a><span id="l170">   *</span>
<a href="l171"></a><span id="l171">   */</span></span>
<a href="l172"></a><span id="l172">  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](paths: Iterable[scales.utils.Path[Item,Section,CC]], isDescending: Boolean)Iterable[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])]" id="10861">sortPositions</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="79531">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="79532">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="79533">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="79544">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="Iterable[scales.utils.Path[Item,Section,CC]]" id="79523">paths</a>: <span title="Iterable[scales.utils.Path[Item,Section,CC]]">Iterable</span><span class="delimiter">[</span>Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>,</span>
<a href="l173"></a><span id="l173">    <span class="comment">//			compareFunction : (Path[Item, Section], Path[Item, Section]) =&gt; Integer = comparePaths _, </span></span>
<a href="l174"></a><span id="l174">    <a title="Boolean" id="79527">isDescending</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>: <span title="Iterable[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])]">Iterable</span><span class="delimiter">[</span><span class="delimiter">(</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span> =</span>
<a href="l175"></a><span id="l175"></span>
<a href="l176"></a><span id="l176">    <span class="comment">// Have to force them anyway</span></span>
<a href="l177"></a><span id="l177">    scala.util.<span title="object scala.util.Sorting">Sorting</span>.<span title="(a: Seq[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])], f: ((scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC]), (scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])) =&gt; Boolean)(implicit evidence$5: scala.reflect.ClassManifest[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])])Array[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])]">stableSort</span><span title="(xs: Array[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])])scala.collection.mutable.WrappedArray[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])]" class="delimiter">(</span><a href="#10854" title="(paths: Iterable[scales.utils.Path[Item,Section,CC]])Iterable[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])]">positions</a><span class="delimiter">(</span><a href="#79523" title="Iterable[scales.utils.Path[Item,Section,CC]]">paths</a><span class="delimiter">)</span>.<span title="=&gt; Seq[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])]">toSeq</span>, <span class="delimiter">(</span>p1: <span title="(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])" class="delimiter">(</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>, p2: <span title="(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])" class="delimiter">(</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span></span>
<a href="l178"></a><span id="l178">      <span class="keyword">val</span> <a href="#80955" title="(Int, scales.utils.Position[Item,Section,CC], scales.utils.Position[Item,Section,CC])" class="delimiter">(</a><a href="#80954" title="Int" id="80955">res</a>, <a href="#80954" title="scales.utils.Position[Item,Section,CC]" id="80956">pos1</a>, <a href="#80954" title="scales.utils.Position[Item,Section,CC]" id="80957">pos2</a><span class="delimiter">)</span> = <a href="#10840" title="(path1: (scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC]), path2: (scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC]))(Int, scales.utils.Position[Item,Section,CC], scales.utils.Position[Item,Section,CC])">comparePaths</a><span title="(Int, scales.utils.Position[Item,Section,CC], scales.utils.Position[Item,Section,CC]) @unchecked" class="delimiter">(</span><a href="#80952" title="(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])">p1</a>, <a href="#80953" title="(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])">p2</a><span class="delimiter">)</span> <span class="comment">//compareFunction(p1, p2)</span></span>
<a href="l179"></a><span id="l179">      <span class="keyword">val</span> <a title="Boolean" id="80958">order</a> = <span class="delimiter">(</span><a href="#80955" title="Int">res</a> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span> <span title="(x: Boolean)Boolean">||</span> <a href="#80955" title="Int">res</a> <span title="(x: Int)Boolean">==</span> <span class="delimiter">(</span><a href="#10824" title="=&gt; Int">NotSameRoot</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l180"></a><span id="l180">      <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#79527" title="Boolean">isDescending</a><span class="delimiter">)</span> <a href="#80958" title="Boolean">order</a> <span class="keyword">else</span> <span title="=&gt; Boolean">!</span><a href="#80958" title="Boolean">order</a></span>
<a href="l181"></a><span id="l181">    <span class="delimiter">}</span><span class="delimiter">)</span></span>
<a href="l182"></a><span id="l182">  <span class="comment">/**</span>
<a href="l183"></a><span id="l183">   * Sorts according to position of each path item, descending or descending based on a depth first then rightwise order.</span>
<a href="l184"></a><span id="l184">   *</span>
<a href="l185"></a><span id="l185">   */</span></span>
<a href="l186"></a><span id="l186">  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](paths: Iterable[scales.utils.Path[Item,Section,CC]], isDescending: Boolean)Iterable[scales.utils.Path[Item,Section,CC]]" id="10868">sort</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="81256">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="81257">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="81258">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="81330">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="Iterable[scales.utils.Path[Item,Section,CC]]" id="81248">paths</a>: <span title="Iterable[scales.utils.Path[Item,Section,CC]]">Iterable</span><span class="delimiter">[</span>Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>,</span>
<a href="l187"></a><span id="l187">    <a title="Boolean" id="81252">isDescending</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>: <span title="Iterable[scales.utils.Path[Item,Section,CC]]">Iterable</span><span class="delimiter">[</span>Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#10861" title="(paths: Iterable[scales.utils.Path[Item,Section,CC]], isDescending: Boolean)Iterable[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])]">sortPositions</a><span class="delimiter">(</span><a href="#81248" title="Iterable[scales.utils.Path[Item,Section,CC]]">paths</a>, <a href="#81252" title="Boolean">isDescending</a><span class="delimiter">)</span>.<span title="(f: ((scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])) =&gt; scales.utils.Path[Item,Section,CC])(implicit bf: scala.collection.generic.CanBuildFrom[Iterable[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])],scales.utils.Path[Item,Section,CC],Iterable[scales.utils.Path[Item,Section,CC]]])Iterable[scales.utils.Path[Item,Section,CC]]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Iterable.Coll,scales.utils.Path[Item,Section,CC],Iterable[scales.utils.Path[Item,Section,CC]]]" class="delimiter">(</span><a title="(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])" id="81306">x</a> =&gt; <a href="#81306" title="(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])">x</a>.<span title="=&gt; scales.utils.Path[Item,Section,CC]">_2</span><span class="delimiter">)</span></span>
<a href="l188"></a><span id="l188"></span>
<a href="l189"></a><span id="l189"><span class="delimiter">}</span></span>
<a href="l190"></a><span id="l190"></span>
<a href="l191"></a><span id="l191"><span class="keyword">trait</span> <a title="trait PathImplicits extends java.lang.Object with ScalaObject" id="9070">PathImplicits</a> <span title="ScalaObject" class="delimiter">{</span></span>
<a href="l192"></a><span id="l192">  <span class="comment">/**</span>
<a href="l193"></a><span id="l193">   * Provide &amp; combinator to pass the result of one fold onto the other,</span>
<a href="l194"></a><span id="l194">   * in the case of failure no further joined functions will be called.</span>
<a href="l195"></a><span id="l195">   *</span>
<a href="l196"></a><span id="l196">   * And provides | which allows NoPaths failures, allowing the use site to decide</span>
<a href="l197"></a><span id="l197">   * how to combine</span>
<a href="l198"></a><span id="l198">   */</span></span>
<a href="l199"></a><span id="l199">  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](f: (scales.utils.Path[Item,Section,CC]) =&gt; scales.utils.package.FoldR[Item,Section,CC])java.lang.Object{def &amp;(next: (scales.utils.Path[Item,Section,CC]) =&gt; scales.utils.package.FoldR[Item,Section,CC]): (scales.utils.Path[Item,Section,CC]) =&gt; scales.utils.package.FoldR[Item,Section,CC]; def |(next: (scales.utils.Path[Item,Section,CC]) =&gt; scales.utils.package.FoldR[Item,Section,CC]): (scales.utils.Path[Item,Section,CC]) =&gt; scales.utils.package.FoldR[Item,Section,CC]}" id="66642">fToFoldRToCombine</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="66646">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="66647">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="66648">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="67467">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="(scales.utils.Path[Item,Section,CC]) =&gt; scales.utils.package.FoldR[Item,Section,CC]" id="67458">f</a>: <span title="(scales.utils.Path[Item,Section,CC]) =&gt; scales.utils.package.FoldR[Item,Section,CC]">PathFoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#67461" title="java.lang.Object{def &amp;(next: (scales.utils.Path[Item,Section,CC]) =&gt; scales.utils.package.FoldR[Item,Section,CC]): (scales.utils.Path[Item,Section,CC]) =&gt; scales.utils.package.FoldR[Item,Section,CC]; def |(next: (scales.utils.Path[Item,Section,CC]) =&gt; scales.utils.package.FoldR[Item,Section,CC]): (scales.utils.Path[Item,Section,CC]) =&gt; scales.utils.package.FoldR[Item,Section,CC]}" class="keyword">new</a> <a title="anonymous class $anon extends java.lang.Object" id="67461" class="delimiter">{</a></span>
<a href="l200"></a><span id="l200">    <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(next: (scales.utils.Path[Item,Section,CC]) =&gt; scales.utils.package.FoldR[Item,Section,CC], orOnFail: (scales.utils.Path[Item,Section,CC], scales.utils.FoldError) =&gt; scales.utils.package.FoldR[Item,Section,CC])(scales.utils.Path[Item,Section,CC]) =&gt; scales.utils.package.FoldR[Item,Section,CC]" id="67463">onSuccess</a><span class="delimiter">(</span><a title="(scales.utils.Path[Item,Section,CC]) =&gt; scales.utils.package.FoldR[Item,Section,CC]" id="67471">next</a>: <span title="(scales.utils.Path[Item,Section,CC]) =&gt; scales.utils.package.FoldR[Item,Section,CC]">PathFoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, <a title="(scales.utils.Path[Item,Section,CC], scales.utils.FoldError) =&gt; scales.utils.package.FoldR[Item,Section,CC]" id="67473">orOnFail</a>: <span class="delimiter">(</span>Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, FoldError<span class="delimiter">)</span> =&gt; FoldR<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> = <span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC]" id="67715">a</a>, <a title="scales.utils.FoldError" id="67716">b</a><span class="delimiter">)</span> =&gt; <span title="(b: scales.utils.FoldError)Right[Nothing,scales.utils.FoldError]">Right</span><span class="delimiter">(</span><a href="#67716" title="scales.utils.FoldError">b</a><span class="delimiter">)</span><span class="delimiter">)</span>: <span title="(scales.utils.Path[Item,Section,CC]) =&gt; scales.utils.package.FoldR[Item,Section,CC]">PathFoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> =</span>
<a href="l201"></a><span id="l201">      <span class="delimiter">(</span>path: <a href="#84069" title="scales.utils.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> =&gt;</span>
<a href="l202"></a><span id="l202">        <span class="comment">// modify back in (allows changes), or pass on the error</span></span>
<a href="l203"></a><span id="l203">        <a href="#67458" title="(v1: scales.utils.Path[Item,Section,CC])scales.utils.package.FoldR[Item,Section,CC]">f</a><span class="delimiter">(</span><a href="#67539" title="scales.utils.Path[Item,Section,CC]">path</a><span class="delimiter">)</span>.<span title="(fa: (scales.utils.Path[Item,Section,CC]) =&gt; scales.utils.package.FoldR[Item,Section,CC], fb: (scales.utils.FoldError) =&gt; scales.utils.package.FoldR[Item,Section,CC])scales.utils.package.FoldR[Item,Section,CC]">fold</span><span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC]" id="67548">fres</a> =&gt;</span>
<a href="l204"></a><span id="l204">          <a href="#67471" title="(v1: scales.utils.Path[Item,Section,CC])scales.utils.package.FoldR[Item,Section,CC]">next</a><span class="delimiter">(</span><a href="#67539" title="scales.utils.Path[Item,Section,CC]">path</a>.<a href="#38059" title="(newFocus: (scales.utils.package.ItemOrTree[Item,Section,CC]) =&gt; scales.utils.package.ItemOrTree[Item,Section,CC])scales.utils.Path[Item,Section,CC]">modify</a><span class="delimiter">(</span><a title="scales.utils.package.ItemOrTree[Item,Section,CC]" id="67667">_</a> =&gt; <a href="#67548" title="scales.utils.Path[Item,Section,CC]">fres</a>.<a href="#38051" title="()scales.utils.Tree[Item,Section,CC]">tree</a><span class="delimiter">)</span><span class="delimiter">)</span>,<span class="comment">//Right(fres.tree))),</span></span>
<a href="l205"></a><span id="l205">          <a href="#67473" title="(v1: scales.utils.Path[Item,Section,CC], v2: scales.utils.FoldError)scales.utils.package.FoldR[Item,Section,CC]">orOnFail</a><span class="delimiter">(</span><a href="#67539" title="scales.utils.Path[Item,Section,CC]">path</a>, <a href="#67692" title="scales.utils.FoldError">_</a><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l206"></a><span id="l206"></span>
<a href="l207"></a><span id="l207">    <span class="keyword">def</span> <a title="(next: (scales.utils.Path[Item,Section,CC]) =&gt; scales.utils.package.FoldR[Item,Section,CC])(scales.utils.Path[Item,Section,CC]) =&gt; scales.utils.package.FoldR[Item,Section,CC]" id="67464">&amp;</a><span class="delimiter">(</span><a title="(scales.utils.Path[Item,Section,CC]) =&gt; scales.utils.package.FoldR[Item,Section,CC]" id="67466">next</a>: <span title="(scales.utils.Path[Item,Section,CC]) =&gt; scales.utils.package.FoldR[Item,Section,CC]">PathFoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(scales.utils.Path[Item,Section,CC]) =&gt; scales.utils.package.FoldR[Item,Section,CC]">PathFoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> =</span>
<a href="l208"></a><span id="l208">      <a href="#67463" title="(next: (scales.utils.Path[Item,Section,CC]) =&gt; scales.utils.package.FoldR[Item,Section,CC], orOnFail: (scales.utils.Path[Item,Section,CC], scales.utils.FoldError) =&gt; scales.utils.package.FoldR[Item,Section,CC])(scales.utils.Path[Item,Section,CC]) =&gt; scales.utils.package.FoldR[Item,Section,CC]">onSuccess</a><span class="delimiter">(</span><a href="#67466" title="(scales.utils.Path[Item,Section,CC]) =&gt; scales.utils.package.FoldR[Item,Section,CC]">next</a><span class="delimiter">)</span></span>
<a href="l209"></a><span id="l209"></span>
<a href="l210"></a><span id="l210">    <span class="keyword">def</span> <a title="(next: (scales.utils.Path[Item,Section,CC]) =&gt; scales.utils.package.FoldR[Item,Section,CC])(scales.utils.Path[Item,Section,CC]) =&gt; scales.utils.package.FoldR[Item,Section,CC]" id="67465">|</a><span class="delimiter">(</span><a title="(scales.utils.Path[Item,Section,CC]) =&gt; scales.utils.package.FoldR[Item,Section,CC]" id="67468">next</a>: <span title="(scales.utils.Path[Item,Section,CC]) =&gt; scales.utils.package.FoldR[Item,Section,CC]">PathFoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(scales.utils.Path[Item,Section,CC]) =&gt; scales.utils.package.FoldR[Item,Section,CC]">PathFoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> =</span>
<a href="l211"></a><span id="l211">      <a href="#67463" title="(next: (scales.utils.Path[Item,Section,CC]) =&gt; scales.utils.package.FoldR[Item,Section,CC], orOnFail: (scales.utils.Path[Item,Section,CC], scales.utils.FoldError) =&gt; scales.utils.package.FoldR[Item,Section,CC])(scales.utils.Path[Item,Section,CC]) =&gt; scales.utils.package.FoldR[Item,Section,CC]">onSuccess</a><span class="delimiter">(</span><a href="#67468" title="(scales.utils.Path[Item,Section,CC]) =&gt; scales.utils.package.FoldR[Item,Section,CC]">next</a>, orOnFail = <span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC]" id="67702">path</a>, <a title="scales.utils.FoldError" id="67703">res</a><span class="delimiter">)</span> =&gt;</span>
<a href="l212"></a><span id="l212">        <span title="scales.utils.package.FoldR[Item,Section,CC]" class="keyword">if</span> <span class="delimiter">(</span><a href="#67703" title="scales.utils.FoldError">res</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#83944" title="object scales.utils.NoPaths">NoPaths</a><span class="delimiter">)</span></span>
<a href="l213"></a><span id="l213">          <a href="#67468" title="(v1: scales.utils.Path[Item,Section,CC])scales.utils.package.FoldR[Item,Section,CC]">next</a><span class="delimiter">(</span><a href="#67702" title="scales.utils.Path[Item,Section,CC]">path</a><span class="delimiter">)</span></span>
<a href="l214"></a><span id="l214">        <span class="keyword">else</span></span>
<a href="l215"></a><span id="l215">          <span title="(b: scales.utils.FoldError)Right[Nothing,scales.utils.FoldError]">Right</span><span class="delimiter">(</span><a href="#67703" title="scales.utils.FoldError">res</a><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l216"></a><span id="l216">  <span class="delimiter">}</span></span>
<a href="l217"></a><span id="l217"></span>
<a href="l218"></a><span id="l218"><span class="delimiter">}</span></span>
<a href="l219"></a><span id="l219"></span>
<a href="l220"></a><span id="l220">case <span class="keyword">class</span> <a title="class Top[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]] extends java.lang.Object with scales.utils.LeftLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]] with ScalaObject with Product with Serializable" id="84097">Top</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="78889">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="78890">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="78891">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="78900">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><a href="#84097" title="ScalaObject" class="delimiter">(</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="EitherLike.scala.html#8887" title="scales.utils.LeftLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]]">LeftLike</a><span class="delimiter">[</span>Top<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span> </span>
<a href="l221"></a><span id="l221"></span>
<a href="l222"></a><span id="l222"></span>
<a href="l223"></a><span id="l223"><span class="comment">/**</span>
<a href="l224"></a><span id="l224"> * Positions only have meaning for a given Path(s).</span>
<a href="l225"></a><span id="l225"> *</span>
<a href="l226"></a><span id="l226"> * Their internal representation may change, as such its private to Paths.</span>
<a href="l227"></a><span id="l227"> * r	 * @author Chris</span>
<a href="l228"></a><span id="l228"> *</span>
<a href="l229"></a><span id="l229"> */</span></span>
<a href="l230"></a><span id="l230"><span class="keyword">trait</span> <a title="trait Position[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]] extends java.lang.Object" id="9077">Position</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="9078">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="9079">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="9080">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="81365">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> <span title="java.lang.Object" class="delimiter">{</span></span>
<a href="l231"></a><span id="l231">  <span class="keyword">private</span><span class="delimiter">[</span>utils<span class="delimiter">]</span> <span class="keyword">val</span> <a title="=&gt; scales.utils.Path[Item,Section,CC]" id="37833">root</a>: <a href="#84069" title="scales.utils.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span></span>
<a href="l232"></a><span id="l232">  <span class="keyword">private</span><span class="delimiter">[</span>utils<span class="delimiter">]</span> <span class="keyword">val</span> <a title="=&gt; scala.collection.immutable.Stack[Int]" id="37834">position</a>: <span title="scala.collection.immutable.Stack[Int]">Stack</span><span class="delimiter">[</span>Int<span class="delimiter">]</span></span>
<a href="l233"></a><span id="l233"><span class="delimiter">}</span></span>
<a href="l234"></a><span id="l234"></span>
<a href="l235"></a><span id="l235"><span class="keyword">private</span><span class="delimiter">[</span>utils<span class="delimiter">]</span> case <span class="keyword">class</span> <a title="class PositionImpl[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]] extends java.lang.Object with scales.utils.Position[Item,Section,CC] with ScalaObject with Product with Serializable" id="84091">PositionImpl</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="81417">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="81418">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="81419">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="84084">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><a href="#84091" title="ScalaObject" class="delimiter">(</a><span class="keyword">val</span> <a title="scala.collection.immutable.Stack[Int]" id="84082">position</a>: <span title="scala.collection.immutable.Stack[Int]">Stack</span><span class="delimiter">[</span>Int<span class="delimiter">]</span>, <span class="keyword">val</span> <a title="scales.utils.Path[Item,Section,CC]" id="84083">root</a>: <a href="#84069" title="scales.utils.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#9077" title="scales.utils.Position[Item,Section,CC]">Position</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span></span>
<a href="l236"></a><span id="l236"></span>
<a href="l237"></a><span id="l237"><span class="comment">/**</span>
<a href="l238"></a><span id="l238"> * Vectors are used due to big O considerations,</span>
<a href="l239"></a><span id="l239"> * List looks ok until appendChild or previousSibling are called.  There may be a better</span>
<a href="l240"></a><span id="l240"> * choice out there though....</span>
<a href="l241"></a><span id="l241"> *</span>
<a href="l242"></a><span id="l242"> * @author Chris</span>
<a href="l243"></a><span id="l243"> *</span>
<a href="l244"></a><span id="l244"> */</span> <span class="comment">// note - lazy is a perf killer for building, probably doesn't save much over interrogation either (given Iterator is used) </span></span>
<a href="l245"></a><span id="l245">case <span class="keyword">class</span> <a title="class Node[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]] extends java.lang.Object with ScalaObject with Product with Serializable" id="84077">Node</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="67593">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="67594">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="67595">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="67619">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><a href="#84077" title="ScalaObject" class="delimiter">(</a><a title="Int" id="67617">index</a>: <span title="Int">Int</span>, <a title="scales.utils.package.ItemOrTree[Item,Section,CC]" id="67618">focus</a>: <a href="EitherLike.scala.html#8884" title="scales.utils.package.ItemOrTree[Item,Section,CC]">ItemOrTree</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span></span>
<a href="l246"></a><span id="l246"></span>
<a href="l247"></a><span id="l247">case <span class="keyword">class</span> <a title="class Path[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]] extends java.lang.Object with Iterable[scales.utils.Path[Item,Section,CC]] with scales.utils.RightLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]] with ScalaObject with Product with Serializable" id="84069">Path</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="67559">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="67560">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="67561">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="67572">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><a href="#84069" title="ScalaObject" class="delimiter">(</a><a title="scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]]" id="67569">top</a>: <a href="EitherLike.scala.html#8884" title="scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]]">EitherLike</a><span class="delimiter">[</span>Top<span class="delimiter">[</span>Item,Section,CC<span class="delimiter">]</span>, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="scales.utils.Node[Item,Section,CC]" id="67570">node</a>: <a href="#84077" title="scales.utils.Node[Item,Section,CC]">Node</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span></span>
<a href="l248"></a><span id="l248">     <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]]" id="67571">cbf</a> : <span title="scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]]">CanBuildFrom</span><span class="delimiter">[</span>CC<span class="delimiter">[</span>_<span class="delimiter">]</span>, ItemOrTree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, CC<span class="delimiter">[</span>ItemOrTree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <span title="Iterable[scales.utils.Path[Item,Section,CC]]">Iterable</span><span class="delimiter">[</span>Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span> <span class="keyword">with</span> <a href="EitherLike.scala.html#8890" title="scales.utils.RightLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]]">RightLike</a><span class="delimiter">[</span>Top<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span> self =&gt;</span>
<a href="l249"></a><span id="l249"></span>
<a href="l250"></a><span id="l250">  <span class="comment">// for some reason its not liking the types, probably  good one</span></span>
<a href="l251"></a><span id="l251">  <span class="comment">//@inline def asCC( </span></span>
<a href="l252"></a><span id="l252"></span>
<a href="l253"></a><span id="l253">  <span class="keyword">def</span> <a title="=&gt; scales.utils.Tree[Item,Section,CC]" id="38042">parentTree</a> : <a href="Trees.scala.html#9220" title="scales.utils.Tree[Item,Section,CC]">Tree</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> = <a href="#67569" title="=&gt; scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]]">top</a>.<a href="EitherLike.scala.html#38084" title="=&gt; scales.utils.Path[Item,Section,CC]">getRight</a>.<a href="#67570" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67618" title="=&gt; scales.utils.package.ItemOrTree[Item,Section,CC]">focus</a>.<a href="EitherLike.scala.html#38084" title="=&gt; scales.utils.Tree[Item,Section,CC]">getRight</a></span>
<a href="l254"></a><span id="l254"></span>
<a href="l255"></a><span id="l255">  <span class="keyword">def</span> <a title="=&gt; Int" id="38043">parentCount</a> = <span title="Int" class="keyword">if</span> <span class="delimiter">(</span><a href="#67569" title="=&gt; scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]]">top</a>.<a href="EitherLike.scala.html#38076" title="=&gt; Boolean">isLeft</a><span class="delimiter">)</span> <span title="Int(0)" class="int">0</span> <span class="keyword">else</span> <a href="#38042" title="=&gt; scales.utils.Tree[Item,Section,CC]">parentTree</a>.<a href="Trees.scala.html#67676" title="=&gt; CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">children</a>.<span title="=&gt; Int">length</span></span>
<a href="l256"></a><span id="l256"></span>
<a href="l257"></a><span id="l257">  <span class="comment">/** Is there a previous sibling */</span></span>
<a href="l258"></a><span id="l258">  <span class="keyword">def</span> <a title="=&gt; Boolean" id="38044">hasPreviousSibling</a> = <span class="delimiter">(</span><a href="#67570" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67617" title="=&gt; Int">index</a> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#67570" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67617" title="=&gt; Int">index</a> <span title="(x: Int)Boolean">&lt;=</span> <a href="#38043" title="=&gt; Int">parentCount</a><span class="delimiter">)</span></span>
<a href="l259"></a><span id="l259"></span>
<a href="l260"></a><span id="l260">  <span class="comment">/** Does it have a further sibling */</span></span>
<a href="l261"></a><span id="l261">  <span class="keyword">def</span> <a title="=&gt; Boolean" id="38045">hasNextSibling</a> = <span class="delimiter">(</span><a href="#67570" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67617" title="=&gt; Int">index</a> <span title="(x: Int)Boolean">&gt;</span> -<span title="Int(-1)" class="int">1</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#67570" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67617" title="=&gt; Int">index</a> <span title="(x: Int)Boolean">&lt;</span> <span class="delimiter">(</span><a href="#38043" title="=&gt; Int">parentCount</a> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l262"></a><span id="l262"></span>
<a href="l263"></a><span id="l263">  <span class="comment">/**</span>
<a href="l264"></a><span id="l264">   * Is the focus an Item?</span>
<a href="l265"></a><span id="l265">   */</span></span>
<a href="l266"></a><span id="l266">  <span class="keyword">def</span> <a title="=&gt; Boolean" id="38046">isItem</a> = <a href="#67570" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67618" title="=&gt; scales.utils.package.ItemOrTree[Item,Section,CC]">focus</a>.<a href="EitherLike.scala.html#38076" title="=&gt; Boolean">isLeft</a></span>
<a href="l267"></a><span id="l267"></span>
<a href="l268"></a><span id="l268">  <span class="comment">/**</span>
<a href="l269"></a><span id="l269">   * Does the focus have a child?</span>
<a href="l270"></a><span id="l270">   */</span></span>
<a href="l271"></a><span id="l271">  <span class="keyword">def</span> <a title="=&gt; Boolean" id="38047">hasChildren</a> =</span>
<a href="l272"></a><span id="l272">    <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#38046" title="=&gt; Boolean">isItem</a><span class="delimiter">)</span> <span title="Boolean(false)" class="keyword">false</span></span>
<a href="l273"></a><span id="l273">    <span class="keyword">else</span> <a href="#38048" title="=&gt; CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">children</a>.<span title="=&gt; Int">length</span> <span title="(x: Int)Boolean">!=</span> <span title="Int(0)" class="int">0</span></span>
<a href="l274"></a><span id="l274"></span>
<a href="l275"></a><span id="l275">  <span class="comment">/**</span>
<a href="l276"></a><span id="l276">   * Children for a path, don't call unless it is not an item</span>
<a href="l277"></a><span id="l277">   */</span> </span>
<a href="l278"></a><span id="l278">  <span class="keyword">def</span> <a title="=&gt; CC[scales.utils.package.ItemOrTree[Item,Section,CC]]" id="38048">children</a> : <a href="#67561" title="CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">CC</a><span class="delimiter">[</span>ItemOrTree<span class="delimiter">[</span>Item,Section,CC<span class="delimiter">]</span><span class="delimiter">]</span>  = <a href="#67570" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67618" title="=&gt; scales.utils.package.ItemOrTree[Item,Section,CC]">focus</a>.<a href="EitherLike.scala.html#38083" title="=&gt; scales.utils.RightLikeProjection[scales.utils.Tree[Item,Section,CC]]">right</a>.<a href="EitherLike.scala.html#38063" title="=&gt; scales.utils.Tree[Item,Section,CC]">get</a>.<a href="Trees.scala.html#67676" title="=&gt; CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">children</a></span>
<a href="l279"></a><span id="l279"></span>
<a href="l280"></a><span id="l280">  <span class="comment">/**</span>
<a href="l281"></a><span id="l281">   * Call hasPreviousSibling first to assert there is a previous sibling</span>
<a href="l282"></a><span id="l282">   */</span></span>
<a href="l283"></a><span id="l283">  <span class="keyword">def</span> <a title="=&gt; scales.utils.Path[Item,Section,CC]" id="38049">previousSibling</a> = <a href="#84069" title="(top: scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]], node: scales.utils.Node[Item,Section,CC])(implicit cbf: scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]])scales.utils.Path[Item,Section,CC]">Path</a><a href="#67571" title="scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]]" class="delimiter">(</a><a href="#67569" title="=&gt; scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]]">top</a>, <a href="#84077" title="(index: Int, focus: scales.utils.package.ItemOrTree[Item,Section,CC])scales.utils.Node[Item,Section,CC]">Node</a><span class="delimiter">(</span><a href="#67570" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67617" title="=&gt; Int">index</a> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span>, <a href="#38042" title="=&gt; scales.utils.Tree[Item,Section,CC]">parentTree</a>.<a href="Trees.scala.html#67676" title="=&gt; CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">children</a>.<span title="(idx: Int)scales.utils.package.ItemOrTree[Item,Section,CC]">apply</span><span class="delimiter">(</span><a href="#67570" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67617" title="=&gt; Int">index</a> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l284"></a><span id="l284"></span>
<a href="l285"></a><span id="l285">  <span class="comment">/**</span>
<a href="l286"></a><span id="l286">   * Call hasNextSibling first to assert there is a next sibling</span>
<a href="l287"></a><span id="l287">   */</span></span>
<a href="l288"></a><span id="l288">  <span class="keyword">def</span> <a title="=&gt; scales.utils.Path[Item,Section,CC]" id="38050">nextSibling</a> = <a href="#84069" title="(top: scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]], node: scales.utils.Node[Item,Section,CC])(implicit cbf: scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]])scales.utils.Path[Item,Section,CC]">Path</a><a href="#67571" title="scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]]" class="delimiter">(</a><a href="#67569" title="=&gt; scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]]">top</a>, <a href="#84077" title="(index: Int, focus: scales.utils.package.ItemOrTree[Item,Section,CC])scales.utils.Node[Item,Section,CC]">Node</a><span class="delimiter">(</span><a href="#67570" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67617" title="=&gt; Int">index</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span>, <a href="#38042" title="=&gt; scales.utils.Tree[Item,Section,CC]">parentTree</a>.<a href="Trees.scala.html#67676" title="(idx: Int)scales.utils.package.ItemOrTree[Item,Section,CC]">children</a><span class="delimiter">(</span><a href="#67570" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67617" title="=&gt; Int">index</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l289"></a><span id="l289"></span>
<a href="l290"></a><span id="l290">  <span class="comment">/**</span>
<a href="l291"></a><span id="l291">   * get the tree (isItem == false)</span>
<a href="l292"></a><span id="l292">   * @return</span>
<a href="l293"></a><span id="l293">   */</span></span>
<a href="l294"></a><span id="l294">  <span class="keyword">def</span> <a title="()scales.utils.Tree[Item,Section,CC]" id="38051">tree</a><span class="delimiter">(</span><span class="delimiter">)</span> = <a href="#67570" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67618" title="=&gt; scales.utils.package.ItemOrTree[Item,Section,CC]">focus</a>.<a href="EitherLike.scala.html#38084" title="=&gt; scales.utils.Tree[Item,Section,CC]">getRight</a></span>
<a href="l295"></a><span id="l295"></span>
<a href="l296"></a><span id="l296">  <span class="comment">/**</span>
<a href="l297"></a><span id="l297">   * get the item (isItem == true)</span>
<a href="l298"></a><span id="l298">   * @return</span>
<a href="l299"></a><span id="l299">   */</span></span>
<a href="l300"></a><span id="l300">  <span class="keyword">def</span> <a title="()Item" id="38052">item</a><span class="delimiter">(</span><span class="delimiter">)</span> = <a href="#67570" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67618" title="=&gt; scales.utils.package.ItemOrTree[Item,Section,CC]">focus</a>.<a href="EitherLike.scala.html#38082" title="=&gt; Item">getLeft</a></span>
<a href="l301"></a><span id="l301"></span>
<a href="l302"></a><span id="l302">  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">class</span> <a title="class ItemIterator extends java.lang.Object with Iterator[scales.utils.Path[Item,Section,CC]] with ScalaObject" id="38053">ItemIterator</a><a href="#38053" title="ScalaObject" class="delimiter">(</a><span class="delimiter">)</span> <span class="keyword">extends</span> <span title="Iterator[scales.utils.Path[Item,Section,CC]]">Iterator</span><span class="delimiter">[</span>Path<span class="delimiter">[</span>Item,Section, CC<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span> </span>
<a href="l303"></a><span id="l303">    <span class="keyword">def</span> <a title="=&gt; Boolean" id="81780">hasNext</a> = <span title="Boolean(false)" class="keyword">false</span></span>
<a href="l304"></a><span id="l304">    <span class="keyword">def</span> <a title="()Nothing" id="81781">next</a><span class="delimiter">(</span><span class="delimiter">)</span> = <a href="package.scala.html#10616" title="(str: String)Nothing">error</a><span class="delimiter">(</span><span title="java.lang.String(&quot;Cannot iterate over an item&quot;)" class="string">&quot;Cannot iterate over an item&quot;</span><span class="delimiter">)</span></span>
<a href="l305"></a><span id="l305">  <span class="delimiter">}</span></span>
<a href="l306"></a><span id="l306"></span>
<a href="l307"></a><span id="l307">  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">class</span> <a title="class TreeIterator extends java.lang.Object with Iterator[scales.utils.Path[Item,Section,CC]] with ScalaObject" id="38054">TreeIterator</a><a href="#38054" title="ScalaObject" class="delimiter">(</a><span class="delimiter">)</span> <span class="keyword">extends</span> <span title="Iterator[scales.utils.Path[Item,Section,CC]]">Iterator</span><span class="delimiter">[</span>Path<span class="delimiter">[</span>Item,Section, CC<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span> </span>
<a href="l308"></a><span id="l308">    <span class="keyword">val</span> <a title="Iterator[scales.utils.package.ItemOrTree[Item,Section,CC]]" id="81791">c</a> = <a href="#38048" title="=&gt; CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">children</a>.<span title="=&gt; Iterator[scales.utils.package.ItemOrTree[Item,Section,CC]]">iterator</span></span>
<a href="l309"></a><span id="l309">    <span class="keyword">var</span> <a title="Int" id="81794">index</a> = -<span title="Int(-1)" class="int">1</span></span>
<a href="l310"></a><span id="l310">    </span>
<a href="l311"></a><span id="l311">    <span class="keyword">def</span> <a title="=&gt; Boolean" id="81796">hasNext</a> = <a href="#81791" title="=&gt; Iterator[scales.utils.package.ItemOrTree[Item,Section,CC]]">c</a>.<span title="=&gt; Boolean">hasNext</span></span>
<a href="l312"></a><span id="l312"></span>
<a href="l313"></a><span id="l313">    <span class="keyword">def</span> <a title="()scales.utils.Path[Item,Section,CC]" id="81797">next</a><span class="delimiter">(</span><span class="delimiter">)</span> : <a href="#84069" title="scales.utils.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> = <span class="delimiter">{</span></span>
<a href="l314"></a><span id="l314">      <a href="#81794" title="(x$1: Int)Unit">index</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span></span>
<a href="l315"></a><span id="l315">      <a href="#84069" title="(top: scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]], node: scales.utils.Node[Item,Section,CC])(implicit cbf: scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]])scales.utils.Path[Item,Section,CC]">Path</a><a href="#67571" title="scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]]" class="delimiter">(</a><a href="#84069" title="scales.utils.Path[Item,Section,CC]">self</a>, <a href="#84077" title="(index: Int, focus: scales.utils.package.ItemOrTree[Item,Section,CC])scales.utils.Node[Item,Section,CC]">Node</a><span class="delimiter">(</span><a href="#81794" title="=&gt; Int">index</a>, <a href="#81791" title="=&gt; Iterator[scales.utils.package.ItemOrTree[Item,Section,CC]]">c</a>.<span title="()scales.utils.package.ItemOrTree[Item,Section,CC]">next</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l316"></a><span id="l316">    <span class="delimiter">}</span></span>
<a href="l317"></a><span id="l317">  <span class="delimiter">}</span></span>
<a href="l318"></a><span id="l318"></span>
<a href="l319"></a><span id="l319">  <span class="comment">/**</span>
<a href="l320"></a><span id="l320">   * Provide iterator to the path of the children</span>
<a href="l321"></a><span id="l321">   */</span></span>
<a href="l322"></a><span id="l322">  <span class="keyword">def</span> <a title="()Iterator[scales.utils.Path[Item,Section,CC]]" id="38055">iterator</a><span class="delimiter">(</span><span class="delimiter">)</span> = </span>
<a href="l323"></a><span id="l323">    <span title="Iterator[scales.utils.Path[Item,Section,CC]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#38046" title="=&gt; Boolean">isItem</a><span class="delimiter">)</span></span>
<a href="l324"></a><span id="l324">      <span title="Path.this.ItemIterator" class="keyword">new</span> <a href="#38053" title="Path.this.ItemIterator">ItemIterator</a><span class="delimiter">(</span><span class="delimiter">)</span></span>
<a href="l325"></a><span id="l325">    <span class="keyword">else</span></span>
<a href="l326"></a><span id="l326">      <span title="Path.this.TreeIterator" class="keyword">new</span> <a href="#38054" title="Path.this.TreeIterator">TreeIterator</a><span class="delimiter">(</span><span class="delimiter">)</span></span>
<a href="l327"></a><span id="l327"></span>
<a href="l328"></a><span id="l328">  <span class="comment">/**</span>
<a href="l329"></a><span id="l329">   * Returns either the first child or none.  Note the child would still need to be unpacked</span>
<a href="l330"></a><span id="l330">   * @return</span>
<a href="l331"></a><span id="l331">   */</span></span>
<a href="l332"></a><span id="l332">  <span class="keyword">def</span> <a title="()Option[scales.utils.Path[Item,Section,CC]]" id="38056">firstChild</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Option[scales.utils.Path[Item,Section,CC]]">Option</span><span class="delimiter">[</span>Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span> =</span>
<a href="l333"></a><span id="l333">    <span title="Option[scales.utils.Path[Item,Section,CC]]" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#38047" title="=&gt; Boolean">hasChildren</a><span class="delimiter">)</span> <span title="object None">None</span> <span class="comment">// can't have a child if its just a data node</span></span>
<a href="l334"></a><span id="l334">    <span class="keyword">else</span> <span title="(x: scales.utils.Path[Item,Section,CC])Some[scales.utils.Path[Item,Section,CC]]">Some</span><span class="delimiter">(</span><a href="#84069" title="(top: scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]], node: scales.utils.Node[Item,Section,CC])(implicit cbf: scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]])scales.utils.Path[Item,Section,CC]">Path</a><a href="#67571" title="scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]]" class="delimiter">(</a><a href="#84069" title="scales.utils.Path[Item,Section,CC]" class="keyword">this</a>, <a href="#84077" title="(index: Int, focus: scales.utils.package.ItemOrTree[Item,Section,CC])scales.utils.Node[Item,Section,CC]">Node</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span>, <a href="#38048" title="=&gt; CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">children</a>.<span title="=&gt; scales.utils.package.ItemOrTree[Item,Section,CC]">head</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l335"></a><span id="l335"></span>
<a href="l336"></a><span id="l336">  <span class="comment">/**</span>
<a href="l337"></a><span id="l337">   * Returns either the last child or none.  Note the child would still need to be unpacked</span>
<a href="l338"></a><span id="l338">   * @return</span>
<a href="l339"></a><span id="l339">   */</span></span>
<a href="l340"></a><span id="l340">  <span class="keyword">def</span> <a title="()Option[scales.utils.Path[Item,Section,CC]]" id="38057">lastChild</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Option[scales.utils.Path[Item,Section,CC]]">Option</span><span class="delimiter">[</span>Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="comment">// don't ask children twice</span></span>
<a href="l341"></a><span id="l341">    <span title="Option[scales.utils.Path[Item,Section,CC]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#38046" title="=&gt; Boolean">isItem</a><span class="delimiter">)</span> <span title="object None">None</span> <span class="comment">// items don't have children</span></span>
<a href="l342"></a><span id="l342">    <span class="keyword">else</span> <span class="delimiter">{</span></span>
<a href="l343"></a><span id="l343">      <span class="keyword">val</span> <a title="CC[scales.utils.package.ItemOrTree[Item,Section,CC]]" id="81994">c</a> = <a href="#38048" title="=&gt; CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">children</a></span>
<a href="l344"></a><span id="l344">      <span title="Option[scales.utils.Path[Item,Section,CC]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#81994" title="CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">c</a>.<span title="=&gt; Int">length</span> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span title="object None">None</span> <span class="comment">// no children</span></span>
<a href="l345"></a><span id="l345">      <span class="keyword">else</span> <span class="delimiter">{</span></span>
<a href="l346"></a><span id="l346">	<span class="keyword">val</span> <a title="Int" id="82001">newPos</a> = <a href="#81994" title="CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">c</a>.<span title="=&gt; Int">length</span> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span></span>
<a href="l347"></a><span id="l347">	<span title="(x: scales.utils.Path[Item,Section,CC])Some[scales.utils.Path[Item,Section,CC]]">Some</span><span class="delimiter">(</span><a href="#84069" title="(top: scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]], node: scales.utils.Node[Item,Section,CC])(implicit cbf: scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]])scales.utils.Path[Item,Section,CC]">Path</a><a href="#67571" title="scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]]" class="delimiter">(</a><a href="#84069" title="scales.utils.Path[Item,Section,CC]" class="keyword">this</a>,</span>
<a href="l348"></a><span id="l348">	  <a href="#84077" title="(index: Int, focus: scales.utils.package.ItemOrTree[Item,Section,CC])scales.utils.Node[Item,Section,CC]">Node</a><span class="delimiter">(</span><a href="#82001" title="Int">newPos</a>, <a href="#81994" title="(idx: Int)scales.utils.package.ItemOrTree[Item,Section,CC]">c</a><span class="delimiter">(</span><a href="#82001" title="Int">newPos</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l349"></a><span id="l349">      <span class="delimiter">}</span></span>
<a href="l350"></a><span id="l350">    <span class="delimiter">}</span></span>
<a href="l351"></a><span id="l351">										   </span>
<a href="l352"></a><span id="l352">  <span class="comment">/**</span>
<a href="l353"></a><span id="l353">   * zipUp returns this if it is already the top item (doesn't have a parent to zip), and a</span>
<a href="l354"></a><span id="l354">   * newly zipped node when not if the focus has been modified</span>
<a href="l355"></a><span id="l355">   */</span></span>
<a href="l356"></a><span id="l356">  <span class="keyword">def</span> <a title="()scales.utils.Path[Item,Section,CC]" id="38058">zipUp</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#84069" title="scales.utils.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> =</span>
<a href="l357"></a><span id="l357">    <span title="scales.utils.Path[Item,Section,CC]" class="keyword">if</span> <span class="delimiter">(</span><a href="#67569" title="=&gt; scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]]">top</a>.<a href="EitherLike.scala.html#38076" title="=&gt; Boolean">isLeft</a><span class="delimiter">)</span> <a href="#84069" title="scales.utils.Path[Item,Section,CC]" class="keyword">this</a></span>
<a href="l358"></a><span id="l358">    <span class="keyword">else</span> <span class="delimiter">{</span></span>
<a href="l359"></a><span id="l359">      <span class="keyword">val</span> <a title="scales.utils.Path[Item,Section,CC]" id="82066">path</a> = <a href="#67569" title="=&gt; scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]]">top</a>.<a href="EitherLike.scala.html#38083" title="=&gt; scales.utils.RightLikeProjection[scales.utils.Path[Item,Section,CC]]">right</a>.<a href="EitherLike.scala.html#38063" title="=&gt; scales.utils.Path[Item,Section,CC]">get</a></span>
<a href="l360"></a><span id="l360">      <span class="keyword">val</span> <a title="scales.utils.Tree[Item,Section,CC]" id="82067">pt</a> = <a href="#38042" title="=&gt; scales.utils.Tree[Item,Section,CC]">parentTree</a></span>
<a href="l361"></a><span id="l361"></span>
<a href="l362"></a><span id="l362">      <span title="scales.utils.Path[Item,Section,CC]" class="keyword">if</span> <span class="delimiter">(</span><a href="#82067" title="scales.utils.Tree[Item,Section,CC]">pt</a>.<a href="Trees.scala.html#67676" title="(idx: Int)scales.utils.package.ItemOrTree[Item,Section,CC]">children</a><span class="delimiter">(</span><a href="#67570" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67617" title="=&gt; Int">index</a><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#67570" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67618" title="=&gt; scales.utils.package.ItemOrTree[Item,Section,CC]">focus</a><span class="delimiter">)</span> <a href="#82066" title="scales.utils.Path[Item,Section,CC]">path</a></span>
<a href="l363"></a><span id="l363">      <span class="keyword">else</span> <span class="delimiter">{</span></span>
<a href="l364"></a><span id="l364">        <span class="keyword">val</span> <a title="scales.utils.package.ItemOrTree[Item,Section,CC]" id="82073">parentFocus</a> = <span class="comment">// ZIP IT, must be a tree</span></span>
<a href="l365"></a><span id="l365">          <a href="package.scala.html#10626" title="(section: Section, children: CC[scales.utils.package.ItemOrTree[Item,Section,CC]])(implicit cbf: scales.utils.package.TreeCBF[Item,Section,CC])scales.utils.package.ItemOrTree[Item,Section,CC]">subtree</a><a href="#67571" title="scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]]" class="delimiter">(</a><a href="#82067" title="scales.utils.Tree[Item,Section,CC]">pt</a>.<a href="Trees.scala.html#67674" title="=&gt; Section">section</a>, <a href="#82067" title="scales.utils.Tree[Item,Section,CC]">pt</a>.<a href="Trees.scala.html#67676" title="=&gt; CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">children</a>.<span title="(index: Int, elem: scales.utils.package.ItemOrTree[Item,Section,CC])(implicit bf: scala.collection.generic.CanBuildFrom[CC[scales.utils.package.ItemOrTree[Item,Section,CC]],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]])CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">updated</span><a href="#67571" title="scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]]" class="delimiter">(</a><a href="#67570" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67617" title="=&gt; Int">index</a>, <a href="#67570" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67618" title="=&gt; scales.utils.package.ItemOrTree[Item,Section,CC]">focus</a><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l366"></a><span id="l366"></span>
<a href="l367"></a><span id="l367">        <a href="#84069" title="(top: scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]], node: scales.utils.Node[Item,Section,CC])(implicit cbf: scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]])scales.utils.Path[Item,Section,CC]">Path</a><a href="#67571" title="scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]]" class="delimiter">(</a><a href="#82066" title="scales.utils.Path[Item,Section,CC]">path</a>.<a href="#67569" title="=&gt; scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]]">top</a>, <a href="#84077" title="(index: Int, focus: scales.utils.package.ItemOrTree[Item,Section,CC])scales.utils.Node[Item,Section,CC]">Node</a><span class="delimiter">(</span><a href="#82066" title="scales.utils.Path[Item,Section,CC]">path</a>.<a href="#67570" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67617" title="=&gt; Int">index</a>,</span>
<a href="l368"></a><span id="l368">          <a href="#82073" title="scales.utils.package.ItemOrTree[Item,Section,CC]">parentFocus</a><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l369"></a><span id="l369">      <span class="delimiter">}</span></span>
<a href="l370"></a><span id="l370">    <span class="delimiter">}</span></span>
<a href="l371"></a><span id="l371"></span>
<a href="l372"></a><span id="l372">  <span class="comment">/**</span>
<a href="l373"></a><span id="l373">   * Replaces this paths focus returning the path for the returned node.</span>
<a href="l374"></a><span id="l374">   * @param</span>
<a href="l375"></a><span id="l375">   */</span></span>
<a href="l376"></a><span id="l376">  <span class="keyword">def</span> <a title="(newFocus: (scales.utils.package.ItemOrTree[Item,Section,CC]) =&gt; scales.utils.package.ItemOrTree[Item,Section,CC])scales.utils.Path[Item,Section,CC]" id="38059">modify</a><span class="delimiter">(</span><a title="(scales.utils.package.ItemOrTree[Item,Section,CC]) =&gt; scales.utils.package.ItemOrTree[Item,Section,CC]" id="67550">newFocus</a>: <span class="delimiter">(</span>ItemOrTree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; ItemOrTree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> =</span>
<a href="l377"></a><span id="l377">    <a href="#84069" title="(top: scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]], node: scales.utils.Node[Item,Section,CC])(implicit cbf: scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]])scales.utils.Path[Item,Section,CC]">Path</a><a href="#67571" title="scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]]" class="delimiter">(</a><a href="#67569" title="=&gt; scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]]">top</a>, <a href="#84077" title="(index: Int, focus: scales.utils.package.ItemOrTree[Item,Section,CC])scales.utils.Node[Item,Section,CC]">Node</a><span class="delimiter">(</span><a href="#67570" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67617" title="=&gt; Int">index</a>,</span>
<a href="l378"></a><span id="l378">      <a href="#67550" title="(v1: scales.utils.package.ItemOrTree[Item,Section,CC])scales.utils.package.ItemOrTree[Item,Section,CC]">newFocus</a><span class="delimiter">(</span><a href="#67570" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67618" title="=&gt; scales.utils.package.ItemOrTree[Item,Section,CC]">focus</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l379"></a><span id="l379"></span>
<a href="l380"></a><span id="l380">  <span class="comment">/**</span>
<a href="l381"></a><span id="l381">   * Removes this node, returning the parent path or None if its top</span>
<a href="l382"></a><span id="l382">   * @return</span>
<a href="l383"></a><span id="l383">   */</span></span>
<a href="l384"></a><span id="l384">  <span class="keyword">def</span> <a title="()Option[scales.utils.Path[Item,Section,CC]]" id="38060">removeAndUp</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Option[scales.utils.Path[Item,Section,CC]]">Option</span><span class="delimiter">[</span>Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span> =</span>
<a href="l385"></a><span id="l385">    <span title="Option[scales.utils.Path[Item,Section,CC]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#67569" title="=&gt; scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]]">top</a>.<a href="EitherLike.scala.html#38076" title="=&gt; Boolean">isLeft</a><span class="delimiter">)</span> <span title="object None">None</span></span>
<a href="l386"></a><span id="l386">    <span class="keyword">else</span> <span class="delimiter">{</span></span>
<a href="l387"></a><span id="l387">      <span class="keyword">val</span> <a title="scales.utils.Path[Item,Section,CC]" id="82201">path</a> = <a href="#67569" title="=&gt; scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]]">top</a>.<a href="EitherLike.scala.html#38083" title="=&gt; scales.utils.RightLikeProjection[scales.utils.Path[Item,Section,CC]]">right</a>.<a href="EitherLike.scala.html#38063" title="=&gt; scales.utils.Path[Item,Section,CC]">get</a></span>
<a href="l388"></a><span id="l388">      <span class="keyword">val</span> <a title="scales.utils.Tree[Item,Section,CC]" id="82202">tree</a> = <a href="#82201" title="scales.utils.Path[Item,Section,CC]">path</a>.<a href="#67570" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67618" title="=&gt; scales.utils.package.ItemOrTree[Item,Section,CC]">focus</a>.<a href="EitherLike.scala.html#38083" title="=&gt; scales.utils.RightLikeProjection[scales.utils.Tree[Item,Section,CC]]">right</a>.<a href="EitherLike.scala.html#38063" title="=&gt; scales.utils.Tree[Item,Section,CC]">get</a></span>
<a href="l389"></a><span id="l389"></span>
<a href="l390"></a><span id="l390">      <span class="keyword">val</span> <a title="(CC[scales.utils.package.ItemOrTree[Item,Section,CC]], CC[scales.utils.package.ItemOrTree[Item,Section,CC]])" id="82203">parts</a> = <a href="#38042" title="=&gt; scales.utils.Tree[Item,Section,CC]">parentTree</a>.<a href="Trees.scala.html#67676" title="=&gt; CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">children</a>.<span title="(n: Int)(CC[scales.utils.package.ItemOrTree[Item,Section,CC]], CC[scales.utils.package.ItemOrTree[Item,Section,CC]])">splitAt</span><span class="delimiter">(</span><a href="#67570" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67617" title="=&gt; Int">index</a><span class="delimiter">)</span></span>
<a href="l391"></a><span id="l391"></span>
<a href="l392"></a><span id="l392">      <span class="keyword">val</span> <a title="scales.utils.package.ItemOrTree[Item,Section,CC]" id="82204">parentFocus</a> = <span class="comment">// ZIP IT, must be a tree</span></span>
<a href="l393"></a><span id="l393">        <a href="package.scala.html#10626" title="(section: Section, children: CC[scales.utils.package.ItemOrTree[Item,Section,CC]])(implicit cbf: scales.utils.package.TreeCBF[Item,Section,CC])scales.utils.package.ItemOrTree[Item,Section,CC]">subtree</a><a href="#67571" title="scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]]" class="delimiter">(</a><a href="#82202" title="scales.utils.Tree[Item,Section,CC]">tree</a>.<a href="Trees.scala.html#67674" title="=&gt; Section">section</a>, <a href="#82203" title="(CC[scales.utils.package.ItemOrTree[Item,Section,CC]], CC[scales.utils.package.ItemOrTree[Item,Section,CC]])">parts</a>.<span title="=&gt; CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">_1</span> <a href="#67571" title="(that: scala.collection.GenTraversableOnce[scales.utils.package.ItemOrTree[Item,Section,CC]])(implicit bf: scala.collection.generic.CanBuildFrom[CC[scales.utils.package.ItemOrTree[Item,Section,CC]],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]])CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">++</a> <a href="#82203" title="(CC[scales.utils.package.ItemOrTree[Item,Section,CC]], CC[scales.utils.package.ItemOrTree[Item,Section,CC]])">parts</a>.<span title="=&gt; CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">_2</span>.<span title="=&gt; CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">tail</span><span class="delimiter">)</span></span>
<a href="l394"></a><span id="l394"></span>
<a href="l395"></a><span id="l395">      <span title="(x: scales.utils.Path[Item,Section,CC])Some[scales.utils.Path[Item,Section,CC]]">Some</span><span class="delimiter">(</span></span>
<a href="l396"></a><span id="l396">        <a href="#84069" title="(top: scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]], node: scales.utils.Node[Item,Section,CC])(implicit cbf: scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]])scales.utils.Path[Item,Section,CC]">Path</a><a href="#67571" title="scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]]" class="delimiter">(</a><a href="#82201" title="scales.utils.Path[Item,Section,CC]">path</a>.<a href="#67569" title="=&gt; scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]]">top</a>, <a href="#84077" title="(index: Int, focus: scales.utils.package.ItemOrTree[Item,Section,CC])scales.utils.Node[Item,Section,CC]">Node</a><span class="delimiter">(</span><a href="#82201" title="scales.utils.Path[Item,Section,CC]">path</a>.<a href="#67570" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67617" title="=&gt; Int">index</a>,</span>
<a href="l397"></a><span id="l397">          <a href="#82204" title="scales.utils.package.ItemOrTree[Item,Section,CC]">parentFocus</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l398"></a><span id="l398">    <span class="delimiter">}</span></span>
<a href="l399"></a><span id="l399"></span>
<a href="l400"></a><span id="l400">  <span class="comment">/**</span>
<a href="l401"></a><span id="l401">   * Gets the relative position of this Path</span>
<a href="l402"></a><span id="l402">   * DOES NOT perform a zip</span>
<a href="l403"></a><span id="l403">   */</span></span>
<a href="l404"></a><span id="l404">  <span class="keyword">def</span> <a title="()scales.utils.Position[Item,Section,CC]" id="38061">position</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#9077" title="scales.utils.Position[Item,Section,CC]">Position</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> = <span class="delimiter">{</span></span>
<a href="l405"></a><span id="l405">    @scala.annotation.tailrec</span>
<a href="l406"></a><span id="l406">    <span class="keyword">def</span> <a title="(path: scales.utils.Path[Item,Section,CC], stack: scala.collection.immutable.Stack[Int])(scala.collection.immutable.Stack[Int], scales.utils.Path[Item,Section,CC])" id="82321">makePosition</a><span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC]" id="82323">path</a>: <a href="#84069" title="scales.utils.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, <a title="scala.collection.immutable.Stack[Int]" id="82324">stack</a>: <span title="scala.collection.immutable.Stack[Int]">Stack</span><span class="delimiter">[</span>Int<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(scala.collection.immutable.Stack[Int], scales.utils.Path[Item,Section,CC])" class="delimiter">(</span>Stack<span class="delimiter">[</span>Int<span class="delimiter">]</span>, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span></span>
<a href="l407"></a><span id="l407">      <span class="keyword">val</span> <a title="scala.collection.immutable.Stack[Int]" id="82326">newStack</a> = <a href="#82324" title="scala.collection.immutable.Stack[Int]">stack</a>.<span title="(elem: Int)scala.collection.immutable.Stack[Int]">push</span><span class="delimiter">(</span><a href="#82323" title="scales.utils.Path[Item,Section,CC]">path</a>.<a href="#67570" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67617" title="=&gt; Int">index</a><span class="delimiter">)</span></span>
<a href="l408"></a><span id="l408">      <span title="(scala.collection.immutable.Stack[Int], scales.utils.Path[Item,Section,CC])" class="keyword">if</span> <span class="delimiter">(</span><a href="#82323" title="scales.utils.Path[Item,Section,CC]">path</a>.<a href="#67569" title="=&gt; scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]]">top</a>.<a href="EitherLike.scala.html#38076" title="=&gt; Boolean">isLeft</a><span class="delimiter">)</span></span>
<a href="l409"></a><span id="l409">        <span title="(_1: scala.collection.immutable.Stack[Int], _2: scales.utils.Path[Item,Section,CC])(scala.collection.immutable.Stack[Int], scales.utils.Path[Item,Section,CC])" class="delimiter">(</span><a href="#82326" title="scala.collection.immutable.Stack[Int]">newStack</a>, <a href="#82323" title="scales.utils.Path[Item,Section,CC]">path</a><span class="delimiter">)</span></span>
<a href="l410"></a><span id="l410">      <span class="keyword">else</span></span>
<a href="l411"></a><span id="l411">        <a href="#82321" title="(path: scales.utils.Path[Item,Section,CC], stack: scala.collection.immutable.Stack[Int])(scala.collection.immutable.Stack[Int], scales.utils.Path[Item,Section,CC])">makePosition</a><span class="delimiter">(</span><a href="#82323" title="scales.utils.Path[Item,Section,CC]">path</a>.<a href="#67569" title="=&gt; scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]]">top</a>.<a href="EitherLike.scala.html#38083" title="=&gt; scales.utils.RightLikeProjection[scales.utils.Path[Item,Section,CC]]">right</a>.<a href="EitherLike.scala.html#38063" title="=&gt; scales.utils.Path[Item,Section,CC]">get</a>, <a href="#82326" title="scala.collection.immutable.Stack[Int]">newStack</a><span class="delimiter">)</span></span>
<a href="l412"></a><span id="l412">    <span class="delimiter">}</span></span>
<a href="l413"></a><span id="l413"></span>
<a href="l414"></a><span id="l414">    <span class="keyword">val</span> <a title="(scala.collection.immutable.Stack[Int], scales.utils.Path[Item,Section,CC])" id="82322">res</a> = <a href="#82321" title="(path: scales.utils.Path[Item,Section,CC], stack: scala.collection.immutable.Stack[Int])(scala.collection.immutable.Stack[Int], scales.utils.Path[Item,Section,CC])">makePosition</a><span class="delimiter">(</span><a href="#84069" title="scales.utils.Path[Item,Section,CC]" class="keyword">this</a>, <span title="[A](elems: A*)scala.collection.immutable.Stack[A]">Stack</span><span title="(elems: Int*)scala.collection.immutable.Stack[Int]" class="delimiter">[</span><span title="Int">Int</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l415"></a><span id="l415">    <span title="scales.utils.PositionImpl[Item,Section,CC]" class="keyword">new</span> <a href="#84091" title="scales.utils.PositionImpl[Item,Section,CC]">PositionImpl</a><span class="delimiter">[</span>Item,Section,CC<span class="delimiter">]</span><span class="delimiter">(</span><a href="#82322" title="(scala.collection.immutable.Stack[Int], scales.utils.Path[Item,Section,CC])">res</a>.<span title="=&gt; scala.collection.immutable.Stack[Int]">_1</span>, <a href="#82322" title="(scala.collection.immutable.Stack[Int], scales.utils.Path[Item,Section,CC])">res</a>.<span title="=&gt; scales.utils.Path[Item,Section,CC]">_2</span><span class="delimiter">)</span></span>
<a href="l416"></a><span id="l416">  <span class="delimiter">}</span></span>
<a href="l417"></a><span id="l417"></span>
<a href="l418"></a><span id="l418">  <span class="comment">/**</span>
<a href="l419"></a><span id="l419">   * Gives a nicer representation then the standard (Paths(Paths(), Paths).  But still too much info</span>
<a href="l420"></a><span id="l420">   *</span>
<a href="l421"></a><span id="l421">   * Path( Section | Top, FocusSection | FocusItem)</span>
<a href="l422"></a><span id="l422">   *</span>
<a href="l423"></a><span id="l423">   * @return</span>
<a href="l424"></a><span id="l424">   */</span></span>
<a href="l425"></a><span id="l425">  <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="38062">toString</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="String">String</span> = <span class="delimiter">{</span></span>
<a href="l426"></a><span id="l426">    <span class="keyword">val</span> <a title="java.lang.StringBuilder" id="82360">builder</a> = <span title="java.lang.StringBuilder" class="keyword">new</span> java.lang.<span title="java.lang.StringBuilder">StringBuilder</span><span class="delimiter">(</span><span class="delimiter">)</span></span>
<a href="l427"></a><span id="l427"></span>
<a href="l428"></a><span id="l428">    <a href="#82360" title="java.lang.StringBuilder">builder</a>.<span title="(x$1: java.lang.String)java.lang.StringBuilder">append</span><span class="delimiter">(</span><span title="java.lang.String(&quot;Path(&quot;)" class="string">&quot;Path(&quot;</span><span class="delimiter">)</span>;</span>
<a href="l429"></a><span id="l429">    <span title="java.lang.StringBuilder" class="keyword">if</span> <span class="delimiter">(</span><a href="#67569" title="=&gt; scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]]">top</a>.<a href="EitherLike.scala.html#38076" title="=&gt; Boolean">isLeft</a><span class="delimiter">)</span></span>
<a href="l430"></a><span id="l430">      <a href="#82360" title="java.lang.StringBuilder">builder</a>.<span title="(x$1: java.lang.String)java.lang.StringBuilder">append</span><span class="delimiter">(</span><span title="java.lang.String(&quot;Top&quot;)" class="string">&quot;Top&quot;</span><span class="delimiter">)</span>;</span>
<a href="l431"></a><span id="l431">    <span class="keyword">else</span></span>
<a href="l432"></a><span id="l432">      <a href="#82360" title="java.lang.StringBuilder">builder</a>.<span title="(x$1: Any)java.lang.StringBuilder">append</span><span class="delimiter">(</span><a href="#67569" title="=&gt; scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]]">top</a>.<a href="EitherLike.scala.html#38083" title="=&gt; scales.utils.RightLikeProjection[scales.utils.Path[Item,Section,CC]]">right</a>.<a href="EitherLike.scala.html#38063" title="=&gt; scales.utils.Path[Item,Section,CC]">get</a>.<a href="#38051" title="()scales.utils.Tree[Item,Section,CC]">tree</a>.<a href="Trees.scala.html#67674" title="=&gt; Section">section</a><span class="delimiter">)</span>;</span>
<a href="l433"></a><span id="l433">    <a href="#82360" title="java.lang.StringBuilder">builder</a>.<span title="(x$1: java.lang.String)java.lang.StringBuilder">append</span><span class="delimiter">(</span><span title="java.lang.String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span>;</span>
<a href="l434"></a><span id="l434">    <span title="java.lang.StringBuilder" class="keyword">if</span> <span class="delimiter">(</span><a href="#38046" title="=&gt; Boolean">isItem</a><span class="delimiter">)</span></span>
<a href="l435"></a><span id="l435">      <a href="#82360" title="java.lang.StringBuilder">builder</a>.<span title="(x$1: Any)java.lang.StringBuilder">append</span><span class="delimiter">(</span><a href="#38052" title="()Item">item</a><span class="delimiter">)</span>;</span>
<a href="l436"></a><span id="l436">    <span class="keyword">else</span></span>
<a href="l437"></a><span id="l437">      <a href="#82360" title="java.lang.StringBuilder">builder</a>.<span title="(x$1: Any)java.lang.StringBuilder">append</span><span class="delimiter">(</span><a href="#38051" title="()scales.utils.Tree[Item,Section,CC]">tree</a>.<a href="Trees.scala.html#67674" title="=&gt; Section">section</a><span class="delimiter">)</span>;</span>
<a href="l438"></a><span id="l438">    <a href="#82360" title="java.lang.StringBuilder">builder</a>.<span title="(x$1: java.lang.String)java.lang.StringBuilder">append</span><span class="delimiter">(</span><span title="java.lang.String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span>;</span>
<a href="l439"></a><span id="l439"></span>
<a href="l440"></a><span id="l440">    <a href="#82360" title="java.lang.StringBuilder">builder</a>.<span title="()java.lang.String">toString</span></span>
<a href="l441"></a><span id="l441">  <span class="delimiter">}</span></span>
<a href="l442"></a><span id="l442"><span class="delimiter">}</span></span>
<a href="l443"></a><span id="l443"></span>
<a href="l444"></a><span id="l444"><span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait FoldOperation[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]] extends java.lang.Object with ScalaObject" id="9099">FoldOperation</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="9100">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="9101">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="9102">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="82513">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> <span title="ScalaObject" class="delimiter">{</span></span>
<a href="l445"></a><span id="l445"></span>
<a href="l446"></a><span id="l446">  <span class="keyword">def</span> <a title="(positions: Seq[scales.utils.Position[Item,Section,CC]])Seq[scales.utils.Position[Item,Section,CC]]" id="79510">adjust</a><span class="delimiter">(</span><a title="Seq[scales.utils.Position[Item,Section,CC]]" id="79696">positions</a>: <span title="Seq[scales.utils.Position[Item,Section,CC]]">Seq</span><span class="delimiter">[</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Seq[scales.utils.Position[Item,Section,CC]]">Seq</span><span class="delimiter">[</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span></span>
<a href="l447"></a><span id="l447"></span>
<a href="l448"></a><span id="l448">  <span class="keyword">def</span> <a title="(path: scales.utils.Path[Item,Section,CC])scales.utils.package.FoldR[Item,Section,CC]" id="79511">perform</a><span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC]" id="79692">path</a>: <a href="#84069" title="scales.utils.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scales.utils.package.FoldR[Item,Section,CC]">FoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span></span>
<a href="l449"></a><span id="l449"></span>
<a href="l450"></a><span id="l450">  <span class="keyword">def</span> <a title="(path: scales.utils.Path[Item,Section,CC], direction: Int, newPath: Iterable[scales.utils.package.ItemOrTree[Item,Section,CC]])(implicit cbf: scales.utils.package.TreeCBF[Item,Section,CC])scales.utils.package.FoldR[Item,Section,CC]" id="79512">add</a><span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC]" id="82516">path</a>: <a href="#84069" title="scales.utils.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, <a title="Int" id="82517">direction</a>: <span title="Int">Int</span>, <a title="Iterable[scales.utils.package.ItemOrTree[Item,Section,CC]]" id="82518">newPath</a>: <span title="Iterable[scales.utils.package.ItemOrTree[Item,Section,CC]]">Iterable</span><span class="delimiter">[</span>ItemOrTree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scales.utils.package.TreeCBF[Item,Section,CC]" id="82519">cbf</a> : <span title="scales.utils.package.TreeCBF[Item,Section,CC]">TreeCBF</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> : <span title="scales.utils.package.FoldR[Item,Section,CC]">FoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> = <span class="delimiter">{</span></span>
<a href="l451"></a><span id="l451">    <span class="comment">// need to go up to replace</span></span>
<a href="l452"></a><span id="l452">    <span class="keyword">val</span> <a title="scales.utils.Path[Item,Section,CC]" id="82521">parent</a> = <a href="#82516" title="scales.utils.Path[Item,Section,CC]">path</a>.<a href="#38058" title="()scales.utils.Path[Item,Section,CC]">zipUp</a></span>
<a href="l453"></a><span id="l453">    <span title="scales.utils.package.FoldR[Item,Section,CC]" class="keyword">if</span> <span class="delimiter">(</span><a href="#82516" title="scales.utils.Path[Item,Section,CC]">path</a>.<a href="#67569" title="=&gt; scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]]">top</a>.<a href="EitherLike.scala.html#38076" title="=&gt; Boolean">isLeft</a><span class="delimiter">)</span></span>
<a href="l454"></a><span id="l454">      <span title="(b: scales.utils.AddedBeforeOrAfterRoot.type)Right[Nothing,scales.utils.AddedBeforeOrAfterRoot.type]">Right</span><span class="delimiter">(</span><a href="#83989" title="object scales.utils.AddedBeforeOrAfterRoot">AddedBeforeOrAfterRoot</a><span class="delimiter">)</span></span>
<a href="l455"></a><span id="l455">    <span class="keyword">else</span></span>
<a href="l456"></a><span id="l456">      <span title="(a: scales.utils.Path[Item,Section,CC])Left[scales.utils.Path[Item,Section,CC],Nothing]">Left</span><span class="delimiter">(</span><a href="#82521" title="scales.utils.Path[Item,Section,CC]">parent</a>.</span>
<a href="l457"></a><span id="l457">        <a href="#38059" title="(newFocus: (scales.utils.package.ItemOrTree[Item,Section,CC]) =&gt; scales.utils.package.ItemOrTree[Item,Section,CC])scales.utils.Path[Item,Section,CC]">modify</a> <span class="delimiter">{</span> <a title="scales.utils.package.ItemOrTree[Item,Section,CC]" id="82540">x</a> =&gt;</span>
<a href="l458"></a><span id="l458">          <span class="keyword">val</span> <a title="scales.utils.Tree[Item,Section,CC]" id="82541">tree</a> = <a href="#82540" title="scales.utils.package.ItemOrTree[Item,Section,CC]">x</a>.<a href="EitherLike.scala.html#38083" title="=&gt; scales.utils.RightLikeProjection[scales.utils.Tree[Item,Section,CC]]">right</a>.<a href="EitherLike.scala.html#38063" title="=&gt; scales.utils.Tree[Item,Section,CC]">get</a>;</span>
<a href="l459"></a><span id="l459">          <span class="keyword">val</span> <a title="Int" id="82542">index</a> = <a href="#82516" title="scales.utils.Path[Item,Section,CC]">path</a>.<a href="#67570" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67617" title="=&gt; Int">index</a> <span title="(x: Int)Int">+</span> <a href="#82517" title="Int">direction</a></span>
<a href="l460"></a><span id="l460">          <span class="keyword">val</span> <a href="#82544" title="(CC[scales.utils.package.ItemOrTree[Item,Section,CC]], CC[scales.utils.package.ItemOrTree[Item,Section,CC]])" class="delimiter">(</a><a href="#82543" title="CC[scales.utils.package.ItemOrTree[Item,Section,CC]]" id="82544">pre</a>,<a href="#82543" title="CC[scales.utils.package.ItemOrTree[Item,Section,CC]]" id="82545">pos</a><span class="delimiter">)</span> = <a href="#82541" title="scales.utils.Tree[Item,Section,CC]">tree</a>.<a href="Trees.scala.html#67676" title="=&gt; CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">children</a>.<span title="(n: Int)(CC[scales.utils.package.ItemOrTree[Item,Section,CC]], CC[scales.utils.package.ItemOrTree[Item,Section,CC]])">splitAt</span><span title="(CC[scales.utils.package.ItemOrTree[Item,Section,CC]], CC[scales.utils.package.ItemOrTree[Item,Section,CC]]) @unchecked" class="delimiter">(</span><a href="#82542" title="Int">index</a><span class="delimiter">)</span></span>
<a href="l461"></a><span id="l461">          <span class="keyword">val</span> <a title="CC[scales.utils.package.ItemOrTree[Item,Section,CC]]" id="82546">newChildren</a> = <span class="delimiter">(</span><a href="#82544" title="CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">pre</a> <a href="#82519" title="(that: scala.collection.GenTraversableOnce[scales.utils.package.ItemOrTree[Item,Section,CC]])(implicit bf: scala.collection.generic.CanBuildFrom[CC[scales.utils.package.ItemOrTree[Item,Section,CC]],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]])CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">++</a> <a href="#82518" title="Iterable[scales.utils.package.ItemOrTree[Item,Section,CC]]">newPath</a><span class="delimiter">)</span> <a href="#82519" title="(that: scala.collection.GenTraversableOnce[scales.utils.package.ItemOrTree[Item,Section,CC]])(implicit bf: scala.collection.generic.CanBuildFrom[CC[scales.utils.package.ItemOrTree[Item,Section,CC]],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]])CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">++</a> <a href="#82545" title="CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">pos</a></span>
<a href="l462"></a><span id="l462">          <a href="Trees.scala.html#79610" title="(section: Section, children: CC[scales.utils.package.ItemOrTree[Item,Section,CC]])scales.utils.Tree[Item,Section,CC]">Tree</a><span class="delimiter">(</span><a href="#82541" title="scales.utils.Tree[Item,Section,CC]">tree</a>.<a href="Trees.scala.html#67674" title="=&gt; Section">section</a>, <a href="#82546" title="CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">newChildren</a><span class="delimiter">)</span><span class="comment">//Right()</span></span>
<a href="l463"></a><span id="l463">        <span class="delimiter">}</span><span class="delimiter">)</span></span>
<a href="l464"></a><span id="l464"></span>
<a href="l465"></a><span id="l465">  <span class="delimiter">}</span></span>
<a href="l466"></a><span id="l466"><span class="delimiter">}</span></span>
<a href="l467"></a><span id="l467"></span>
<a href="l468"></a><span id="l468">case <span class="keyword">class</span> <a title="class Remove[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]] extends java.lang.Object with scales.utils.FoldOperation[Item,Section,CC] with ScalaObject with Product with Serializable" id="84056">Remove</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="82836">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="82837">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="82838">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="84050">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><a href="#84056" title="ScalaObject" class="delimiter">(</a><span class="keyword">implicit</span> <a title="scales.utils.package.TreeCBF[Item,Section,CC]" id="84049">cbf</a> : <span title="scales.utils.package.TreeCBF[Item,Section,CC]">TreeCBF</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#9099" title="scales.utils.FoldOperation[Item,Section,CC]">FoldOperation</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> <span class="delimiter">{</span></span>
<a href="l469"></a><span id="l469">  <span class="keyword">def</span> <a title="(positions: Seq[scales.utils.Position[Item,Section,CC]])Seq[scales.utils.Position[Item,Section,CC]]" id="82671">adjust</a><span class="delimiter">(</span><a title="Seq[scales.utils.Position[Item,Section,CC]]" id="82685">positions</a>: <span title="Seq[scales.utils.Position[Item,Section,CC]]">Seq</span><span class="delimiter">[</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Seq[scales.utils.Position[Item,Section,CC]]">Seq</span><span class="delimiter">[</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#10797" title="(positions: Seq[scales.utils.Position[Item,Section,CC]])Seq[scales.utils.Position[Item,Section,CC]]">cleanBelow</a><span class="delimiter">(</span><a href="#82685" title="Seq[scales.utils.Position[Item,Section,CC]]">positions</a><span class="delimiter">)</span>.<span title="(f: (scales.utils.Position[Item,Section,CC]) =&gt; scales.utils.Position[Item,Section,CC])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[scales.utils.Position[Item,Section,CC]],scales.utils.Position[Item,Section,CC],Seq[scales.utils.Position[Item,Section,CC]]])Seq[scales.utils.Position[Item,Section,CC]]">map</span> <span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,scales.utils.Position[Item,Section,CC],Seq[scales.utils.Position[Item,Section,CC]]]" class="delimiter">{</span> <a href="#10790" title="(base: scales.utils.Position[Item,Section,CC], x: scales.utils.Position[Item,Section,CC], by: Int)scales.utils.Position[Item,Section,CC]">shiftWithBase</a><span class="delimiter">(</span><a href="#82685" title="Seq[scales.utils.Position[Item,Section,CC]]">positions</a>.<span title="=&gt; scales.utils.Position[Item,Section,CC]">head</span>, <a href="#82743" title="scales.utils.Position[Item,Section,CC]">_</a>, -<span title="Int(-1)" class="int">1</span><span class="delimiter">)</span> <span class="delimiter">}</span></span>
<a href="l470"></a><span id="l470"></span>
<a href="l471"></a><span id="l471">  <span class="keyword">def</span> <a title="(path: scales.utils.Path[Item,Section,CC])scales.utils.package.FoldR[Item,Section,CC]" id="82672">perform</a><span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC]" id="82783">path</a>: <a href="#84069" title="scales.utils.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scales.utils.package.FoldR[Item,Section,CC]">FoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> = <span class="delimiter">{</span></span>
<a href="l472"></a><span id="l472">    <span class="keyword">val</span> <a title="Option[scales.utils.Path[Item,Section,CC]]" id="82786">ores</a> = <a href="#82783" title="scales.utils.Path[Item,Section,CC]">path</a>.<a href="#38060" title="()Option[scales.utils.Path[Item,Section,CC]]">removeAndUp</a><span class="delimiter">(</span><span class="delimiter">)</span>;</span>
<a href="l473"></a><span id="l473">    <span title="scales.utils.package.FoldR[Item,Section,CC]" class="keyword">if</span> <span class="delimiter">(</span><a href="#82786" title="Option[scales.utils.Path[Item,Section,CC]]">ores</a>.<span title="=&gt; Boolean">isDefined</span><span class="delimiter">)</span> <span title="(a: scales.utils.Path[Item,Section,CC])Left[scales.utils.Path[Item,Section,CC],Nothing]">Left</span><span class="delimiter">(</span><a href="#82786" title="Option[scales.utils.Path[Item,Section,CC]]">ores</a>.<span title="=&gt; scales.utils.Path[Item,Section,CC]">get</span><span class="delimiter">)</span></span>
<a href="l474"></a><span id="l474">    <span class="keyword">else</span> <span title="(b: scales.utils.RemovedRoot.type)Right[Nothing,scales.utils.RemovedRoot.type]">Right</span><span class="delimiter">(</span><a href="#83974" title="object scales.utils.RemovedRoot">RemovedRoot</a><span class="delimiter">)</span></span>
<a href="l475"></a><span id="l475">  <span class="delimiter">}</span></span>
<a href="l476"></a><span id="l476"><span class="delimiter">}</span></span>
<a href="l477"></a><span id="l477"></span>
<a href="l478"></a><span id="l478">case <span class="keyword">class</span> <a title="class AddBefore[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]] extends java.lang.Object with scales.utils.FoldOperation[Item,Section,CC] with ScalaObject with Product with Serializable" id="84044">AddBefore</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="83043">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="83044">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="83045">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="84036">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><a href="#84044" title="ScalaObject" class="delimiter">(</a><a title="scales.utils.package.ItemOrTree[Item,Section,CC]" id="84034">newPath</a>: <a href="EitherLike.scala.html#8884" title="scales.utils.package.ItemOrTree[Item,Section,CC]">ItemOrTree</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scales.utils.package.TreeCBF[Item,Section,CC]" id="84035">cbf</a> : <span title="scales.utils.package.TreeCBF[Item,Section,CC]">TreeCBF</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#9099" title="scales.utils.FoldOperation[Item,Section,CC]">FoldOperation</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> <span class="delimiter">{</span></span>
<a href="l479"></a><span id="l479">  <span class="keyword">def</span> <a title="(positions: Seq[scales.utils.Position[Item,Section,CC]])Seq[scales.utils.Position[Item,Section,CC]]" id="82882">adjust</a><span class="delimiter">(</span><a title="Seq[scales.utils.Position[Item,Section,CC]]" id="82898">positions</a>: <span title="Seq[scales.utils.Position[Item,Section,CC]]">Seq</span><span class="delimiter">[</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Seq[scales.utils.Position[Item,Section,CC]]">Seq</span><span class="delimiter">[</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#82898" title="Seq[scales.utils.Position[Item,Section,CC]]">positions</a>.<span title="=&gt; Seq[scales.utils.Position[Item,Section,CC]]">tail</span>.<span title="(f: (scales.utils.Position[Item,Section,CC]) =&gt; scales.utils.Position[Item,Section,CC])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[scales.utils.Position[Item,Section,CC]],scales.utils.Position[Item,Section,CC],Seq[scales.utils.Position[Item,Section,CC]]])Seq[scales.utils.Position[Item,Section,CC]]">map</span> <span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,scales.utils.Position[Item,Section,CC],Seq[scales.utils.Position[Item,Section,CC]]]" class="delimiter">{</span> <a href="#10790" title="(base: scales.utils.Position[Item,Section,CC], x: scales.utils.Position[Item,Section,CC], by: Int)scales.utils.Position[Item,Section,CC]">shiftWithBase</a><span class="delimiter">(</span><a href="#82898" title="Seq[scales.utils.Position[Item,Section,CC]]">positions</a>.<span title="=&gt; scales.utils.Position[Item,Section,CC]">head</span>, <a href="#82937" title="scales.utils.Position[Item,Section,CC]">_</a>, <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span class="delimiter">}</span></span>
<a href="l480"></a><span id="l480"></span>
<a href="l481"></a><span id="l481">  <span class="keyword">def</span> <a title="(path: scales.utils.Path[Item,Section,CC])scales.utils.package.FoldR[Item,Section,CC]" id="82883">perform</a><span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC]" id="82977">path</a>: <a href="#84069" title="scales.utils.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scales.utils.package.FoldR[Item,Section,CC]">FoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> = <a href="#79512" title="(path: scales.utils.Path[Item,Section,CC], direction: Int, newPath: Iterable[scales.utils.package.ItemOrTree[Item,Section,CC]])(implicit cbf: scales.utils.package.TreeCBF[Item,Section,CC])scales.utils.package.FoldR[Item,Section,CC]">add</a><a href="#84035" title="scales.utils.package.TreeCBF[Item,Section,CC]" class="delimiter">(</a><a href="#82977" title="scales.utils.Path[Item,Section,CC]">path</a>, <span title="Int(0)" class="int">0</span>, <span title="(xs: scales.utils.package.ItemOrTree[Item,Section,CC]*)List[scales.utils.package.ItemOrTree[Item,Section,CC]]">List</span><span class="delimiter">(</span><a href="#84034" title="=&gt; scales.utils.package.ItemOrTree[Item,Section,CC]">newPath</a><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l482"></a><span id="l482"><span class="delimiter">}</span></span>
<a href="l483"></a><span id="l483"></span>
<a href="l484"></a><span id="l484">case <span class="keyword">class</span> <a title="class AddAfter[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]] extends java.lang.Object with scales.utils.FoldOperation[Item,Section,CC] with ScalaObject with Product with Serializable" id="84029">AddAfter</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="83262">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="83263">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="83264">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="84021">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><a href="#84029" title="ScalaObject" class="delimiter">(</a><a title="scales.utils.package.ItemOrTree[Item,Section,CC]" id="84019">newPath</a>: <a href="EitherLike.scala.html#8884" title="scales.utils.package.ItemOrTree[Item,Section,CC]">ItemOrTree</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scales.utils.package.TreeCBF[Item,Section,CC]" id="84020">cbf</a> : <span title="scales.utils.package.TreeCBF[Item,Section,CC]">TreeCBF</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#9099" title="scales.utils.FoldOperation[Item,Section,CC]">FoldOperation</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> <span class="delimiter">{</span></span>
<a href="l485"></a><span id="l485">  <span class="keyword">def</span> <a title="(positions: Seq[scales.utils.Position[Item,Section,CC]])Seq[scales.utils.Position[Item,Section,CC]]" id="83101">adjust</a><span class="delimiter">(</span><a title="Seq[scales.utils.Position[Item,Section,CC]]" id="83117">positions</a>: <span title="Seq[scales.utils.Position[Item,Section,CC]]">Seq</span><span class="delimiter">[</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Seq[scales.utils.Position[Item,Section,CC]]">Seq</span><span class="delimiter">[</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#83117" title="Seq[scales.utils.Position[Item,Section,CC]]">positions</a>.<span title="=&gt; Seq[scales.utils.Position[Item,Section,CC]]">tail</span>.<span title="(f: (scales.utils.Position[Item,Section,CC]) =&gt; scales.utils.Position[Item,Section,CC])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[scales.utils.Position[Item,Section,CC]],scales.utils.Position[Item,Section,CC],Seq[scales.utils.Position[Item,Section,CC]]])Seq[scales.utils.Position[Item,Section,CC]]">map</span> <span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,scales.utils.Position[Item,Section,CC],Seq[scales.utils.Position[Item,Section,CC]]]" class="delimiter">{</span> <a href="#10790" title="(base: scales.utils.Position[Item,Section,CC], x: scales.utils.Position[Item,Section,CC], by: Int)scales.utils.Position[Item,Section,CC]">shiftWithBase</a><span class="delimiter">(</span><a href="#83117" title="Seq[scales.utils.Position[Item,Section,CC]]">positions</a>.<span title="=&gt; scales.utils.Position[Item,Section,CC]">head</span>, <a href="#83156" title="scales.utils.Position[Item,Section,CC]">_</a>, <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span class="delimiter">}</span></span>
<a href="l486"></a><span id="l486"></span>
<a href="l487"></a><span id="l487">  <span class="keyword">def</span> <a title="(path: scales.utils.Path[Item,Section,CC])scales.utils.package.FoldR[Item,Section,CC]" id="83102">perform</a><span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC]" id="83196">path</a>: <a href="#84069" title="scales.utils.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scales.utils.package.FoldR[Item,Section,CC]">FoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> = <a href="#79512" title="(path: scales.utils.Path[Item,Section,CC], direction: Int, newPath: Iterable[scales.utils.package.ItemOrTree[Item,Section,CC]])(implicit cbf: scales.utils.package.TreeCBF[Item,Section,CC])scales.utils.package.FoldR[Item,Section,CC]">add</a><a href="#84020" title="scales.utils.package.TreeCBF[Item,Section,CC]" class="delimiter">(</a><a href="#83196" title="scales.utils.Path[Item,Section,CC]">path</a>, <span title="Int(1)" class="int">1</span>, <span title="(xs: scales.utils.package.ItemOrTree[Item,Section,CC]*)List[scales.utils.package.ItemOrTree[Item,Section,CC]]">List</span><span class="delimiter">(</span><a href="#84019" title="=&gt; scales.utils.package.ItemOrTree[Item,Section,CC]">newPath</a><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l488"></a><span id="l488"><span class="delimiter">}</span></span>
<a href="l489"></a><span id="l489"></span>
<a href="l490"></a><span id="l490"><span class="comment">/**</span>
<a href="l491"></a><span id="l491"> * Use to make it easier to filter out large sets (for those that aren't interesting simply asis them, see tests for use case)</span>
<a href="l492"></a><span id="l492"> */</span></span>
<a href="l493"></a><span id="l493">case <span class="keyword">class</span> <a title="class AsIs[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]] extends java.lang.Object with scales.utils.FoldOperation[Item,Section,CC] with ScalaObject with Product with Serializable" id="84014">AsIs</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="83351">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="83352">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="83353">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="84011">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><a href="#84014" title="ScalaObject" class="delimiter">(</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#9099" title="scales.utils.FoldOperation[Item,Section,CC]">FoldOperation</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> <span class="delimiter">{</span></span>
<a href="l494"></a><span id="l494">  <span class="comment">/**</span>
<a href="l495"></a><span id="l495">   * No OP, just move one one</span>
<a href="l496"></a><span id="l496">   */</span></span>
<a href="l497"></a><span id="l497">  <span class="keyword">def</span> <a title="(positions: Seq[scales.utils.Position[Item,Section,CC]])Seq[scales.utils.Position[Item,Section,CC]]" id="83315">adjust</a><span class="delimiter">(</span><a title="Seq[scales.utils.Position[Item,Section,CC]]" id="83320">positions</a>: <span title="Seq[scales.utils.Position[Item,Section,CC]]">Seq</span><span class="delimiter">[</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Seq[scales.utils.Position[Item,Section,CC]]">Seq</span><span class="delimiter">[</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#83320" title="Seq[scales.utils.Position[Item,Section,CC]]">positions</a>.<span title="=&gt; Seq[scales.utils.Position[Item,Section,CC]]">tail</span></span>
<a href="l498"></a><span id="l498"></span>
<a href="l499"></a><span id="l499">  <span class="keyword">def</span> <a title="(path: scales.utils.Path[Item,Section,CC])scales.utils.package.FoldR[Item,Section,CC]" id="83316">perform</a><span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC]" id="83323">path</a>: <a href="#84069" title="scales.utils.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scales.utils.package.FoldR[Item,Section,CC]">FoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> = <span title="(a: scales.utils.Path[Item,Section,CC])Left[scales.utils.Path[Item,Section,CC],Nothing]">Left</span><span class="delimiter">(</span><a href="#83323" title="scales.utils.Path[Item,Section,CC]">path</a><span class="delimiter">)</span></span>
<a href="l500"></a><span id="l500"><span class="delimiter">}</span></span>
<a href="l501"></a><span id="l501"></span>
<a href="l502"></a><span id="l502"><span class="keyword">object</span> <a title="object scales.utils.Replace" id="83473">Replace</a> <span title="ScalaObject" class="delimiter">{</span></span>
<a href="l503"></a><span id="l503">  <span class="comment">/**</span>
<a href="l504"></a><span id="l504">   * Simpler interface</span>
<a href="l505"></a><span id="l505">   */</span></span>
<a href="l506"></a><span id="l506">  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](replaceWith: scales.utils.package.ItemOrTree[Item,Section,CC]*)(implicit cbf: scales.utils.package.TreeCBF[Item,Section,CC])scales.utils.Replace[Item,Section,CC]" id="83381">apply</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="83385">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="83386">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="83387">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="83425">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="scales.utils.package.ItemOrTree[Item,Section,CC]*" id="83421">replaceWith</a>: <span title="scales.utils.package.ItemOrTree[Item,Section,CC]*">ItemOrTree</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>*<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scales.utils.package.TreeCBF[Item,Section,CC]" id="83422">cbf</a> : <span title="scales.utils.package.TreeCBF[Item,Section,CC]">TreeCBF</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#83422" title="scales.utils.Replace[Item,Section,CC]" class="keyword">new</a> <a href="#83657" title="scales.utils.Replace[Item,Section,CC]">Replace</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">(</span><a href="#83421" title="scales.utils.package.ItemOrTree[Item,Section,CC]*">replaceWith</a><span class="delimiter">)</span></span>
<a href="l507"></a><span id="l507"></span>
<a href="l508"></a><span id="l508"><span class="delimiter">}</span></span>
<a href="l509"></a><span id="l509"></span>
<a href="l510"></a><span id="l510"><span class="comment">/**</span>
<a href="l511"></a><span id="l511"> * Allows replacing one path with many, may be easier to use the * version however</span>
<a href="l512"></a><span id="l512"> */</span></span>
<a href="l513"></a><span id="l513">case <span class="keyword">class</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](x$0: scales.utils.Replace[Item,Section,CC])Option[Iterable[scales.utils.package.ItemOrTree[Item,Section,CC]]]" id="83657">Replace</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="83606">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="83607">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="83608">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="83630">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><a href="#83657" title="ScalaObject" class="delimiter">(</a><a title="Iterable[scales.utils.package.ItemOrTree[Item,Section,CC]]" id="83602">replaceWith</a>: <span title="Iterable[scales.utils.package.ItemOrTree[Item,Section,CC]]">Iterable</span><span class="delimiter">[</span>ItemOrTree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scales.utils.package.TreeCBF[Item,Section,CC]" id="83609">cbf</a> : <span title="scales.utils.package.TreeCBF[Item,Section,CC]">TreeCBF</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#9099" title="scales.utils.FoldOperation[Item,Section,CC]">FoldOperation</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> <span class="delimiter">{</span></span>
<a href="l514"></a><span id="l514"></span>
<a href="l515"></a><span id="l515">  <span class="comment">/**</span>
<a href="l516"></a><span id="l516">   * clean below for any that are invalidated by the replace then replaceWiths size minus the 1 that we have removed/replaced</span>
<a href="l517"></a><span id="l517">   */</span></span>
<a href="l518"></a><span id="l518">  <span class="keyword">def</span> <a title="(positions: Seq[scales.utils.Position[Item,Section,CC]])Seq[scales.utils.Position[Item,Section,CC]]" id="83401">adjust</a><span class="delimiter">(</span><a title="Seq[scales.utils.Position[Item,Section,CC]]" id="83479">positions</a>: <span title="Seq[scales.utils.Position[Item,Section,CC]]">Seq</span><span class="delimiter">[</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Seq[scales.utils.Position[Item,Section,CC]]">Seq</span><span class="delimiter">[</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#10797" title="(positions: Seq[scales.utils.Position[Item,Section,CC]])Seq[scales.utils.Position[Item,Section,CC]]">cleanBelow</a><span class="delimiter">(</span><a href="#83479" title="Seq[scales.utils.Position[Item,Section,CC]]">positions</a><span class="delimiter">)</span>.<span title="(f: (scales.utils.Position[Item,Section,CC]) =&gt; scales.utils.Position[Item,Section,CC])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[scales.utils.Position[Item,Section,CC]],scales.utils.Position[Item,Section,CC],Seq[scales.utils.Position[Item,Section,CC]]])Seq[scales.utils.Position[Item,Section,CC]]">map</span> <span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,scales.utils.Position[Item,Section,CC],Seq[scales.utils.Position[Item,Section,CC]]]" class="delimiter">{</span> <a href="#10790" title="(base: scales.utils.Position[Item,Section,CC], x: scales.utils.Position[Item,Section,CC], by: Int)scales.utils.Position[Item,Section,CC]">shiftWithBase</a><span class="delimiter">(</span><a href="#83479" title="Seq[scales.utils.Position[Item,Section,CC]]">positions</a>.<span title="=&gt; scales.utils.Position[Item,Section,CC]">head</span>, <a href="#83537" title="scales.utils.Position[Item,Section,CC]">_</a>, <a href="#83602" title="=&gt; Iterable[scales.utils.package.ItemOrTree[Item,Section,CC]]">replaceWith</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span class="delimiter">}</span></span>
<a href="l519"></a><span id="l519"></span>
<a href="l520"></a><span id="l520">  <span class="keyword">def</span> <a title="(path: scales.utils.Path[Item,Section,CC])scales.utils.package.FoldR[Item,Section,CC]" id="83402">perform</a><span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC]" id="83582">path</a>: <a href="#84069" title="scales.utils.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scales.utils.package.FoldR[Item,Section,CC]">FoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> = <span class="delimiter">{</span></span>
<a href="l521"></a><span id="l521">    <span class="comment">// modify with tail</span></span>
<a href="l522"></a><span id="l522">    <span class="keyword">val</span> <a title="scales.utils.Path[Item,Section,CC]" id="83585">tpath</a> = <a href="#83582" title="scales.utils.Path[Item,Section,CC]">path</a>.<a href="#38059" title="(newFocus: (scales.utils.package.ItemOrTree[Item,Section,CC]) =&gt; scales.utils.package.ItemOrTree[Item,Section,CC])scales.utils.Path[Item,Section,CC]">modify</a><span class="delimiter">(</span><a title="scales.utils.package.ItemOrTree[Item,Section,CC]" id="83588">_</a> =&gt; <a href="#83602" title="=&gt; Iterable[scales.utils.package.ItemOrTree[Item,Section,CC]]">replaceWith</a>.<span title="=&gt; scales.utils.package.ItemOrTree[Item,Section,CC]">head</span><span class="delimiter">)</span></span>
<a href="l523"></a><span id="l523">    <a href="#79512" title="(path: scales.utils.Path[Item,Section,CC], direction: Int, newPath: Iterable[scales.utils.package.ItemOrTree[Item,Section,CC]])(implicit cbf: scales.utils.package.TreeCBF[Item,Section,CC])scales.utils.package.FoldR[Item,Section,CC]">add</a><a href="#83609" title="scales.utils.package.TreeCBF[Item,Section,CC]" class="delimiter">(</a><a href="#83585" title="scales.utils.Path[Item,Section,CC]">tpath</a>, <span title="Int(1)" class="int">1</span>, <a href="#83602" title="=&gt; Iterable[scales.utils.package.ItemOrTree[Item,Section,CC]]">replaceWith</a>.<span title="=&gt; Iterable[scales.utils.package.ItemOrTree[Item,Section,CC]]">tail</span><span class="delimiter">)</span></span>
<a href="l524"></a><span id="l524">  <span class="delimiter">}</span></span>
<a href="l525"></a><span id="l525"><span class="delimiter">}</span></span>
<a href="l526"></a><span id="l526"></span>
<a href="l527"></a><span id="l527"><span class="comment">/**</span>
<a href="l528"></a><span id="l528"> * Allows foldPositions to be nested, only replace makes sense here (afaict)</span>
<a href="l529"></a><span id="l529"> */</span></span>
<a href="l530"></a><span id="l530">case <span class="keyword">class</span> <a title="class ReplaceWith[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]] extends java.lang.Object with scales.utils.FoldOperation[Item,Section,CC] with ScalaObject with Product with Serializable" id="84006">ReplaceWith</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="83877">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="83878">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="83879">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="83998">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><a href="#84006" title="ScalaObject" class="delimiter">(</a><a title="(scales.utils.Path[Item,Section,CC]) =&gt; scales.utils.package.FoldR[Item,Section,CC]" id="83996">f</a>: <span title="(scales.utils.Path[Item,Section,CC]) =&gt; scales.utils.package.FoldR[Item,Section,CC]">PathFoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scales.utils.package.TreeCBF[Item,Section,CC]" id="83997">cbf</a> : <span title="scales.utils.package.TreeCBF[Item,Section,CC]">TreeCBF</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#9099" title="scales.utils.FoldOperation[Item,Section,CC]">FoldOperation</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> <span class="delimiter">{</span></span>
<a href="l531"></a><span id="l531"></span>
<a href="l532"></a><span id="l532">  <span class="keyword">def</span> <a title="(positions: Seq[scales.utils.Position[Item,Section,CC]])Seq[scales.utils.Position[Item,Section,CC]]" id="83666">adjust</a><span class="delimiter">(</span><a title="Seq[scales.utils.Position[Item,Section,CC]]" id="83682">positions</a>: <span title="Seq[scales.utils.Position[Item,Section,CC]]">Seq</span><span class="delimiter">[</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Seq[scales.utils.Position[Item,Section,CC]]">Seq</span><span class="delimiter">[</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#10797" title="(positions: Seq[scales.utils.Position[Item,Section,CC]])Seq[scales.utils.Position[Item,Section,CC]]">cleanBelow</a><span class="delimiter">(</span><a href="#83682" title="Seq[scales.utils.Position[Item,Section,CC]]">positions</a><span class="delimiter">)</span>.<span title="(f: (scales.utils.Position[Item,Section,CC]) =&gt; scales.utils.Position[Item,Section,CC])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[scales.utils.Position[Item,Section,CC]],scales.utils.Position[Item,Section,CC],Seq[scales.utils.Position[Item,Section,CC]]])Seq[scales.utils.Position[Item,Section,CC]]">map</span> <span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,scales.utils.Position[Item,Section,CC],Seq[scales.utils.Position[Item,Section,CC]]]" class="delimiter">{</span> <a href="#10790" title="(base: scales.utils.Position[Item,Section,CC], x: scales.utils.Position[Item,Section,CC], by: Int)scales.utils.Position[Item,Section,CC]">shiftWithBase</a><span class="delimiter">(</span><a href="#83682" title="Seq[scales.utils.Position[Item,Section,CC]]">positions</a>.<span title="=&gt; scales.utils.Position[Item,Section,CC]">head</span>, <a href="#83740" title="scales.utils.Position[Item,Section,CC]">_</a>, <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span class="delimiter">}</span></span>
<a href="l533"></a><span id="l533"></span>
<a href="l534"></a><span id="l534">  <span class="keyword">def</span> <a title="(path: scales.utils.Path[Item,Section,CC])scales.utils.package.FoldR[Item,Section,CC]" id="83667">perform</a><span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC]" id="83780">path</a>: <a href="#84069" title="scales.utils.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scales.utils.package.FoldR[Item,Section,CC]">FoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> =</span>
<a href="l535"></a><span id="l535">    <span class="comment">// modify back in (allows changes), or pass on the error</span></span>
<a href="l536"></a><span id="l536">    <a href="#83996" title="(v1: scales.utils.Path[Item,Section,CC])scales.utils.package.FoldR[Item,Section,CC]">f</a><span class="delimiter">(</span><a href="#83780" title="scales.utils.Path[Item,Section,CC]">path</a><span class="delimiter">)</span>.<span title="(fa: (scales.utils.Path[Item,Section,CC]) =&gt; Product with Serializable with Either[scales.utils.Path[Item,Section,CC],scales.utils.FoldError], fb: (scales.utils.FoldError) =&gt; Product with Serializable with Either[scales.utils.Path[Item,Section,CC],scales.utils.FoldError])Product with Serializable with Either[scales.utils.Path[Item,Section,CC],scales.utils.FoldError]">fold</span><span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC]" id="83791">fres</a> =&gt; <span title="(a: scales.utils.Path[Item,Section,CC])Left[scales.utils.Path[Item,Section,CC],Nothing]">Left</span><span class="delimiter">(</span><a href="#83780" title="scales.utils.Path[Item,Section,CC]">path</a>.<a href="#38059" title="(newFocus: (scales.utils.package.ItemOrTree[Item,Section,CC]) =&gt; scales.utils.package.ItemOrTree[Item,Section,CC])scales.utils.Path[Item,Section,CC]">modify</a><span class="delimiter">(</span><a title="scales.utils.package.ItemOrTree[Item,Section,CC]" id="83803">_</a> =&gt; <a href="#83791" title="scales.utils.Path[Item,Section,CC]">fres</a>.<a href="#38051" title="()scales.utils.Tree[Item,Section,CC]">tree</a><span class="delimiter">)</span><span class="delimiter">)</span>,<span class="comment">//Right(fres.tree))),</span></span>
<a href="l537"></a><span id="l537">      <span title="(b: scales.utils.FoldError)Right[Nothing,scales.utils.FoldError]">Right</span><span class="delimiter">(</span><a href="#83809" title="scales.utils.FoldError">_</a><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l538"></a><span id="l538"></span>
<a href="l539"></a><span id="l539"><span class="delimiter">}</span></span>
<a href="l540"></a><span id="l540"></span>
<a href="l541"></a><span id="l541"><span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait FoldError extends java.lang.Object" id="9139">FoldError</a></span>
<a href="l542"></a><span id="l542"></span>
<a href="l543"></a><span id="l543">case <span class="keyword">object</span> <a href="#83936" title="object scales.utils.NoPaths" id="83944">NoPaths</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#9139" title="scales.utils.FoldError">FoldError</a></span>
<a href="l544"></a><span id="l544">case <span class="keyword">object</span> <a href="#83951" title="object scales.utils.NoSingleRoot" id="83959">NoSingleRoot</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#9139" title="scales.utils.FoldError">FoldError</a></span>
<a href="l545"></a><span id="l545">case <span class="keyword">object</span> <a href="#83966" title="object scales.utils.RemovedRoot" id="83974">RemovedRoot</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#9139" title="scales.utils.FoldError">FoldError</a></span>
<a href="l546"></a><span id="l546">case <span class="keyword">object</span> <a href="#83981" title="object scales.utils.AddedBeforeOrAfterRoot" id="83989">AddedBeforeOrAfterRoot</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#9139" title="scales.utils.FoldError">FoldError</a></span>
<a href="l547"></a><span id="l547"></span>
<a href="l548"></a><span id="l548">        </span>
</pre>
    </body>
</html>