<table class="classes"><tbody><tr>
      <td class="barContainerLeft"><a href="#">&#x200B;scales/&#x200B;utils/<span class="header">&#x200B;ImmutableArray.scala</span></a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">67 %</div>
        <div class="greenBar" style="width:134px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_ImmutableArray.scala.html#Class_scales_utils_IAOne"><img src="class.png"></img>IAOne</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_ImmutableArray.scala.html#Class_scales_utils_IAThree"><img src="class.png"></img>IAThree</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">85 %</div>
        <div class="greenBar" style="width:170px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_ImmutableArray.scala.html#Class_scales_utils_IATwo"><img src="class.png"></img>IATwo</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_ImmutableArray.scala.html#Class_scales_utils_ImmutableArray"><img src="class.png"></img>ImmutableArray</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_ImmutableArray.scala.html#Class_scales_utils_ImmutableArrayAll"><img src="class.png"></img>ImmutableArrayAll</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_ImmutableArray.scala.html#Class_scales_utils_ImmutableArrayBuilder"><img src="class.png"></img>ImmutableArrayBuilder</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">92 %</div>
        <div class="greenBar" style="width:184px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_ImmutableArray.scala.html#Class_scales_utils_ImmutableArrayProxy"><img src="class.png"></img>ImmutableArrayProxy</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_ImmutableArray.scala.html#Object_scales_utils_ImmutableArrayProxy"><img src="object.png"></img>ImmutableArrayProxy</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_ImmutableArray.scala.html#Trait_scales_utils_ImmutableArrayProxy"><img src="trait.png"></img>ImmutableArrayProxy</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">50 %</div>
        <div class="greenBar" style="width:100px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_ImmutableArray.scala.html#Trait_scales_utils_ImmutableArrayProxy_ImmutableArrayProxyCBF"><img src="trait.png"></img>ImmutableArrayProxy.ImmutableArrayProxyCBF</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">50 %</div>
        <div class="greenBar" style="width:100px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_ImmutableArray.scala.html#Class_scales_utils_ImmutableArrayProxyBuilder"><img src="class.png"></img>ImmutableArrayProxyBuilder</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">73 %</div>
        <div class="greenBar" style="width:146px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_ImmutableArray.scala.html#Object_scales_utils_ImmutableArrayProxyBuilder"><img src="object.png"></img>ImmutableArrayProxyBuilder</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_ImmutableArray.scala.html#Trait_scales_utils_ImmutableArrayT"><img src="trait.png"></img>ImmutableArrayT</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">52 %</div>
        <div class="greenBar" style="width:104px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_ImmutableArray.scala.html#Class_scales_utils_VectorImpl"><img src="class.png"></img>VectorImpl</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">45 %</div>
        <div class="greenBar" style="width:90px;">&nbsp;</div>
      </div>
    </div></td>
    </tr></tbody></table><table class="source"><tbody><tr>
            <td class="black">1</td>
            <td>package scales.utils
</td>
          </tr><tr>
            <td class="black">2</td>
            <td>
</td>
          </tr><tr>
            <td class="black">3</td>
            <td>import collection.{IndexedSeqOptimized, IndexedSeqLike, IndexedSeq}
</td>
          </tr><tr>
            <td class="black">4</td>
            <td>import collection.mutable.Builder //{ArrayBuilder, Builder}
</td>
          </tr><tr>
            <td class="black">5</td>
            <td>import collection.generic.{CanBuildFrom, GenericTraversableTemplate, SeqFactory, GenericCompanion}
</td>
          </tr><tr>
            <td class="black">6</td>
            <td>
</td>
          </tr><tr>
            <td class="black">7</td>
            <td>//import scales.collection.immutable.Vector
</td>
          </tr><tr>
            <td class="black">8</td>
            <td>
</td>
          </tr><tr>
            <td class="black">9</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">10</td>
            <td> * Behaves like an ArrayList/ArrayBuffer, growing an internal array as necessary
</td>
          </tr><tr>
            <td class="black">11</td>
            <td> */
</td>
          </tr><tr>
            <td class="green">12</td>
            <td><a id="Object_scales_utils_ImmutableArrayProxyBuilder"></a><a id="Class_scales_utils_ImmutableArrayBuilder"></a><a id="Class_scales_utils_ImmutableArrayProxyBuilder"></a>case class ImmutableArrayBuilder[ A ]() extends Builder[A, ImmutableArray[A]]{
</td>
          </tr><tr>
            <td class="black">13</td>
            <td>
</td>
          </tr><tr>
            <td class="red">14</td>
            <td>  final val gf = <span class="non">0.10
</span></td>
          </tr><tr>
            <td class="red">15</td>
            <td>  final val gp = <span class="non">0.95
</span></td>
          </tr><tr>
            <td class="black">16</td>
            <td>
</td>
          </tr><tr>
            <td class="black">17</td>
            <td>  def resize( orig : Array[AnyRef], newCapacity : Int, len : Int ) = { 
</td>
          </tr><tr>
            <td class="green">18</td>
            <td>    val ar = Array.ofDim[AnyRef](newCapacity)
</td>
          </tr><tr>
            <td class="green">19</td>
            <td>    if (len != 0)
</td>
          </tr><tr>
            <td class="green">20</td>
            <td>      Array.copy(orig, 0, ar, 0, len)
</td>
          </tr><tr>
            <td class="black">21</td>
            <td>
</td>
          </tr><tr>
            <td class="green">22</td>
            <td>    ar
</td>
          </tr><tr>
            <td class="black">23</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">24</td>
            <td>
</td>
          </tr><tr>
            <td class="black">25</td>
            <td>  var buf : Array[AnyRef] = _
</td>
          </tr><tr>
            <td class="black">26</td>
            <td>  
</td>
          </tr><tr>
            <td class="green">27</td>
            <td>  var len = 0
</td>
          </tr><tr>
            <td class="black">28</td>
            <td>
</td>
          </tr><tr>
            <td class="black">29</td>
            <td>  protected def ensureSize( size : Int ) {
</td>
          </tr><tr>
            <td class="green">30</td>
            <td>    if ((buf eq null) || (size &gt; buf.length))
</td>
          </tr><tr>
            <td class="green">31</td>
            <td>      buf = resize( buf, size, len )
</td>
          </tr><tr>
            <td class="green">32</td>
            <td>    else if (size &gt; (buf.length * gp).toInt) {
</td>
          </tr><tr>
            <td class="green">33</td>
            <td>      buf = resize( buf, buf.length + (buf.length.toDouble * gf).toInt, len )
</td>
          </tr><tr>
            <td class="black">34</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">35</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">36</td>
            <td>
</td>
          </tr><tr>
            <td class="black">37</td>
            <td>  override def sizeHint( size : Int ) {
</td>
          </tr><tr>
            <td class="green">38</td>
            <td>    if ((buf eq null) || size &gt; buf.length) // don't grow unless necessary
</td>
          </tr><tr>
            <td class="green">39</td>
            <td>      buf = resize( buf, size, len )
</td>
          </tr><tr>
            <td class="black">40</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">41</td>
            <td>
</td>
          </tr><tr>
            <td class="black">42</td>
            <td>  def result : ImmutableArray[A] = 
</td>
          </tr><tr>
            <td class="green">43</td>
            <td>    if (len == 0)
</td>
          </tr><tr>
            <td class="green">44</td>
            <td>      ImmutableArrayProxy.emptyImmutableArray.asInstanceOf[ImmutableArray[A]]
</td>
          </tr><tr>
            <td class="black">45</td>
            <td>    else
</td>
          </tr><tr>
            <td class="green">46</td>
            <td>      ImmutableArray(buf, 0, len)
</td>
          </tr><tr>
            <td class="black">47</td>
            <td>
</td>
          </tr><tr>
            <td class="green">48</td>
            <td>  override def ++=(xs: TraversableOnce[A]): this.type = xs match {
</td>
          </tr><tr>
            <td class="black">49</td>
            <td>    case ImmutableArray( base, offset, slen) =&gt;
</td>
          </tr><tr>
            <td class="green">50</td>
            <td>      ensureSize(len + slen)
</td>
          </tr><tr>
            <td class="green">51</td>
            <td>      Array.copy(base, offset, buf, len, slen)
</td>
          </tr><tr>
            <td class="green">52</td>
            <td>      len += slen
</td>
          </tr><tr>
            <td class="green">53</td>
            <td>      this
</td>
          </tr><tr>
            <td class="black">54</td>
            <td>    case _ =&gt;
</td>
          </tr><tr>
            <td class="green">55</td>
            <td>      super.++=(xs)
</td>
          </tr><tr>
            <td class="black">56</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">57</td>
            <td>
</td>
          </tr><tr>
            <td class="black">58</td>
            <td>  def +=( elem : A) : this.type = {
</td>
          </tr><tr>
            <td class="green">59</td>
            <td>    ensureSize(len + 1)
</td>
          </tr><tr>
            <td class="black">60</td>
            <td>    // we know its big enough
</td>
          </tr><tr>
            <td class="green">61</td>
            <td>    buf(len) = elem.asInstanceOf[AnyRef]
</td>
          </tr><tr>
            <td class="green">62</td>
            <td>    len += 1
</td>
          </tr><tr>
            <td class="green">63</td>
            <td>    this
</td>
          </tr><tr>
            <td class="black">64</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">65</td>
            <td>
</td>
          </tr><tr>
            <td class="black">66</td>
            <td>  def clear() {
</td>
          </tr><tr>
            <td class="green">67</td>
            <td>    len = 0
</td>
          </tr><tr>
            <td class="black">68</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">69</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">70</td>
            <td>
</td>
          </tr><tr>
            <td class="green">71</td>
            <td><a id="Class_scales_utils_IAOne"></a>case class IAOne[ +A ]( one : A ) extends ImmutableArrayProxy[A] {
</td>
          </tr><tr>
            <td class="black">72</td>
            <td>
</td>
          </tr><tr>
            <td class="green">73</td>
            <td>  def apply(idx : Int) = one
</td>
          </tr><tr>
            <td class="black">74</td>
            <td>
</td>
          </tr><tr>
            <td class="green">75</td>
            <td>  def length = 1
</td>
          </tr><tr>
            <td class="black">76</td>
            <td>
</td>
          </tr><tr>
            <td class="green">77</td>
            <td>  def ar = this
</td>
          </tr><tr>
            <td class="black">78</td>
            <td>
</td>
          </tr><tr>
            <td class="black">79</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">80</td>
            <td>
</td>
          </tr><tr>
            <td class="black">81</td>
            <td>import scala.annotation.switch
</td>
          </tr><tr>
            <td class="black">82</td>
            <td>
</td>
          </tr><tr>
            <td class="red">83</td>
            <td><a id="Class_scales_utils_IATwo"></a>case class IATwo[ +A ]<span class="non">( one : A, two : A ) extends ImmutableArrayProxy[A] {
</span></td>
          </tr><tr>
            <td class="black">84</td>
            <td>
</td>
          </tr><tr>
            <td class="red">85</td>
            <td>  def apply(idx : Int) = (<span class="non">idx : @switch) match {
</span></td>
          </tr><tr>
            <td class="red">86</td>
            <td>    case 0 =&gt; <span class="non">one
</span></td>
          </tr><tr>
            <td class="red">87</td>
            <td>    case 1 =&gt; <span class="non">two
</span></td>
          </tr><tr>
            <td class="black">88</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">89</td>
            <td>
</td>
          </tr><tr>
            <td class="red">90</td>
            <td>  def length = <span class="non">2
</span></td>
          </tr><tr>
            <td class="black">91</td>
            <td>
</td>
          </tr><tr>
            <td class="red">92</td>
            <td>  def ar = <span class="non">this
</span></td>
          </tr><tr>
            <td class="black">93</td>
            <td>
</td>
          </tr><tr>
            <td class="black">94</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">95</td>
            <td>
</td>
          </tr><tr>
            <td class="green">96</td>
            <td><a id="Class_scales_utils_IAThree"></a>case class IAThree[ +A ]( one : A, two : A, three : A ) extends ImmutableArrayProxy[A] {
</td>
          </tr><tr>
            <td class="black">97</td>
            <td>
</td>
          </tr><tr>
            <td class="green">98</td>
            <td>  def apply(idx : Int) = (idx : @switch) match {
</td>
          </tr><tr>
            <td class="green">99</td>
            <td>    case 0 =&gt; one
</td>
          </tr><tr>
            <td class="green">100</td>
            <td>    case 1 =&gt; two
</td>
          </tr><tr>
            <td class="green">101</td>
            <td>    case 2 =&gt; three
</td>
          </tr><tr>
            <td class="black">102</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">103</td>
            <td>
</td>
          </tr><tr>
            <td class="green">104</td>
            <td>  def length = 3
</td>
          </tr><tr>
            <td class="black">105</td>
            <td>
</td>
          </tr><tr>
            <td class="red">106</td>
            <td>  def ar = <span class="non">this
</span></td>
          </tr><tr>
            <td class="black">107</td>
            <td>
</td>
          </tr><tr>
            <td class="black">108</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">109</td>
            <td>
</td>
          </tr><tr>
            <td class="black">110</td>
            <td>
</td>
          </tr><tr>
            <td class="black">111</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">112</td>
            <td> * Object arrays are just faster, System.arraycopy doesn't trust you and will type check everything, we can let nsc do that job for us.
</td>
          </tr><tr>
            <td class="black">113</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">114</td>
            <td> * Same as ImmutableArray but for when the base is the entire collection, no offset or len are then needed
</td>
          </tr><tr>
            <td class="black">115</td>
            <td> */ 
</td>
          </tr><tr>
            <td class="black">116</td>
            <td><a id="Trait_scales_utils_ImmutableArrayT"></a>trait ImmutableArrayT[ +A ] extends ImmutableArrayProxy[A] {
</td>
          </tr><tr>
            <td class="black">117</td>
            <td>  val base : Array[AnyRef]
</td>
          </tr><tr>
            <td class="black">118</td>
            <td>  def offset : Int
</td>
          </tr><tr>
            <td class="black">119</td>
            <td>  def len : Int
</td>
          </tr><tr>
            <td class="black">120</td>
            <td>
</td>
          </tr><tr>
            <td class="black">121</td>
            <td>  import ImmutableArrayProxyBuilder._
</td>
          </tr><tr>
            <td class="black">122</td>
            <td>
</td>
          </tr><tr>
            <td class="green">123</td>
            <td>  def apply(idx : Int ) = base(idx + offset).asInstanceOf[A]
</td>
          </tr><tr>
            <td class="black">124</td>
            <td> 
</td>
          </tr><tr>
            <td class="green">125</td>
            <td>  def length = len
</td>
          </tr><tr>
            <td class="black">126</td>
            <td>  
</td>
          </tr><tr>
            <td class="black">127</td>
            <td>  @inline override def +:[B &gt;: A, That](elem: B)(implicit bf: CanBuildFrom[ImmutableArrayProxy[A], B, That]): That =
</td>
          </tr><tr>
            <td class="red">128</td>
            <td>    (<span class="non">if (len == vectorAfter) super.+:(elem)
</span></td>
          </tr><tr>
            <td class="black">129</td>
            <td>    else {
</td>
          </tr><tr>
            <td class="red">130</td>
            <td>      val ar = <span class="non">Array.ofDim[AnyRef](len+1)
</span></td>
          </tr><tr>
            <td class="red">131</td>
            <td>      <span class="non">Array.copy(base, offset, ar, 1, len)
</span></td>
          </tr><tr>
            <td class="red">132</td>
            <td>      <span class="non">ar(0) = elem.asInstanceOf[AnyRef]
</span></td>
          </tr><tr>
            <td class="red">133</td>
            <td>      ImmutableArrayAll<span class="non">[B](ar)
</span></td>
          </tr><tr>
            <td class="black">134</td>
            <td>    }).asInstanceOf[That]
</td>
          </tr><tr>
            <td class="black">135</td>
            <td>  
</td>
          </tr><tr>
            <td class="black">136</td>
            <td>  @inline override def :+[B &gt;: A, That](elem: B)(implicit bf: CanBuildFrom[ImmutableArrayProxy[A], B, That]): That =
</td>
          </tr><tr>
            <td class="green">137</td>
            <td>    (if (len == vectorAfter) super.:+(elem)
</td>
          </tr><tr>
            <td class="black">138</td>
            <td>    else {
</td>
          </tr><tr>
            <td class="green">139</td>
            <td>      val ar = Array.ofDim[AnyRef](len+1)
</td>
          </tr><tr>
            <td class="green">140</td>
            <td>      Array.copy(base, offset, ar, 0, len)
</td>
          </tr><tr>
            <td class="green">141</td>
            <td>      ar(len) = elem.asInstanceOf[AnyRef]
</td>
          </tr><tr>
            <td class="green">142</td>
            <td>      ImmutableArrayAll[B](ar)
</td>
          </tr><tr>
            <td class="black">143</td>
            <td>    }).asInstanceOf[That]
</td>
          </tr><tr>
            <td class="black">144</td>
            <td>
</td>
          </tr><tr>
            <td class="black">145</td>
            <td>  @inline override def take( n : Int ) = 
</td>
          </tr><tr>
            <td class="yellow">146</td>
            <td>    ImmutableArray(base, offset, if (len - n &lt; 0) <span class="non">len else </span>n)
</td>
          </tr><tr>
            <td class="black">147</td>
            <td>
</td>
          </tr><tr>
            <td class="black">148</td>
            <td>  @inline override def drop( n : Int ) = 
</td>
          </tr><tr>
            <td class="yellow">149</td>
            <td>    ImmutableArray(base, offset + n, if (len - n &lt; 0) <span class="non">0 else (</span>len - n))
</td>
          </tr><tr>
            <td class="black">150</td>
            <td>
</td>
          </tr><tr>
            <td class="green">151</td>
            <td>  @inline override def tail = drop(1)
</td>
          </tr><tr>
            <td class="black">152</td>
            <td>
</td>
          </tr><tr>
            <td class="black">153</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">154</td>
            <td>   * we can do better - slice used by many functions in Optimized
</td>
          </tr><tr>
            <td class="black">155</td>
            <td>   */ 
</td>
          </tr><tr>
            <td class="black">156</td>
            <td>  @inline override def slice(from: Int, until: Int) = {
</td>
          </tr><tr>
            <td class="green">157</td>
            <td>    val lo    = math.max(from, 0)
</td>
          </tr><tr>
            <td class="green">158</td>
            <td>    val hi    = math.min(until, len)
</td>
          </tr><tr>
            <td class="green">159</td>
            <td>    val elems = math.max(hi - lo, 0)
</td>
          </tr><tr>
            <td class="green">160</td>
            <td>    ImmutableArray(base, offset, elems)
</td>
          </tr><tr>
            <td class="black">161</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">162</td>
            <td>
</td>
          </tr><tr>
            <td class="black">163</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">164</td>
            <td>   * Basically optimised version for back, hint used directly, one new array creation
</td>
          </tr><tr>
            <td class="black">165</td>
            <td>   */ 
</td>
          </tr><tr>
            <td class="black">166</td>
            <td>  override def updated[B &gt;: A, That](index: Int, elem: B)(implicit bf: CanBuildFrom[ImmutableArrayProxy[A], B, That]): That =
</td>
          </tr><tr>
            <td class="green">167</td>
            <td>    if (bf.isInstanceOf[ImmutableArrayProxy.ImmutableArrayProxyCBF[_]]) {
</td>
          </tr><tr>
            <td class="black">168</td>
            <td>      // we know its objects underneath, we know the relationship is sound
</td>
          </tr><tr>
            <td class="green">169</td>
            <td>      val ar = Array.ofDim[AnyRef](len)
</td>
          </tr><tr>
            <td class="green">170</td>
            <td>      Array.copy(base, offset, ar, 0, len)
</td>
          </tr><tr>
            <td class="green">171</td>
            <td>      ar(index) = elem.asInstanceOf[AnyRef]
</td>
          </tr><tr>
            <td class="green">172</td>
            <td>      ImmutableArrayAll[B](ar).asInstanceOf[That]
</td>
          </tr><tr>
            <td class="black">173</td>
            <td>    } else {
</td>
          </tr><tr>
            <td class="red">174</td>
            <td>      val b = <span class="non">bf(repr)
</span></td>
          </tr><tr>
            <td class="red">175</td>
            <td>      val (<span class="non">prefix, rest) = this.splitAt(index)
</span></td>
          </tr><tr>
            <td class="red">176</td>
            <td>      <span class="non">b.sizeHint(len)
</span></td>
          </tr><tr>
            <td class="red">177</td>
            <td>      <span class="non">b ++= toCollection(prefix)
</span></td>
          </tr><tr>
            <td class="red">178</td>
            <td>      <span class="non">b += elem
</span></td>
          </tr><tr>
            <td class="red">179</td>
            <td>      <span class="non">b ++= toCollection(rest.tail)
</span></td>
          </tr><tr>
            <td class="red">180</td>
            <td>      <span class="non">b.result()
</span></td>
          </tr><tr>
            <td class="black">181</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">182</td>
            <td>
</td>
          </tr><tr>
            <td class="black">183</td>
            <td>  override def toArray[U &gt;: A : ClassManifest]: Array[U] =
</td>
          </tr><tr>
            <td class="red">184</td>
            <td>    if (<span class="non">implicitly[ClassManifest[U]].erasure eq base.getClass.getComponentType) {
</span></td>
          </tr><tr>
            <td class="red">185</td>
            <td>      if ((<span class="non">offset == 0) &amp;&amp; (len == base.length))
</span></td>
          </tr><tr>
            <td class="red">186</td>
            <td>  <span class="non">base.asInstanceOf[Array[U]]
</span></td>
          </tr><tr>
            <td class="black">187</td>
            <td>      else {
</td>
          </tr><tr>
            <td class="red">188</td>
            <td>  val ar = <span class="non">Array.ofDim[U](len)
</span></td>
          </tr><tr>
            <td class="red">189</td>
            <td>  <span class="non">Array.copy(base, offset, ar, 0, len)
</span></td>
          </tr><tr>
            <td class="red">190</td>
            <td>  <span class="non">ar  
</span></td>
          </tr><tr>
            <td class="black">191</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">192</td>
            <td>    } else 
</td>
          </tr><tr>
            <td class="red">193</td>
            <td>      <span class="non">super.toArray[U]
</span></td>
          </tr><tr>
            <td class="black">194</td>
            <td>
</td>
          </tr><tr>
            <td class="black">195</td>
            <td>
</td>
          </tr><tr>
            <td class="green">196</td>
            <td>  def ar = this
</td>
          </tr><tr>
            <td class="black">197</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">198</td>
            <td>
</td>
          </tr><tr>
            <td class="black">199</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">200</td>
            <td> * Don't add the offset and length, for building a dom this save 8 per elem, only matters for large docs (can save 4mb from 54mb), but can't hurt small ones.
</td>
          </tr><tr>
            <td class="black">201</td>
            <td> */ 
</td>
          </tr><tr>
            <td class="green">202</td>
            <td><a id="Class_scales_utils_ImmutableArrayAll"></a>case class ImmutableArrayAll[ +A ]( base : Array[AnyRef]) extends ImmutableArrayT[A] {
</td>
          </tr><tr>
            <td class="green">203</td>
            <td>  @inline final def offset = 0
</td>
          </tr><tr>
            <td class="green">204</td>
            <td>  @inline final def len = base.length
</td>
          </tr><tr>
            <td class="green">205</td>
            <td>  @inline final override def length = base.length
</td>
          </tr><tr>
            <td class="black">206</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">207</td>
            <td>
</td>
          </tr><tr>
            <td class="black">208</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">209</td>
            <td> * Object arrays are just faster, System.arraycopy doesn't trust you and will type check everything, we can let nsc do that job for us.
</td>
          </tr><tr>
            <td class="black">210</td>
            <td> */ 
</td>
          </tr><tr>
            <td class="green">211</td>
            <td><a id="Class_scales_utils_ImmutableArray"></a>case class ImmutableArray[ +A ]( base : Array[AnyRef], offset : Int, len : Int) extends ImmutableArrayT[A] {
</td>
          </tr><tr>
            <td class="black">212</td>
            <td>
</td>
          </tr><tr>
            <td class="black">213</td>
            <td>/*  import ImmutableArrayProxyBuilder._
</td>
          </tr><tr>
            <td class="black">214</td>
            <td>
</td>
          </tr><tr>
            <td class="black">215</td>
            <td>  def apply(idx : Int ) = base(idx + offset).asInstanceOf[A]
</td>
          </tr><tr>
            <td class="black">216</td>
            <td> 
</td>
          </tr><tr>
            <td class="black">217</td>
            <td>  def length = len
</td>
          </tr><tr>
            <td class="black">218</td>
            <td>  
</td>
          </tr><tr>
            <td class="black">219</td>
            <td>  @inline override def +:[B &gt;: A, That](elem: B)(implicit bf: CanBuildFrom[ImmutableArrayProxy[A], B, That]): That =
</td>
          </tr><tr>
            <td class="black">220</td>
            <td>    (if (len == vectorAfter) super.+:(elem)
</td>
          </tr><tr>
            <td class="black">221</td>
            <td>    else {
</td>
          </tr><tr>
            <td class="black">222</td>
            <td>      val ar = Array.ofDim[AnyRef](len+1)
</td>
          </tr><tr>
            <td class="black">223</td>
            <td>      Array.copy(base, offset, ar, 1, len)
</td>
          </tr><tr>
            <td class="black">224</td>
            <td>      ar(0) = elem.asInstanceOf[AnyRef]
</td>
          </tr><tr>
            <td class="black">225</td>
            <td>      ImmutableArray[B](ar, 0, len+1)
</td>
          </tr><tr>
            <td class="black">226</td>
            <td>    }).asInstanceOf[That]
</td>
          </tr><tr>
            <td class="black">227</td>
            <td>  
</td>
          </tr><tr>
            <td class="black">228</td>
            <td>  @inline override def :+[B &gt;: A, That](elem: B)(implicit bf: CanBuildFrom[ImmutableArrayProxy[A], B, That]): That =
</td>
          </tr><tr>
            <td class="black">229</td>
            <td>    (if (len == vectorAfter) super.:+(elem)
</td>
          </tr><tr>
            <td class="black">230</td>
            <td>    else {
</td>
          </tr><tr>
            <td class="black">231</td>
            <td>      val ar = Array.ofDim[AnyRef](len+1)
</td>
          </tr><tr>
            <td class="black">232</td>
            <td>      Array.copy(base, offset, ar, 0, len)
</td>
          </tr><tr>
            <td class="black">233</td>
            <td>      ar(len) = elem.asInstanceOf[AnyRef]
</td>
          </tr><tr>
            <td class="black">234</td>
            <td>      ImmutableArray[B](ar, 0, len+1).asInstanceOf[That]
</td>
          </tr><tr>
            <td class="black">235</td>
            <td>    }).asInstanceOf[That]
</td>
          </tr><tr>
            <td class="black">236</td>
            <td>
</td>
          </tr><tr>
            <td class="black">237</td>
            <td>  @inline override def take( n : Int ) = 
</td>
          </tr><tr>
            <td class="black">238</td>
            <td>    ImmutableArray(base, offset, if (len - n &lt; 0) len else n)
</td>
          </tr><tr>
            <td class="black">239</td>
            <td>
</td>
          </tr><tr>
            <td class="black">240</td>
            <td>  @inline override def drop( n : Int ) = 
</td>
          </tr><tr>
            <td class="black">241</td>
            <td>    ImmutableArray(base, offset + n, if (len - n &lt; 0) 0 else (len - n))
</td>
          </tr><tr>
            <td class="black">242</td>
            <td>
</td>
          </tr><tr>
            <td class="black">243</td>
            <td>  @inline override def tail = drop(1)
</td>
          </tr><tr>
            <td class="black">244</td>
            <td>
</td>
          </tr><tr>
            <td class="black">245</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">246</td>
            <td>   * we can do better - slice used by many functions in Optimized
</td>
          </tr><tr>
            <td class="black">247</td>
            <td>   */ 
</td>
          </tr><tr>
            <td class="black">248</td>
            <td>  @inline override def slice(from: Int, until: Int) = {
</td>
          </tr><tr>
            <td class="black">249</td>
            <td>    val lo    = math.max(from, 0)
</td>
          </tr><tr>
            <td class="black">250</td>
            <td>    val hi    = math.min(until, len)
</td>
          </tr><tr>
            <td class="black">251</td>
            <td>    val elems = math.max(hi - lo, 0)
</td>
          </tr><tr>
            <td class="black">252</td>
            <td>    ImmutableArray(base, offset, elems)
</td>
          </tr><tr>
            <td class="black">253</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">254</td>
            <td>
</td>
          </tr><tr>
            <td class="black">255</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">256</td>
            <td>   * Basically optimised version for back, hint used directly, one new array creation
</td>
          </tr><tr>
            <td class="black">257</td>
            <td>   */ 
</td>
          </tr><tr>
            <td class="black">258</td>
            <td>  override def updated[B &gt;: A, That](index: Int, elem: B)(implicit bf: CanBuildFrom[ImmutableArrayProxy[A], B, That]): That =
</td>
          </tr><tr>
            <td class="black">259</td>
            <td>    if (bf.isInstanceOf[ImmutableArrayProxy.ImmutableArrayProxyCBF[_]]) {
</td>
          </tr><tr>
            <td class="black">260</td>
            <td>      // we know its objects underneath, we know the relationship is sound
</td>
          </tr><tr>
            <td class="black">261</td>
            <td>      val ar = Array.ofDim[AnyRef](len)
</td>
          </tr><tr>
            <td class="black">262</td>
            <td>      Array.copy(base, offset, ar, 0, len)
</td>
          </tr><tr>
            <td class="black">263</td>
            <td>      ar(index) = elem.asInstanceOf[AnyRef]
</td>
          </tr><tr>
            <td class="black">264</td>
            <td>      ImmutableArray[B](ar, 0, len).asInstanceOf[That]
</td>
          </tr><tr>
            <td class="black">265</td>
            <td>    } else {
</td>
          </tr><tr>
            <td class="black">266</td>
            <td>      val b = bf(repr)
</td>
          </tr><tr>
            <td class="black">267</td>
            <td>      val (prefix, rest) = this.splitAt(index)
</td>
          </tr><tr>
            <td class="black">268</td>
            <td>      b.sizeHint(len)
</td>
          </tr><tr>
            <td class="black">269</td>
            <td>      b ++= toCollection(prefix)
</td>
          </tr><tr>
            <td class="black">270</td>
            <td>      b += elem
</td>
          </tr><tr>
            <td class="black">271</td>
            <td>      b ++= toCollection(rest.tail)
</td>
          </tr><tr>
            <td class="black">272</td>
            <td>      b.result
</td>
          </tr><tr>
            <td class="black">273</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">274</td>
            <td>
</td>
          </tr><tr>
            <td class="black">275</td>
            <td>  override def toArray[U &gt;: A : ClassManifest]: Array[U] =
</td>
          </tr><tr>
            <td class="black">276</td>
            <td>    if (implicitly[ClassManifest[U]].erasure eq base.getClass.getComponentType) {
</td>
          </tr><tr>
            <td class="black">277</td>
            <td>      if ((offset == 0) &amp;&amp; (len == base.length))
</td>
          </tr><tr>
            <td class="black">278</td>
            <td>  base.asInstanceOf[Array[U]]
</td>
          </tr><tr>
            <td class="black">279</td>
            <td>      else {
</td>
          </tr><tr>
            <td class="black">280</td>
            <td>  val ar = Array.ofDim[U](len)
</td>
          </tr><tr>
            <td class="black">281</td>
            <td>  Array.copy(base, offset, ar, 0, len)
</td>
          </tr><tr>
            <td class="black">282</td>
            <td>  ar  
</td>
          </tr><tr>
            <td class="black">283</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">284</td>
            <td>    } else 
</td>
          </tr><tr>
            <td class="black">285</td>
            <td>      super.toArray[U]
</td>
          </tr><tr>
            <td class="black">286</td>
            <td>
</td>
          </tr><tr>
            <td class="black">287</td>
            <td>
</td>
          </tr><tr>
            <td class="black">288</td>
            <td>  def ar = this */
</td>
          </tr><tr>
            <td class="black">289</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">290</td>
            <td>
</td>
          </tr><tr>
            <td class="black">291</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">292</td>
            <td> * Starts an ImmutableArrayProxy and provides the CanBuildFrom
</td>
          </tr><tr>
            <td class="black">293</td>
            <td> */ 
</td>
          </tr><tr>
            <td class="black">294</td>
            <td><a id="Object_scales_utils_ImmutableArrayProxy"></a>object ImmutableArrayProxy extends SeqFactory[ImmutableArrayProxy] {
</td>
          </tr><tr>
            <td class="green">295</td>
            <td>  val emptyImmutableArray = new ImmutableArray[Nothing](Array[AnyRef](),0,0)
</td>
          </tr><tr>
            <td class="black">296</td>
            <td>
</td>
          </tr><tr>
            <td class="green">297</td>
            <td>  @inline override def empty[ A ] : ImmutableArrayProxy[A]  = emptyImmutableArray.asInstanceOf[ImmutableArrayProxy[A]]
</td>
          </tr><tr>
            <td class="black">298</td>
            <td>
</td>
          </tr><tr>
            <td class="black">299</td>
            <td>  @inline def newBuilder[A]
</td>
          </tr><tr>
            <td class="black">300</td>
            <td>  : Builder[A, ImmutableArrayProxy[A]] =
</td>
          </tr><tr>
            <td class="green">301</td>
            <td>    ImmutableArrayProxyBuilder()
</td>
          </tr><tr>
            <td class="black">302</td>
            <td>  
</td>
          </tr><tr>
            <td class="green">303</td>
            <td><a id="Class_scales_utils_ImmutableArrayProxy"></a>  @inline implicit def canBuildFrom[T](implicit ma: ClassManifest[T]): CanBuildFrom[ImmutableArrayProxy[_], T, ImmutableArrayProxy[T]] = new ImmutableArrayProxyCBF[T]{ val m = ma }
</td>
          </tr><tr>
            <td class="black">304</td>
            <td>
</td>
          </tr><tr>
            <td class="black">305</td>
            <td><a id="Trait_scales_utils_ImmutableArrayProxy_ImmutableArrayProxyCBF"></a>  trait ImmutableArrayProxyCBF[T] extends CanBuildFrom[ImmutableArrayProxy[_], T, ImmutableArrayProxy[T]] {
</td>
          </tr><tr>
            <td class="black">306</td>
            <td>    
</td>
          </tr><tr>
            <td class="black">307</td>
            <td>    val m : ClassManifest[T]
</td>
          </tr><tr>
            <td class="black">308</td>
            <td>
</td>
          </tr><tr>
            <td class="green">309</td>
            <td>    def apply(from: ImmutableArrayProxy[_]): Builder[T, ImmutableArrayProxy[T]] = newBuilder
</td>
          </tr><tr>
            <td class="red">310</td>
            <td>    def apply: Builder[T, ImmutableArrayProxy[T]] = <span class="non">newBuilder
</span></td>
          </tr><tr>
            <td class="black">311</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">312</td>
            <td>    
</td>
          </tr><tr>
            <td class="black">313</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">314</td>
            <td>
</td>
          </tr><tr>
            <td class="black">315</td>
            <td>object ImmutableArrayProxyBuilder {
</td>
          </tr><tr>
            <td class="red">316</td>
            <td>  final val vectorAfter = <span class="non">31
</span></td>
          </tr><tr>
            <td class="black">317</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">318</td>
            <td>
</td>
          </tr><tr>
            <td class="black">319</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">320</td>
            <td> * An attempt to be a little more efficient with ImmutableArray, should make up for update not working?
</td>
          </tr><tr>
            <td class="black">321</td>
            <td> */
</td>
          </tr><tr>
            <td class="green">322</td>
            <td>case class ImmutableArrayProxyBuilder[ A ]() extends Builder[A, ImmutableArrayProxy[A]]{
</td>
          </tr><tr>
            <td class="black">323</td>
            <td>  import ImmutableArrayProxyBuilder._
</td>
          </tr><tr>
            <td class="black">324</td>
            <td>
</td>
          </tr><tr>
            <td class="green">325</td>
            <td>  lazy val arrayBuilder = new ImmutableArrayBuilder[A]()
</td>
          </tr><tr>
            <td class="green">326</td>
            <td>  lazy val vectorBuilder = Vector.newBuilder[A]
</td>
          </tr><tr>
            <td class="black">327</td>
            <td>  
</td>
          </tr><tr>
            <td class="green">328</td>
            <td>  var inVector = false
</td>
          </tr><tr>
            <td class="green">329</td>
            <td>  var haveChosen = false
</td>
          </tr><tr>
            <td class="black">330</td>
            <td>
</td>
          </tr><tr>
            <td class="black">331</td>
            <td>  override def sizeHint( size : Int ) {
</td>
          </tr><tr>
            <td class="green">332</td>
            <td>    if (size &gt; vectorAfter) {
</td>
          </tr><tr>
            <td class="red">333</td>
            <td>      <span class="non">inVector = true
</span></td>
          </tr><tr>
            <td class="red">334</td>
            <td>      <span class="non">haveChosen = true
</span></td>
          </tr><tr>
            <td class="black">335</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">336</td>
            <td>
</td>
          </tr><tr>
            <td class="green">337</td>
            <td>    if (inVector) {
</td>
          </tr><tr>
            <td class="red">338</td>
            <td>      <span class="non">vectorBuilder.sizeHint(size)
</span></td>
          </tr><tr>
            <td class="black">339</td>
            <td>    } else {
</td>
          </tr><tr>
            <td class="green">340</td>
            <td>      arrayBuilder.sizeHint(size)
</td>
          </tr><tr>
            <td class="black">341</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">342</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">343</td>
            <td>
</td>
          </tr><tr>
            <td class="black">344</td>
            <td>  // for the case when we were under 32 but are now over
</td>
          </tr><tr>
            <td class="black">345</td>
            <td>  protected def checkVB() {
</td>
          </tr><tr>
            <td class="green">346</td>
            <td>    if (!inVector) {
</td>
          </tr><tr>
            <td class="green">347</td>
            <td>      if (arrayBuilder.len &gt; vectorAfter) {
</td>
          </tr><tr>
            <td class="green">348</td>
            <td>  moveToVector
</td>
          </tr><tr>
            <td class="black">349</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">350</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">351</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">352</td>
            <td>
</td>
          </tr><tr>
            <td class="black">353</td>
            <td>  protected def moveToVector() {
</td>
          </tr><tr>
            <td class="black">354</td>
            <td>    // copy over
</td>
          </tr><tr>
            <td class="green">355</td>
            <td>    val r = arrayBuilder.result
</td>
          </tr><tr>
            <td class="green">356</td>
            <td>    vectorBuilder.sizeHint(r.len)
</td>
          </tr><tr>
            <td class="green">357</td>
            <td>    vectorBuilder.++=(r)
</td>
          </tr><tr>
            <td class="green">358</td>
            <td>    arrayBuilder.clear
</td>
          </tr><tr>
            <td class="green">359</td>
            <td>    inVector = true
</td>
          </tr><tr>
            <td class="green">360</td>
            <td>    haveChosen = true
</td>
          </tr><tr>
            <td class="black">361</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">362</td>
            <td>
</td>
          </tr><tr>
            <td class="black">363</td>
            <td>  def result : ImmutableArrayProxy[A] =
</td>
          </tr><tr>
            <td class="green">364</td>
            <td>    if (inVector) VectorImpl(vectorBuilder.result)
</td>
          </tr><tr>
            <td class="black">365</td>
            <td>    else { // do it here as this is the correct type
</td>
          </tr><tr>
            <td class="black">366</td>
            <td>      import arrayBuilder.{buf, len}
</td>
          </tr><tr>
            <td class="green">367</td>
            <td>      if (len == 1)
</td>
          </tr><tr>
            <td class="green">368</td>
            <td>  IAOne(buf(0).asInstanceOf[A])
</td>
          </tr><tr>
            <td class="black">369</td>
            <td>      else
</td>
          </tr><tr>
            <td class="green">370</td>
            <td>  if (len != 0 &amp;&amp; len == buf.length)
</td>
          </tr><tr>
            <td class="green">371</td>
            <td>    ImmutableArrayAll[A](buf)
</td>
          </tr><tr>
            <td class="black">372</td>
            <td>  else
</td>
          </tr><tr>
            <td class="green">373</td>
            <td>    arrayBuilder.result
</td>
          </tr><tr>
            <td class="black">374</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">375</td>
            <td>
</td>
          </tr><tr>
            <td class="black">376</td>
            <td>  override def ++=(xs: TraversableOnce[A]): this.type = {
</td>
          </tr><tr>
            <td class="black">377</td>
            <td>    // if its already a vector don't start with arrays again
</td>
          </tr><tr>
            <td class="green">378</td>
            <td>    if (!haveChosen &amp;&amp; xs.isInstanceOf[VectorImpl[A]]) {
</td>
          </tr><tr>
            <td class="red">379</td>
            <td>      <span class="non">inVector = true
</span></td>
          </tr><tr>
            <td class="red">380</td>
            <td>      <span class="non">haveChosen = true
</span></td>
          </tr><tr>
            <td class="black">381</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">382</td>
            <td>    
</td>
          </tr><tr>
            <td class="green">383</td>
            <td>    xs match {
</td>
          </tr><tr>
            <td class="black">384</td>
            <td>      case p : ImmutableArrayProxy[A] =&gt; 
</td>
          </tr><tr>
            <td class="green">385</td>
            <td>  if (inVector) 
</td>
          </tr><tr>
            <td class="red">386</td>
            <td>    <span class="non">vectorBuilder.++=(p.ar) 
</span></td>
          </tr><tr>
            <td class="black">387</td>
            <td>  else
</td>
          </tr><tr>
            <td class="green">388</td>
            <td>    arrayBuilder.++=(p.ar)
</td>
          </tr><tr>
            <td class="black">389</td>
            <td>      case _ =&gt; 
</td>
          </tr><tr>
            <td class="green">390</td>
            <td>  if (inVector)
</td>
          </tr><tr>
            <td class="red">391</td>
            <td>    <span class="non">vectorBuilder.++=(xs)
</span></td>
          </tr><tr>
            <td class="black">392</td>
            <td>  else
</td>
          </tr><tr>
            <td class="green">393</td>
            <td>    arrayBuilder.++=(xs)
</td>
          </tr><tr>
            <td class="black">394</td>
            <td>    }      
</td>
          </tr><tr>
            <td class="black">395</td>
            <td>
</td>
          </tr><tr>
            <td class="green">396</td>
            <td>    checkVB
</td>
          </tr><tr>
            <td class="green">397</td>
            <td>    this
</td>
          </tr><tr>
            <td class="black">398</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">399</td>
            <td>
</td>
          </tr><tr>
            <td class="black">400</td>
            <td>  def +=( elem : A) : this.type =
</td>
          </tr><tr>
            <td class="green">401</td>
            <td>    if (inVector) {
</td>
          </tr><tr>
            <td class="red">402</td>
            <td>      <span class="non">vectorBuilder.+=(elem)
</span></td>
          </tr><tr>
            <td class="red">403</td>
            <td>      <span class="non">this
</span></td>
          </tr><tr>
            <td class="black">404</td>
            <td>    } else {
</td>
          </tr><tr>
            <td class="green">405</td>
            <td>      arrayBuilder.+=(elem)
</td>
          </tr><tr>
            <td class="green">406</td>
            <td>      checkVB
</td>
          </tr><tr>
            <td class="green">407</td>
            <td>      this
</td>
          </tr><tr>
            <td class="black">408</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">409</td>
            <td>
</td>
          </tr><tr>
            <td class="black">410</td>
            <td>  def clear() {
</td>
          </tr><tr>
            <td class="red">411</td>
            <td>    <span class="non">vectorBuilder.clear
</span></td>
          </tr><tr>
            <td class="red">412</td>
            <td>    <span class="non">arrayBuilder.clear
</span></td>
          </tr><tr>
            <td class="red">413</td>
            <td>    <span class="non">inVector = false
</span></td>
          </tr><tr>
            <td class="red">414</td>
            <td>    <span class="non">haveChosen = false
</span></td>
          </tr><tr>
            <td class="black">415</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">416</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">417</td>
            <td>
</td>
          </tr><tr>
            <td class="black">418</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">419</td>
            <td> * Wraps behaviour of ImmutableArray like objects, when the array is greater than 31 it will be swapped to Vector.
</td>
          </tr><tr>
            <td class="black">420</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">421</td>
            <td> */ 
</td>
          </tr><tr>
            <td class="black">422</td>
            <td><a id="Trait_scales_utils_ImmutableArrayProxy"></a>trait ImmutableArrayProxy[+A] extends IndexedSeq[A] with IndexedSeqOptimized[A, ImmutableArrayProxy[A]] with GenericTraversableTemplate[A, ImmutableArrayProxy] {
</td>
          </tr><tr>
            <td class="black">423</td>
            <td>
</td>
          </tr><tr>
            <td class="red">424</td>
            <td>  override def companion: GenericCompanion[ImmutableArrayProxy] = <span class="non">ImmutableArrayProxy
</span></td>
          </tr><tr>
            <td class="black">425</td>
            <td>
</td>
          </tr><tr>
            <td class="green">426</td>
            <td>  override protected[this] def newBuilder: Builder[A, ImmutableArrayProxy[A]] = ImmutableArrayProxy.newBuilder[A]
</td>
          </tr><tr>
            <td class="black">427</td>
            <td>
</td>
          </tr><tr>
            <td class="black">428</td>
            <td>  def ar : TraversableOnce[A]
</td>
          </tr><tr>
            <td class="black">429</td>
            <td> 
</td>
          </tr><tr>
            <td class="black">430</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">431</td>
            <td>
</td>
          </tr><tr>
            <td class="black">432</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">433</td>
            <td> * Proxy Vector.  When its in Vector it stays in Vector. 
</td>
          </tr><tr>
            <td class="black">434</td>
            <td> */ 
</td>
          </tr><tr>
            <td class="green">435</td>
            <td><a id="Class_scales_utils_VectorImpl"></a>case class VectorImpl[ +A ](ar : Vector[A]) extends ImmutableArrayProxy[A] {
</td>
          </tr><tr>
            <td class="black">436</td>
            <td>
</td>
          </tr><tr>
            <td class="green">437</td>
            <td>  def apply(idx : Int ) = ar.apply(idx)
</td>
          </tr><tr>
            <td class="black">438</td>
            <td> 
</td>
          </tr><tr>
            <td class="green">439</td>
            <td>  def length = ar.length
</td>
          </tr><tr>
            <td class="black">440</td>
            <td>  
</td>
          </tr><tr>
            <td class="red">441</td>
            <td>  @inline override def +:[B &gt;: A, That](elem: B)(implicit bf: CanBuildFrom[ImmutableArrayProxy[A], B, That]): That = <span class="non">VectorImpl(ar.+:(elem)).asInstanceOf[That]
</span></td>
          </tr><tr>
            <td class="black">442</td>
            <td>  
</td>
          </tr><tr>
            <td class="green">443</td>
            <td>  @inline override def :+[B &gt;: A, That](elem: B)(implicit bf: CanBuildFrom[ImmutableArrayProxy[A], B, That]): That = VectorImpl(ar.:+(elem)).asInstanceOf[That]
</td>
          </tr><tr>
            <td class="black">444</td>
            <td>
</td>
          </tr><tr>
            <td class="red">445</td>
            <td>  @inline override def take( n : Int ) = <span class="non">VectorImpl(ar.take(n))
</span></td>
          </tr><tr>
            <td class="black">446</td>
            <td>
</td>
          </tr><tr>
            <td class="red">447</td>
            <td>  @inline override def drop( n : Int ) = <span class="non">VectorImpl(ar.drop(n))
</span></td>
          </tr><tr>
            <td class="black">448</td>
            <td>
</td>
          </tr><tr>
            <td class="red">449</td>
            <td>  @inline override def tail = <span class="non">VectorImpl(ar.tail)
</span></td>
          </tr><tr>
            <td class="black">450</td>
            <td>
</td>
          </tr><tr>
            <td class="red">451</td>
            <td>  @inline override def slice(from: Int, until: Int) = <span class="non">VectorImpl(ar.slice(from, until))
</span></td>
          </tr><tr>
            <td class="black">452</td>
            <td>
</td>
          </tr><tr>
            <td class="green">453</td>
            <td>  override def updated[B &gt;: A, That](index: Int, elem: B)(implicit bf: CanBuildFrom[ImmutableArrayProxy[A], B, That]): That = VectorImpl(ar.updated(index, elem)).asInstanceOf[That]
</td>
          </tr><tr>
            <td class="black">454</td>
            <td>
</td>
          </tr><tr>
            <td class="red">455</td>
            <td>  override def toArray[U &gt;: A : ClassManifest]: Array[U] = <span class="non">ar.toArray
</span></td>
          </tr><tr>
            <td class="black">456</td>
            <td>
</td>
          </tr><tr>
            <td class="black">457</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">458</td>
            <td>
</td>
          </tr></tbody></table>