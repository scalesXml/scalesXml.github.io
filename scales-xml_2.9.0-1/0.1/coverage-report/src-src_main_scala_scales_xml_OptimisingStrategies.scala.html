<table class="classes"><tbody><tr>
      <td class="barContainerLeft"><a href="#">&#x200B;scales/&#x200B;xml/<span class="header">&#x200B;OptimisingStrategies.scala</span></a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">79 %</div>
        <div class="greenBar" style="width:158px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_OptimisingStrategies.scala.html#Class_scales_xml_BaseToken"><img src="class.png"></img>BaseToken</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_OptimisingStrategies.scala.html#Trait_scales_xml_BaseTokenF"><img src="trait.png"></img>BaseTokenF</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_OptimisingStrategies.scala.html#Object_scales_xml_ElemMemoryOptimisation"><img src="object.png"></img>ElemMemoryOptimisation</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_OptimisingStrategies.scala.html#Trait_scales_xml_ElemOptimisationT"><img src="trait.png"></img>ElemOptimisationT</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_OptimisingStrategies.scala.html#Trait_scales_xml_ElemQNameOptimisationT"><img src="trait.png"></img>ElemQNameOptimisationT</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">93 %</div>
        <div class="greenBar" style="width:186px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_OptimisingStrategies.scala.html#Class_scales_xml_ElemToken"><img src="class.png"></img>ElemToken</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_OptimisingStrategies.scala.html#Trait_scales_xml_ElemTokenF"><img src="trait.png"></img>ElemTokenF</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_OptimisingStrategies.scala.html#Trait_scales_xml_FullMemoryOptimisationT"><img src="trait.png"></img>FullMemoryOptimisationT</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_OptimisingStrategies.scala.html#Object_scales_xml_HighMemoryOptimisation"><img src="object.png"></img>HighMemoryOptimisation</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_OptimisingStrategies.scala.html#Object_scales_xml_MemoryAndSpeedierStrategy"><img src="object.png"></img>MemoryAndSpeedierStrategy</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_OptimisingStrategies.scala.html#Trait_scales_xml_MemoryOptimisationStrategy"><img src="trait.png"></img>MemoryOptimisationStrategy</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_OptimisingStrategies.scala.html#Class_scala_collection_immutable_MutableVectorLike"><img src="class.png"></img>MutableVectorLike</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">64 %</div>
        <div class="greenBar" style="width:128px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_OptimisingStrategies.scala.html#Trait_scales_xml_MutableVectorLikeStrategy"><img src="trait.png"></img>MutableVectorLikeStrategy</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_OptimisingStrategies.scala.html#Object_scales_xml_NoOptimisation"><img src="object.png"></img>NoOptimisation</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_OptimisingStrategies.scala.html#Trait_scales_xml_OptimisationToken"><img src="trait.png"></img>OptimisationToken</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_OptimisingStrategies.scala.html#Trait_scales_xml_OptimisingStrategiesImplicits"><img src="trait.png"></img>OptimisingStrategiesImplicits</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_OptimisingStrategies.scala.html#Trait_scales_xml_PathOptimisationStrategy"><img src="trait.png"></img>PathOptimisationStrategy</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_OptimisingStrategies.scala.html#Object_scales_xml_QNameAndSpeedierStrategy"><img src="object.png"></img>QNameAndSpeedierStrategy</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_OptimisingStrategies.scala.html#Object_scales_xml_QNameMemoryOptimisation"><img src="object.png"></img>QNameMemoryOptimisation</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_OptimisingStrategies.scala.html#Trait_scales_xml_QNameOptimisationT"><img src="trait.png"></img>QNameOptimisationT</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">93 %</div>
        <div class="greenBar" style="width:186px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_OptimisingStrategies.scala.html#Class_scales_xml_QNameToken"><img src="class.png"></img>QNameToken</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_OptimisingStrategies.scala.html#Trait_scales_xml_QNameTokenF"><img src="trait.png"></img>QNameTokenF</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_OptimisingStrategies.scala.html#Trait_scales_xml_TextNodeJoiner"><img src="trait.png"></img>TextNodeJoiner</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr></tbody></table><table class="source"><tbody><tr>
            <td class="black">1</td>
            <td>package scales.xml {
</td>
          </tr><tr>
            <td class="black">2</td>
            <td>
</td>
          </tr><tr>
            <td class="black">3</td>
            <td>import scales.utils._
</td>
          </tr><tr>
            <td class="black">4</td>
            <td>
</td>
          </tr><tr>
            <td class="black">5</td>
            <td><a id="Trait_scales_xml_OptimisingStrategiesImplicits"></a>trait OptimisingStrategiesImplicits {
</td>
          </tr><tr>
            <td class="black">6</td>
            <td>//  implicit val defaultPathOptimisation : PathOptimisationStrategy = NoOptimisation
</td>
          </tr><tr>
            <td class="black">7</td>
            <td>//  implicit val defaultOptimisation : MemoryOptimisationStrategy = NoOptimisation
</td>
          </tr><tr>
            <td class="black">8</td>
            <td>
</td>
          </tr><tr>
            <td class="black">9</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">10</td>
            <td>
</td>
          </tr><tr>
            <td class="black">11</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">12</td>
            <td> * Simple marker for per parse optimisation oppurtunties
</td>
          </tr><tr>
            <td class="black">13</td>
            <td> */
</td>
          </tr><tr>
            <td class="black">14</td>
            <td><a id="Trait_scales_xml_OptimisationToken"></a>trait OptimisationToken {
</td>
          </tr><tr>
            <td class="black">15</td>
            <td>  implicit val ver : XmlVersion
</td>
          </tr><tr>
            <td class="black">16</td>
            <td>  implicit val fromParser : FromParser
</td>
          </tr><tr>
            <td class="black">17</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">18</td>
            <td>
</td>
          </tr><tr>
            <td class="red">19</td>
            <td><a id="Class_scales_xml_BaseToken"></a>class BaseToken<span class="non">(implicit val ver : XmlVersion, val fromParser : FromParser) extends OptimisationToken
</span></td>
          </tr><tr>
            <td class="black">20</td>
            <td>
</td>
          </tr><tr>
            <td class="black">21</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">22</td>
            <td> * Memory usage in DOMs is often dominated by repeated elements.  Xerces and co use string tables to optimise memory usage, with DTM a key example.
</td>
          </tr><tr>
            <td class="black">23</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">24</td>
            <td> * Performing lookups is expensive so the strategys have selective levels of lookup.  Developers may therefore choose appropriate levels that best fit their trade-off between space and time.
</td>
          </tr><tr>
            <td class="black">25</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">26</td>
            <td> * There will, of course, be temporary garbage created for such a scheme but it should pay off for larger messages.
</td>
          </tr><tr>
            <td class="black">27</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">28</td>
            <td> */ 
</td>
          </tr><tr>
            <td class="black">29</td>
            <td><a id="Trait_scales_xml_MemoryOptimisationStrategy"></a>trait MemoryOptimisationStrategy[Token &lt;: OptimisationToken] {
</td>
          </tr><tr>
            <td class="black">30</td>
            <td>
</td>
          </tr><tr>
            <td class="black">31</td>
            <td>  def createToken(implicit ver : XmlVersion, fromParser : FromParser) : Token
</td>
          </tr><tr>
            <td class="black">32</td>
            <td>
</td>
          </tr><tr>
            <td class="black">33</td>
            <td>//  def createToken(implicit ver : XmlVersion, fromParser : FromParser) : Token = new BaseToken()
</td>
          </tr><tr>
            <td class="black">34</td>
            <td>
</td>
          </tr><tr>
            <td class="black">35</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">36</td>
            <td>   * It is expected that certain attributes have fixed values, ie. booleans or based on schema enums etc, this function allows such optimisations.
</td>
          </tr><tr>
            <td class="black">37</td>
            <td>   *
</td>
          </tr><tr>
            <td class="black">38</td>
            <td>   * The qname will have been obtained via qName, so any optimisations provided by it can be leveraged.
</td>
          </tr><tr>
            <td class="black">39</td>
            <td>   *
</td>
          </tr><tr>
            <td class="black">40</td>
            <td>   */ 
</td>
          </tr><tr>
            <td class="green">41</td>
            <td>  def attribute( qname : AttributeQName, value : String, token : Token) : Attribute = Attribute(qname,value)
</td>
          </tr><tr>
            <td class="black">42</td>
            <td>
</td>
          </tr><tr>
            <td class="black">43</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">44</td>
            <td>   * The creation costs can also be reduced
</td>
          </tr><tr>
            <td class="black">45</td>
            <td>   */ 
</td>
          </tr><tr>
            <td class="black">46</td>
            <td>  def noNamespaceQName( local : String, token : Token) : NoNamespaceQName = {
</td>
          </tr><tr>
            <td class="black">47</td>
            <td>    import token._
</td>
          </tr><tr>
            <td class="green">48</td>
            <td>    NoNamespaceQName(local)
</td>
          </tr><tr>
            <td class="black">49</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">50</td>
            <td>
</td>
          </tr><tr>
            <td class="black">51</td>
            <td>  def unprefixedQName( local : String, uri : String, token : Token) : UnprefixedQName =  {
</td>
          </tr><tr>
            <td class="black">52</td>
            <td>    import token._
</td>
          </tr><tr>
            <td class="green">53</td>
            <td>    UnprefixedQName(local, Namespace(uri))
</td>
          </tr><tr>
            <td class="black">54</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">55</td>
            <td>
</td>
          </tr><tr>
            <td class="black">56</td>
            <td>  def prefixedQName( local : String, uri : String, prefix : String, token : Token) : PrefixedQName =  {
</td>
          </tr><tr>
            <td class="black">57</td>
            <td>    import token._
</td>
          </tr><tr>
            <td class="green">58</td>
            <td>    PrefixedQName(local, Namespace(uri).prefixed(prefix))
</td>
          </tr><tr>
            <td class="black">59</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">60</td>
            <td>
</td>
          </tr><tr>
            <td class="black">61</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">62</td>
            <td>   * For files without large (and varied) attribute counts per repeated element it may represent significant space savings to optimise against the entire Elem itself.
</td>
          </tr><tr>
            <td class="black">63</td>
            <td>   *
</td>
          </tr><tr>
            <td class="black">64</td>
            <td>   * The Elements QName is garaunteed to be the last QName evaluated via the QName functions (i.e. Attributes are done first then the Elems QName)  
</td>
          </tr><tr>
            <td class="black">65</td>
            <td>   */ 
</td>
          </tr><tr>
            <td class="black">66</td>
            <td>  def elem( name : QName, attributes : Attributes, namespaces : Map[String, String], token : Token) : Elem =  {
</td>
          </tr><tr>
            <td class="black">67</td>
            <td>    import token._
</td>
          </tr><tr>
            <td class="green">68</td>
            <td>    Elem(name, attributes, namespaces)
</td>
          </tr><tr>
            <td class="black">69</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">70</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">71</td>
            <td>
</td>
          </tr><tr>
            <td class="black">72</td>
            <td><a id="Trait_scales_xml_BaseTokenF"></a>trait BaseTokenF {
</td>
          </tr><tr>
            <td class="black">73</td>
            <td>
</td>
          </tr><tr>
            <td class="red">74</td>
            <td>  def createToken(implicit ver : XmlVersion, fromParser : FromParser) : BaseToken = <span class="non">new BaseToken()
</span></td>
          </tr><tr>
            <td class="black">75</td>
            <td>
</td>
          </tr><tr>
            <td class="black">76</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">77</td>
            <td>
</td>
          </tr><tr>
            <td class="black">78</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">79</td>
            <td> * Default optimisation strategy, performing no optimisation at all
</td>
          </tr><tr>
            <td class="black">80</td>
            <td> */ 
</td>
          </tr><tr>
            <td class="black">81</td>
            <td><a id="Object_scales_xml_NoOptimisation"></a>object NoOptimisation extends PathOptimisationStrategy[BaseToken] with BaseTokenF
</td>
          </tr><tr>
            <td class="black">82</td>
            <td>
</td>
          </tr><tr>
            <td class="black">83</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">84</td>
            <td> * Certain paths may be repeated (based on QNames of parents etc) and known to be by the developer, its also possible that the developer simply is not interested in this path.
</td>
          </tr><tr>
            <td class="black">85</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">86</td>
            <td> * Developers may also customise the creation of paths (for example adding starting children or replacing the XmlChildren implementation.
</td>
          </tr><tr>
            <td class="black">87</td>
            <td> */
</td>
          </tr><tr>
            <td class="black">88</td>
            <td><a id="Trait_scales_xml_PathOptimisationStrategy"></a>trait PathOptimisationStrategy[Token &lt;: OptimisationToken] extends MemoryOptimisationStrategy[Token] {
</td>
          </tr><tr>
            <td class="black">89</td>
            <td>  
</td>
          </tr><tr>
            <td class="black">90</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">91</td>
            <td>   * Any elementEnd implementation must perform either an xml.zipUp
</td>
          </tr><tr>
            <td class="black">92</td>
            <td>   * or removeAndUp.  The default performs a zipUp
</td>
          </tr><tr>
            <td class="black">93</td>
            <td>   */ 
</td>
          </tr><tr>
            <td class="black">94</td>
            <td><a id="Trait_scales_xml_TextNodeJoiner"></a>  def elementEnd( xml : TreeProxies, token : Token)  
</td>
          </tr><tr>
            <td class="black">95</td>
            <td>//    : XmlPath = xml.zipUp 
</td>
          </tr><tr>
            <td class="black">96</td>
            <td>    {
</td>
          </tr><tr>
            <td class="green">97</td>
            <td>      xml.elementEnd
</td>
          </tr><tr>
            <td class="black">98</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">99</td>
            <td>
</td>
          </tr><tr>
            <td class="black">100</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">101</td>
            <td>   * Start a new tree, defaults to addAndFocus.
</td>
          </tr><tr>
            <td class="black">102</td>
            <td>   */ 
</td>
          </tr><tr>
            <td class="black">103</td>
            <td>  def beginSubTree( stack : TreeProxies, elem : Elem, token : Token) {
</td>
          </tr><tr>
            <td class="green">104</td>
            <td>    stack.beginSub(elem)
</td>
          </tr><tr>
            <td class="black">105</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">106</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">107</td>
            <td>
</td>
          </tr><tr>
            <td class="green">108</td>
            <td><a id="Class_scales_xml_QNameToken"></a>class QNameToken(implicit val ver : XmlVersion, val fromParser : FromParser) extends OptimisationToken {
</td>
          </tr><tr>
            <td class="green">109</td>
            <td>  val qkey = new FullEqualQNameKey()
</td>
          </tr><tr>
            <td class="black">110</td>
            <td>
</td>
          </tr><tr>
            <td class="black">111</td>
            <td>  // the following reduce init costs was 6% of garbage and 3% of runtime on avg
</td>
          </tr><tr>
            <td class="black">112</td>
            <td>
</td>
          </tr><tr>
            <td class="green">113</td>
            <td>  val noNsQ = (k : FullEqualQNameKey) =&gt; NoNamespaceQName(k.local)
</td>
          </tr><tr>
            <td class="green">114</td>
            <td>  val unQ = (k : FullEqualQNameKey) =&gt; UnprefixedQName(k.local, Namespace(k.namespace))
</td>
          </tr><tr>
            <td class="green">115</td>
            <td>  val pQ = (k : FullEqualQNameKey) =&gt; PrefixedQName(k.local, Namespace(k.namespace).prefixed(k.prefix))
</td>
          </tr><tr>
            <td class="black">116</td>
            <td>  
</td>
          </tr><tr>
            <td class="black">117</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">118</td>
            <td>
</td>
          </tr><tr>
            <td class="black">119</td>
            <td><a id="Trait_scales_xml_QNameTokenF"></a>trait QNameTokenF {
</td>
          </tr><tr>
            <td class="green">120</td>
            <td>  def createToken(implicit ver : XmlVersion, fromParser : FromParser) = new QNameToken()
</td>
          </tr><tr>
            <td class="black">121</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">122</td>
            <td>
</td>
          </tr><tr>
            <td class="black">123</td>
            <td>
</td>
          </tr><tr>
            <td class="black">124</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">125</td>
            <td> * Threadsafe global cache, assumption is most applications would benefit from this 
</td>
          </tr><tr>
            <td class="black">126</td>
            <td> */
</td>
          </tr><tr>
            <td class="black">127</td>
            <td><a id="Trait_scales_xml_QNameOptimisationT"></a>trait QNameOptimisationT[Token &lt;: QNameToken] extends MemoryOptimisationStrategy[Token] {
</td>
          </tr><tr>
            <td class="black">128</td>
            <td>
</td>
          </tr><tr>
            <td class="black">129</td>
            <td>  import java.util.concurrent.ConcurrentHashMap
</td>
          </tr><tr>
            <td class="black">130</td>
            <td>
</td>
          </tr><tr>
            <td class="green">131</td>
            <td>  val qNameCache = new ConcurrentHashMap[ FullEqualQNameKey, QName ]
</td>
          </tr><tr>
            <td class="black">132</td>
            <td>  
</td>
          </tr><tr>
            <td class="black">133</td>
            <td>//  override def createToken(implicit ver : XmlVersion, fromParser : FromParser) = new QNameToken()
</td>
          </tr><tr>
            <td class="black">134</td>
            <td>
</td>
          </tr><tr>
            <td class="black">135</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">136</td>
            <td>   * The creation costs can also be reduced
</td>
          </tr><tr>
            <td class="black">137</td>
            <td>   */ 
</td>
          </tr><tr>
            <td class="black">138</td>
            <td>  override def noNamespaceQName( local : String, token : Token) : NoNamespaceQName = {
</td>
          </tr><tr>
            <td class="green">139</td>
            <td>    val qt = token//.asInstanceOf[QNameToken]
</td>
          </tr><tr>
            <td class="black">140</td>
            <td>    import qt._
</td>
          </tr><tr>
            <td class="green">141</td>
            <td>    value( qkey.setNoNamespaceQName(local) )( noNsQ )
</td>
          </tr><tr>
            <td class="black">142</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">143</td>
            <td>
</td>
          </tr><tr>
            <td class="black">144</td>
            <td>  override def unprefixedQName( local : String, uri : String, token : Token) : UnprefixedQName = {
</td>
          </tr><tr>
            <td class="green">145</td>
            <td>    val qt = token//.asInstanceOf[QNameToken]
</td>
          </tr><tr>
            <td class="black">146</td>
            <td>    import qt._
</td>
          </tr><tr>
            <td class="green">147</td>
            <td>    value( qkey.setUnprefixedQName(local, uri) )( unQ )
</td>
          </tr><tr>
            <td class="black">148</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">149</td>
            <td>
</td>
          </tr><tr>
            <td class="black">150</td>
            <td>  override def prefixedQName( local : String, uri : String, prefix : String, token : Token) : PrefixedQName = {
</td>
          </tr><tr>
            <td class="green">151</td>
            <td>    val qt = token//.asInstanceOf[QNameToken]
</td>
          </tr><tr>
            <td class="black">152</td>
            <td>    import qt._
</td>
          </tr><tr>
            <td class="green">153</td>
            <td>    value( qkey.setPrefixedQName( local, uri, prefix) )( pQ )
</td>
          </tr><tr>
            <td class="black">154</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">155</td>
            <td>
</td>
          </tr><tr>
            <td class="black">156</td>
            <td>  def value[T &lt;: QName](key : FullEqualQNameKey)( newT : FullEqualQNameKey =&gt; T ) : T = {
</td>
          </tr><tr>
            <td class="green">157</td>
            <td>    var value = qNameCache.get(key)
</td>
          </tr><tr>
            <td class="green">158</td>
            <td>    if (value == null) {
</td>
          </tr><tr>
            <td class="green">159</td>
            <td>      value = newT(key)
</td>
          </tr><tr>
            <td class="green">160</td>
            <td>      val res = qNameCache.putIfAbsent(key.copy, value)// copy because now it needs to be frozen
</td>
          </tr><tr>
            <td class="yellow">161</td>
            <td>      value = if (res == null) value else <span class="non">res
</span></td>
          </tr><tr>
            <td class="black">162</td>
            <td>    }
</td>
          </tr><tr>
            <td class="green">163</td>
            <td>    value.asInstanceOf[T]
</td>
          </tr><tr>
            <td class="black">164</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">165</td>
            <td>
</td>
          </tr><tr>
            <td class="black">166</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">167</td>
            <td>
</td>
          </tr><tr>
            <td class="green">168</td>
            <td><a id="Class_scales_xml_ElemToken"></a>class ElemToken(implicit ver : XmlVersion, fromParser : FromParser) extends QNameToken {
</td>
          </tr><tr>
            <td class="green">169</td>
            <td>  val ekey = new ElemKey()
</td>
          </tr><tr>
            <td class="black">170</td>
            <td>  
</td>
          </tr><tr>
            <td class="green">171</td>
            <td>  val ef = (key : ElemKey) =&gt; Elem(key.name, key.attributes, key.namespaces)
</td>
          </tr><tr>
            <td class="black">172</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">173</td>
            <td>
</td>
          </tr><tr>
            <td class="black">174</td>
            <td><a id="Trait_scales_xml_ElemTokenF"></a>trait ElemTokenF {
</td>
          </tr><tr>
            <td class="green">175</td>
            <td>  def createToken(implicit ver : XmlVersion, fromParser : FromParser) = new ElemToken()
</td>
          </tr><tr>
            <td class="black">176</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">177</td>
            <td>
</td>
          </tr><tr>
            <td class="black">178</td>
            <td>
</td>
          </tr><tr>
            <td class="black">179</td>
            <td><a id="Trait_scales_xml_ElemQNameOptimisationT"></a>trait ElemQNameOptimisationT[Token &lt;: ElemToken] extends QNameOptimisationT[Token] {
</td>
          </tr><tr>
            <td class="black">180</td>
            <td>  import java.util.concurrent.ConcurrentHashMap
</td>
          </tr><tr>
            <td class="black">181</td>
            <td>
</td>
          </tr><tr>
            <td class="green">182</td>
            <td>  val ecache = new ConcurrentHashMap[ ElemKey, Elem ]
</td>
          </tr><tr>
            <td class="black">183</td>
            <td>
</td>
          </tr><tr>
            <td class="green">184</td>
            <td>  val cacheAll = false
</td>
          </tr><tr>
            <td class="black">185</td>
            <td>
</td>
          </tr><tr>
            <td class="black">186</td>
            <td>  def elemValue(key : ElemKey)( newT : ElemKey =&gt; Elem ) : Elem = {
</td>
          </tr><tr>
            <td class="green">187</td>
            <td>    var value = ecache.get(key)
</td>
          </tr><tr>
            <td class="green">188</td>
            <td>    if (value == null) {
</td>
          </tr><tr>
            <td class="green">189</td>
            <td>      value = newT(key)
</td>
          </tr><tr>
            <td class="green">190</td>
            <td>      val res = ecache.putIfAbsent(key.copy, value)// copy because now it needs to be frozen
</td>
          </tr><tr>
            <td class="yellow">191</td>
            <td>      value = if (res == null) value else <span class="non">res
</span></td>
          </tr><tr>
            <td class="black">192</td>
            <td>    }
</td>
          </tr><tr>
            <td class="green">193</td>
            <td>    value
</td>
          </tr><tr>
            <td class="black">194</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">195</td>
            <td>
</td>
          </tr><tr>
            <td class="black">196</td>
            <td>  override def elem( name : QName, attributes : Attributes, namespaces : Map[String, String], token : Token) : Elem = { 
</td>
          </tr><tr>
            <td class="green">197</td>
            <td>    val et = token//.asInstanceOf[ElemToken]
</td>
          </tr><tr>
            <td class="black">198</td>
            <td>    import et._
</td>
          </tr><tr>
            <td class="black">199</td>
            <td>
</td>
          </tr><tr>
            <td class="green">200</td>
            <td>    if (cacheAll ||
</td>
          </tr><tr>
            <td class="black">201</td>
            <td>  ((attributes eq emptyAttributes) &amp;&amp;
</td>
          </tr><tr>
            <td class="black">202</td>
            <td>  (namespaces eq emptyNamespaces))
</td>
          </tr><tr>
            <td class="black">203</td>
            <td>  )
</td>
          </tr><tr>
            <td class="green">204</td>
            <td>        elemValue(ekey.set(name, attributes, namespaces, qkey.lastHash) )( ef )
</td>
          </tr><tr>
            <td class="green">205</td>
            <td>    else Elem(name, attributes, namespaces)(token.fromParser)
</td>
          </tr><tr>
            <td class="black">206</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">207</td>
            <td>  
</td>
          </tr><tr>
            <td class="black">208</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">209</td>
            <td>
</td>
          </tr><tr>
            <td class="black">210</td>
            <td><a id="Trait_scales_xml_FullMemoryOptimisationT"></a>trait FullMemoryOptimisationT[Token &lt;: ElemToken] extends ElemQNameOptimisationT[Token] {
</td>
          </tr><tr>
            <td class="red">211</td>
            <td>  override val cacheAll = <span class="non">true
</span></td>
          </tr><tr>
            <td class="black">212</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">213</td>
            <td>
</td>
          </tr><tr>
            <td class="black">214</td>
            <td><a id="Object_scales_xml_QNameMemoryOptimisation"></a>object QNameMemoryOptimisation extends PathOptimisationStrategy[QNameToken] with QNameOptimisationT[QNameToken] with QNameTokenF
</td>
          </tr><tr>
            <td class="black">215</td>
            <td>
</td>
          </tr><tr>
            <td class="black">216</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">217</td>
            <td> * Simple hashmap on Elem -&gt; Elem, makes no optimisations across qnames (use QNameOptimisationT for that)
</td>
          </tr><tr>
            <td class="black">218</td>
            <td> */ 
</td>
          </tr><tr>
            <td class="black">219</td>
            <td><a id="Trait_scales_xml_ElemOptimisationT"></a>trait ElemOptimisationT[Token &lt;: OptimisationToken] extends MemoryOptimisationStrategy[Token] {
</td>
          </tr><tr>
            <td class="black">220</td>
            <td>
</td>
          </tr><tr>
            <td class="black">221</td>
            <td>  import java.util.concurrent.ConcurrentHashMap
</td>
          </tr><tr>
            <td class="black">222</td>
            <td>
</td>
          </tr><tr>
            <td class="red">223</td>
            <td>  val cache = <span class="non">new ConcurrentHashMap[ Elem, Elem ]
</span></td>
          </tr><tr>
            <td class="black">224</td>
            <td>
</td>
          </tr><tr>
            <td class="black">225</td>
            <td>  override def elem( name : QName, attributes : Attributes, namespaces : Map[String, String], token : Token) : Elem = {
</td>
          </tr><tr>
            <td class="black">226</td>
            <td>    import token._
</td>
          </tr><tr>
            <td class="red">227</td>
            <td>    <span class="non">value(Elem(name, attributes, namespaces), cache) (Elem(name, attributes, namespaces))
</span></td>
          </tr><tr>
            <td class="black">228</td>
            <td>  }  
</td>
          </tr><tr>
            <td class="black">229</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">230</td>
            <td>
</td>
          </tr><tr>
            <td class="black">231</td>
            <td><a id="Object_scales_xml_ElemMemoryOptimisation"></a>object ElemMemoryOptimisation extends PathOptimisationStrategy[ElemToken] with ElemOptimisationT[ElemToken] with ElemTokenF
</td>
          </tr><tr>
            <td class="black">232</td>
            <td>
</td>
          </tr><tr>
            <td class="black">233</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">234</td>
            <td> * Optimises on QNames and Elems, reducing duplicates at the cost of CHM lookups.
</td>
          </tr><tr>
            <td class="black">235</td>
            <td> */ 
</td>
          </tr><tr>
            <td class="black">236</td>
            <td><a id="Object_scales_xml_HighMemoryOptimisation"></a>object HighMemoryOptimisation extends PathOptimisationStrategy[ElemToken] with ElemOptimisationT[ElemToken] with QNameOptimisationT[ElemToken] with ElemTokenF
</td>
          </tr><tr>
            <td class="black">237</td>
            <td>
</td>
          </tr><tr>
            <td class="black">238</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">239</td>
            <td> * As this adds extra processing time, but better fits XPath rules (i.e. all text children below are joined) its available to be mixed in, but isn't added by default.
</td>
          </tr><tr>
            <td class="black">240</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">241</td>
            <td> * This also removes any extra parsing time from string joining.
</td>
          </tr><tr>
            <td class="black">242</td>
            <td> */ 
</td>
          </tr><tr>
            <td class="black">243</td>
            <td>trait TextNodeJoiner[Token &lt;: OptimisationToken] extends PathOptimisationStrategy[Token] {
</td>
          </tr><tr>
            <td class="black">244</td>
            <td>    
</td>
          </tr><tr>
            <td class="black">245</td>
            <td>  import ScalesXml.xmlCBF
</td>
          </tr><tr>
            <td class="black">246</td>
            <td>
</td>
          </tr><tr>
            <td class="black">247</td>
            <td>  override def elementEnd( proxies : TreeProxies, token : Token) {
</td>
          </tr><tr>
            <td class="black">248</td>
            <td>    // get our current call the real one
</td>
          </tr><tr>
            <td class="green">249</td>
            <td>    val l = proxies.current
</td>
          </tr><tr>
            <td class="green">250</td>
            <td>    super.elementEnd(proxies, token)
</td>
          </tr><tr>
            <td class="black">251</td>
            <td>
</td>
          </tr><tr>
            <td class="green">252</td>
            <td>    val joined = joinTextNodes(l.children)
</td>
          </tr><tr>
            <td class="black">253</td>
            <td>
</td>
          </tr><tr>
            <td class="black">254</td>
            <td>    // if depth == -1 then l.children is now fixed
</td>
          </tr><tr>
            <td class="green">255</td>
            <td>    if (proxies.depth == -1) {
</td>
          </tr><tr>
            <td class="green">256</td>
            <td>      l.children = joined
</td>
          </tr><tr>
            <td class="black">257</td>
            <td>    } else {
</td>
          </tr><tr>
            <td class="black">258</td>
            <td>      // we have to look at new current and manipulate that
</td>
          </tr><tr>
            <td class="green">259</td>
            <td>      val nc = proxies.current
</td>
          </tr><tr>
            <td class="green">260</td>
            <td>      nc.children = nc.children.updated(nc.children.size - 1, Tree(l.elem, joined))
</td>
          </tr><tr>
            <td class="black">261</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">262</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">263</td>
            <td>
</td>
          </tr><tr>
            <td class="black">264</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">265</td>
            <td>
</td>
          </tr><tr>
            <td class="black">266</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">267</td>
            <td> * A Mutable vector is used internally, only update on the last element and :+/append is supported, the result of elementEnd is however immutable and safe to re-use via a super call.
</td>
          </tr><tr>
            <td class="black">268</td>
            <td> */ 
</td>
          </tr><tr>
            <td class="black">269</td>
            <td><a id="Trait_scales_xml_MutableVectorLikeStrategy"></a>trait MutableVectorLikeStrategy[Token &lt;: OptimisationToken] extends PathOptimisationStrategy[Token] {
</td>
          </tr><tr>
            <td class="black">270</td>
            <td>  
</td>
          </tr><tr>
            <td class="black">271</td>
            <td>  import ScalesXml.xmlCBF
</td>
          </tr><tr>
            <td class="black">272</td>
            <td>  import scala.collection.immutable.MutableVectorLike
</td>
          </tr><tr>
            <td class="black">273</td>
            <td>
</td>
          </tr><tr>
            <td class="black">274</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">275</td>
            <td>   * Reproduced zipUp
</td>
          </tr><tr>
            <td class="black">276</td>
            <td>   */ 
</td>
          </tr><tr>
            <td class="black">277</td>
            <td>  override def elementEnd( proxies : TreeProxies, token : Token) {
</td>
          </tr><tr>
            <td class="green">278</td>
            <td>    val l = proxies.current
</td>
          </tr><tr>
            <td class="green">279</td>
            <td>    l.children = l.children.asInstanceOf[MutableVectorLike[ItemOrElem]].immutable
</td>
          </tr><tr>
            <td class="green">280</td>
            <td>    if (proxies.depth &gt; 0) {
</td>
          </tr><tr>
            <td class="green">281</td>
            <td>      proxies.depth -= 1
</td>
          </tr><tr>
            <td class="green">282</td>
            <td>      val newC = proxies.proxies( proxies.depth )
</td>
          </tr><tr>
            <td class="green">283</td>
            <td>      proxies.current = newC
</td>
          </tr><tr>
            <td class="green">284</td>
            <td>      newC.children = (newC.children :+ Tree(l.elem, l.children))
</td>
          </tr><tr>
            <td class="black">285</td>
            <td>    } else {
</td>
          </tr><tr>
            <td class="green">286</td>
            <td>      proxies.depth -= 1
</td>
          </tr><tr>
            <td class="black">287</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">288</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">289</td>
            <td>  
</td>
          </tr><tr>
            <td class="black">290</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">291</td>
            <td>   * Start a new tree, substitutes a MutableVectorLike instead of an immutable
</td>
          </tr><tr>
            <td class="black">292</td>
            <td>   */ 
</td>
          </tr><tr>
            <td class="black">293</td>
            <td>  override def beginSubTree( proxies : TreeProxies, elem : Elem, token : Token) {
</td>
          </tr><tr>
            <td class="green">294</td>
            <td>    proxies.beginSub(elem, new MutableVectorLike[ItemOrElem](true))
</td>
          </tr><tr>
            <td class="black">295</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">296</td>
            <td>   
</td>
          </tr><tr>
            <td class="black">297</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">298</td>
            <td>
</td>
          </tr><tr>
            <td class="black">299</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">300</td>
            <td> * Reduces memory consumption at a 5-10% perfromance hit over the default QNameAndSpeedierStrategy
</td>
          </tr><tr>
            <td class="black">301</td>
            <td> */ 
</td>
          </tr><tr>
            <td class="black">302</td>
            <td><a id="Object_scales_xml_MemoryAndSpeedierStrategy"></a>object MemoryAndSpeedierStrategy extends MutableVectorLikeStrategy[ElemToken] with FullMemoryOptimisationT[ElemToken] with ElemTokenF
</td>
          </tr><tr>
            <td class="black">303</td>
            <td>
</td>
          </tr><tr>
            <td class="black">304</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">305</td>
            <td> * The default as it will equal or better Scala Xml memory consumption at a performance gain.
</td>
          </tr><tr>
            <td class="black">306</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">307</td>
            <td> * For the lowest memory consumption possible, for example where memory is more important than raw performance, see MemoryAndSpeedierStrategy
</td>
          </tr><tr>
            <td class="black">308</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">309</td>
            <td> */
</td>
          </tr><tr>
            <td class="black">310</td>
            <td><a id="Object_scales_xml_QNameAndSpeedierStrategy"></a>object QNameAndSpeedierStrategy extends MutableVectorLikeStrategy[ElemToken] with ElemQNameOptimisationT[ElemToken] with ElemTokenF
</td>
          </tr><tr>
            <td class="black">311</td>
            <td>
</td>
          </tr><tr>
            <td class="black">312</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">313</td>
            <td>
</td>
          </tr><tr>
            <td class="black">314</td>
            <td>package scala.collection.immutable {
</td>
          </tr><tr>
            <td class="black">315</td>
            <td>
</td>
          </tr><tr>
            <td class="black">316</td>
            <td>import scala.annotation.unchecked.uncheckedVariance
</td>
          </tr><tr>
            <td class="black">317</td>
            <td>
</td>
          </tr><tr>
            <td class="black">318</td>
            <td>import scales.utils._
</td>
          </tr><tr>
            <td class="black">319</td>
            <td>
</td>
          </tr><tr>
            <td class="black">320</td>
            <td>//import collection.{IndexedSeqOptimized, IndexedSeqLike, IndexedSeq}
</td>
          </tr><tr>
            <td class="black">321</td>
            <td>import collection.mutable.Builder //{ArrayBuilder, Builder}
</td>
          </tr><tr>
            <td class="black">322</td>
            <td>import collection.generic.{CanBuildFrom, GenericTraversableTemplate, SeqFactory, GenericCompanion}
</td>
          </tr><tr>
            <td class="black">323</td>
            <td>
</td>
          </tr><tr>
            <td class="black">324</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">325</td>
            <td> * Don't use this unless you are not having your own OptimisationStrategies.
</td>
          </tr><tr>
            <td class="black">326</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">327</td>
            <td> * Basic copy of a VectorBuilder but without result etc, this only uses ar
</td>
          </tr><tr>
            <td class="black">328</td>
            <td> * and returns either a smaller immutablearray or a vectorimpl.
</td>
          </tr><tr>
            <td class="black">329</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">330</td>
            <td> * The whole idea is not to routinely copy the tree around and provide
</td>
          </tr><tr>
            <td class="black">331</td>
            <td> * very fast updates and access to the current head (i.e. zipUp)
</td>
          </tr><tr>
            <td class="black">332</td>
            <td> */ 
</td>
          </tr><tr>
            <td class="green">333</td>
            <td><a id="Class_scala_collection_immutable_MutableVectorLike"></a>final class MutableVectorLike[+A](val copyArray : Boolean = false) extends ImmutableArrayProxy[A] with VectorPointer[A @uncheckedVariance]{
</td>
          </tr><tr>
            <td class="black">334</td>
            <td>
</td>
          </tr><tr>
            <td class="red">335</td>
            <td>  override def companion: GenericCompanion[ImmutableArrayProxy] = <span class="non">err
</span></td>
          </tr><tr>
            <td class="black">336</td>
            <td>
</td>
          </tr><tr>
            <td class="red">337</td>
            <td>  override protected[this] def newBuilder: Builder[A, ImmutableArrayProxy[A]] = <span class="non">err
</span></td>
          </tr><tr>
            <td class="black">338</td>
            <td>
</td>
          </tr><tr>
            <td class="green">339</td>
            <td>  display0 = new Array[AnyRef](32)
</td>
          </tr><tr>
            <td class="green">340</td>
            <td>  depth = 1
</td>
          </tr><tr>
            <td class="black">341</td>
            <td>
</td>
          </tr><tr>
            <td class="red">342</td>
            <td>  def err = <span class="non">error(&quot;MutableVector like only supports apply(length-1), updated(length - 1), :+ and immutable&quot;)
</span></td>
          </tr><tr>
            <td class="black">343</td>
            <td>
</td>
          </tr><tr>
            <td class="green">344</td>
            <td>  private var blockIndex = 0
</td>
          </tr><tr>
            <td class="green">345</td>
            <td>  private var lo = 0
</td>
          </tr><tr>
            <td class="black">346</td>
            <td>
</td>
          </tr><tr>
            <td class="green">347</td>
            <td>  private var len = 0
</td>
          </tr><tr>
            <td class="black">348</td>
            <td>
</td>
          </tr><tr>
            <td class="black">349</td>
            <td>  def apply(idx : Int ) = 
</td>
          </tr><tr>
            <td class="red">350</td>
            <td>    if (<span class="non">idx != (len -1))
</span></td>
          </tr><tr>
            <td class="red">351</td>
            <td>      <span class="non">err
</span></td>
          </tr><tr>
            <td class="black">352</td>
            <td>    else
</td>
          </tr><tr>
            <td class="red">353</td>
            <td>      <span class="non">display0(lo-1).asInstanceOf[A]
</span></td>
          </tr><tr>
            <td class="black">354</td>
            <td>
</td>
          </tr><tr>
            <td class="red">355</td>
            <td>  @inline override def length = <span class="non">len
</span></td>
          </tr><tr>
            <td class="black">356</td>
            <td>  
</td>
          </tr><tr>
            <td class="red">357</td>
            <td>  @inline override def +:[B &gt;: A, That](elem: B)(implicit bf: CanBuildFrom[ImmutableArrayProxy[A], B, That]): That = <span class="non">err
</span></td>
          </tr><tr>
            <td class="black">358</td>
            <td>  
</td>
          </tr><tr>
            <td class="black">359</td>
            <td>  @inline override def :+[B &gt;: A, That](elem: B)(implicit bf: CanBuildFrom[ImmutableArrayProxy[A], B, That]): That = {
</td>
          </tr><tr>
            <td class="green">360</td>
            <td>    if (lo &gt;= display0.length) {
</td>
          </tr><tr>
            <td class="green">361</td>
            <td>      val newBlockIndex = blockIndex+32
</td>
          </tr><tr>
            <td class="green">362</td>
            <td>      gotoNextBlockStartWritable(newBlockIndex, blockIndex ^ newBlockIndex)
</td>
          </tr><tr>
            <td class="green">363</td>
            <td>      blockIndex = newBlockIndex
</td>
          </tr><tr>
            <td class="green">364</td>
            <td>      lo = 0
</td>
          </tr><tr>
            <td class="black">365</td>
            <td>    }
</td>
          </tr><tr>
            <td class="green">366</td>
            <td>    display0(lo) = elem.asInstanceOf[AnyRef]
</td>
          </tr><tr>
            <td class="green">367</td>
            <td>    lo += 1
</td>
          </tr><tr>
            <td class="green">368</td>
            <td>    len += 1
</td>
          </tr><tr>
            <td class="green">369</td>
            <td>    this.asInstanceOf[That]
</td>
          </tr><tr>
            <td class="black">370</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">371</td>
            <td>
</td>
          </tr><tr>
            <td class="black">372</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">373</td>
            <td>   * Basically optimised version for back, hint used directly, one new array creation
</td>
          </tr><tr>
            <td class="black">374</td>
            <td>   */ 
</td>
          </tr><tr>
            <td class="black">375</td>
            <td>  @inline override def updated[B &gt;: A, That](index: Int, elem: B)(implicit bf: CanBuildFrom[ImmutableArrayProxy[A], B, That]): That =
</td>
          </tr><tr>
            <td class="red">376</td>
            <td>    if (<span class="non">index != (len - 1))
</span></td>
          </tr><tr>
            <td class="red">377</td>
            <td>      <span class="non">err
</span></td>
          </tr><tr>
            <td class="black">378</td>
            <td>    else {
</td>
          </tr><tr>
            <td class="red">379</td>
            <td>      <span class="non">display0(lo - 1) = elem.asInstanceOf[AnyRef]
</span></td>
          </tr><tr>
            <td class="red">380</td>
            <td>      <span class="non">this.asInstanceOf[That]
</span></td>
          </tr><tr>
            <td class="black">381</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">382</td>
            <td>
</td>
          </tr><tr>
            <td class="red">383</td>
            <td>  override def iterator() = <span class="non">err
</span></td>
          </tr><tr>
            <td class="black">384</td>
            <td>
</td>
          </tr><tr>
            <td class="red">385</td>
            <td>  def ar = <span class="non">err
</span></td>
          </tr><tr>
            <td class="black">386</td>
            <td>
</td>
          </tr><tr>
            <td class="black">387</td>
            <td>  def immutable : ImmutableArrayProxy[A] = {
</td>
          </tr><tr>
            <td class="green">388</td>
            <td>    val size = len
</td>
          </tr><tr>
            <td class="black">389</td>
            <td>
</td>
          </tr><tr>
            <td class="black">390</td>
            <td>    import scala.annotation.switch  
</td>
          </tr><tr>
            <td class="black">391</td>
            <td>
</td>
          </tr><tr>
            <td class="black">392</td>
            <td>    val res : ImmutableArrayProxy[A] = 
</td>
          </tr><tr>
            <td class="green">393</td>
            <td>      if (len &gt; ImmutableArrayProxyBuilder.vectorAfter) {
</td>
          </tr><tr>
            <td class="green">394</td>
            <td>  if (size == 0)
</td>
          </tr><tr>
            <td class="red">395</td>
            <td>    <span class="non">VectorImpl(Vector.empty)
</span></td>
          </tr><tr>
            <td class="black">396</td>
            <td>  else {
</td>
          </tr><tr>
            <td class="green">397</td>
            <td>    val s = new Vector[A](0, size, 0)
</td>
          </tr><tr>
            <td class="green">398</td>
            <td>    s.initFrom(this)
</td>
          </tr><tr>
            <td class="green">399</td>
            <td>    if (depth &gt; 1) s.gotoPos(0, size - 1 )
</td>
          </tr><tr>
            <td class="black">400</td>
            <td>
</td>
          </tr><tr>
            <td class="green">401</td>
            <td>    VectorImpl(s)
</td>
          </tr><tr>
            <td class="black">402</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">403</td>
            <td>      } else 
</td>
          </tr><tr>
            <td class="green">404</td>
            <td>  (len : @switch) match {
</td>
          </tr><tr>
            <td class="black">405</td>
            <td>    case 0 =&gt; 
</td>
          </tr><tr>
            <td class="green">406</td>
            <td>        ImmutableArrayProxy.emptyImmutableArray.asInstanceOf[ImmutableArray[A]]
</td>
          </tr><tr>
            <td class="black">407</td>
            <td>    case 1 =&gt;
</td>
          </tr><tr>
            <td class="green">408</td>
            <td>      IAOne(display0(0).asInstanceOf[A])
</td>
          </tr><tr>
            <td class="black">409</td>
            <td>    case 2 =&gt;
</td>
          </tr><tr>
            <td class="red">410</td>
            <td>      <span class="non">IATwo(display0(0).asInstanceOf[A], display0(1).asInstanceOf[A])
</span></td>
          </tr><tr>
            <td class="black">411</td>
            <td>    case 3 =&gt;
</td>
          </tr><tr>
            <td class="green">412</td>
            <td>      IAThree(display0(0).asInstanceOf[A], display0(1).asInstanceOf[A], display0(2).asInstanceOf[A])
</td>
          </tr><tr>
            <td class="black">413</td>
            <td>    case _ =&gt; 
</td>
          </tr><tr>
            <td class="green">414</td>
            <td>      if (copyArray) {
</td>
          </tr><tr>
            <td class="green">415</td>
            <td>        val nar = new Array[AnyRef](size)
</td>
          </tr><tr>
            <td class="green">416</td>
            <td>        Array.copy(display0, 0, nar, 0, size)
</td>
          </tr><tr>
            <td class="green">417</td>
            <td>        ImmutableArrayAll[A](nar)
</td>
          </tr><tr>
            <td class="black">418</td>
            <td>      } else
</td>
          </tr><tr>
            <td class="red">419</td>
            <td>        <span class="non">ImmutableArray(display0, 0, size) // bad memory wise but no added cost
</span></td>
          </tr><tr>
            <td class="black">420</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">421</td>
            <td>      
</td>
          </tr><tr>
            <td class="black">422</td>
            <td>    
</td>
          </tr><tr>
            <td class="black">423</td>
            <td>    // wipe this one out
</td>
          </tr><tr>
            <td class="green">424</td>
            <td>    display0 = null.asInstanceOf[Array[AnyRef]]
</td>
          </tr><tr>
            <td class="black">425</td>
            <td>
</td>
          </tr><tr>
            <td class="green">426</td>
            <td>    res
</td>
          </tr><tr>
            <td class="black">427</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">428</td>
            <td>
</td>
          </tr><tr>
            <td class="red">429</td>
            <td>  override def toString() = <span class="non">&quot;MutableVectorLike&quot;
</span></td>
          </tr><tr>
            <td class="black">430</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">431</td>
            <td>
</td>
          </tr><tr>
            <td class="black">432</td>
            <td>}
</td>
          </tr></tbody></table>