<table class="classes"><tbody><tr>
      <td class="barContainerLeft"><a href="#">&#x200B;scales/&#x200B;xml/<span class="header">&#x200B;XmlPaths.scala</span></a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">78 %</div>
        <div class="greenBar" style="width:156px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPaths.scala.html#Class_scales_xml_AttributeParentPath"><img src="class.png"></img>AttributeParentPath</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPaths.scala.html#Class_scales_xml_AttributePath"><img src="class.png"></img>AttributePath</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPaths.scala.html#Class_scales_xml_AttributePathComparisoms"><img src="class.png"></img>AttributePathComparisoms</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPaths.scala.html#Class_scales_xml_XPath"><img src="class.png"></img>XPath</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">64 %</div>
        <div class="greenBar" style="width:128px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPaths.scala.html#Class_scales_xml_XPathInfo"><img src="class.png"></img>XPathInfo</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPaths.scala.html#Class_scales_xml_XmlPathComparisoms"><img src="class.png"></img>XmlPathComparisoms</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPaths.scala.html#Trait_scales_xml_XmlPathImplicits"><img src="trait.png"></img>XmlPathImplicits</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">68 %</div>
        <div class="greenBar" style="width:136px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPaths.scala.html#Trait_scales_xml_XmlPaths"><img src="trait.png"></img>XmlPaths</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPaths.scala.html#Trait_scales_xml_XmlPaths_AttributeAxis"><img src="trait.png"></img>XmlPaths.AttributeAxis</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPaths.scala.html#Class_scales_xml_XmlPaths_AttributeHelpers"><img src="class.png"></img>XmlPaths.AttributeHelpers</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">42 %</div>
        <div class="greenBar" style="width:84px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPaths.scala.html#Object_scales_xml_XmlPaths_Attributes"><img src="object.png"></img>XmlPaths.Attributes</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">66 %</div>
        <div class="greenBar" style="width:132px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPaths.scala.html#Object_scales_xml_XmlPaths_Attributes_Functions"><img src="object.png"></img>XmlPaths.Attributes.Functions</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">71 %</div>
        <div class="greenBar" style="width:142px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPaths.scala.html#Trait_scales_xml_XmlPaths_Axis"><img src="trait.png"></img>XmlPaths.Axis</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">80 %</div>
        <div class="greenBar" style="width:160px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPaths.scala.html#Trait_scales_xml_XmlPaths_ElementStep"><img src="trait.png"></img>XmlPaths.ElementStep</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">95 %</div>
        <div class="greenBar" style="width:190px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPaths.scala.html#Object_scales_xml_XmlPaths_Elements"><img src="object.png"></img>XmlPaths.Elements</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">25 %</div>
        <div class="greenBar" style="width:50px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPaths.scala.html#Object_scales_xml_XmlPaths_Elements_Functions"><img src="object.png"></img>XmlPaths.Elements.Functions</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">83 %</div>
        <div class="greenBar" style="width:166px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPaths.scala.html#Trait_scales_xml_XmlPaths_OtherNodeTypes"><img src="trait.png"></img>XmlPaths.OtherNodeTypes</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">77 %</div>
        <div class="greenBar" style="width:154px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPaths.scala.html#Trait_scales_xml_XmlPaths_SiblingsAxis"><img src="trait.png"></img>XmlPaths.SiblingsAxis</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPaths.scala.html#Object_scales_xml_XmlPaths_TextFunctions"><img src="object.png"></img>XmlPaths.TextFunctions</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">83 %</div>
        <div class="greenBar" style="width:166px;">&nbsp;</div>
      </div>
    </div></td>
    </tr></tbody></table><table class="source"><tbody><tr>
            <td class="black">1</td>
            <td>package scales.xml
</td>
          </tr><tr>
            <td class="black">2</td>
            <td>
</td>
          </tr><tr>
            <td class="black">3</td>
            <td>/** Simple container for keeping relationship between the parent and attribute */
</td>
          </tr><tr>
            <td class="green">4</td>
            <td><a id="Class_scales_xml_AttributePath"></a>case class AttributePath(attribute: Attribute, parent: XmlPath)
</td>
          </tr><tr>
            <td class="black">5</td>
            <td>
</td>
          </tr><tr>
            <td class="green">6</td>
            <td><a id="Class_scales_xml_XmlPathComparisoms"></a>case class XmlPathComparisoms(path: XmlPath) {
</td>
          </tr><tr>
            <td class="green">7</td>
            <td>  def ===(other: String) = Elements.Functions.text(path) == other
</td>
          </tr><tr>
            <td class="black">8</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">9</td>
            <td>
</td>
          </tr><tr>
            <td class="red">10</td>
            <td><a id="Class_scales_xml_AttributePathComparisoms"></a>case class AttributePathComparisoms<span class="non">(path: AttributePath) {
</span></td>
          </tr><tr>
            <td class="red">11</td>
            <td>  def ===(other: String) = <span class="non">Attributes.Functions.text(path) == other
</span></td>
          </tr><tr>
            <td class="black">12</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">13</td>
            <td>
</td>
          </tr><tr>
            <td class="black">14</td>
            <td>import scales.utils._
</td>
          </tr><tr>
            <td class="black">15</td>
            <td><a id="Class_scales_xml_XPathInfo"></a>import scala.collection.generic.CanBuildFrom
</td>
          </tr><tr>
            <td class="black">16</td>
            <td>
</td>
          </tr><tr>
            <td class="black">17</td>
            <td><a id="Trait_scales_xml_XmlPathImplicits"></a>trait XmlPathImplicits {
</td>
          </tr><tr>
            <td class="green">18</td>
            <td>  implicit val samePath: (XmlPath, XmlPath) =&gt; Boolean = comparePaths(_, _)._1 == 0
</td>
          </tr><tr>
            <td class="black">19</td>
            <td>
</td>
          </tr><tr>
            <td class="black">20</td>
            <td>  /** Unpack the attribute from the tuple */
</td>
          </tr><tr>
            <td class="green">21</td>
            <td>  implicit def fromAttrPathToAttribute(attrPath: AttributePath): Attribute = attrPath.attribute
</td>
          </tr><tr>
            <td class="black">22</td>
            <td>
</td>
          </tr><tr>
            <td class="black">23</td>
            <td>  /** By default a List, eager/strict evaluation, is used.  The user of the library can simply choose another collection to wrap the xmlPath */
</td>
          </tr><tr>
            <td class="black">24</td>
            <td>  implicit def fromXmlPathToXPath(xmlPath: XmlPath)(
</td>
          </tr><tr>
            <td class="green">25</td>
            <td>    implicit cbf: CanBuildFrom[List[XmlPath], XmlPath, List[XmlPath]]) = new XPath[List[XmlPath]](
</td>
          </tr><tr>
            <td class="yellow">26</td>
            <td>    XPathInfo(List(List(xmlPath)), initialNode = <span class="non">true), cbf)
</span></td>
          </tr><tr>
            <td class="black">27</td>
            <td>
</td>
          </tr><tr>
            <td class="black">28</td>
            <td>  implicit def fromXPathToIterable[T](xpath: XPath[T]) = {
</td>
          </tr><tr>
            <td class="green">29</td>
            <td>    val nodes = xpath.path.nodes.flatten
</td>
          </tr><tr>
            <td class="green">30</td>
            <td>    DuplicateFilter(sort[XmlItem, Elem, XCC](paths = nodes))(ScalesUtils.sameRef)
</td>
          </tr><tr>
            <td class="black">31</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">32</td>
            <td>
</td>
          </tr><tr>
            <td class="green">33</td>
            <td>  implicit def fromAttributePathToAxis(attrs: Iterable[AttributePath]) = new AttributeParentPath(attrs)
</td>
          </tr><tr>
            <td class="black">34</td>
            <td>
</td>
          </tr><tr>
            <td class="green">35</td>
            <td>  implicit def fromPathToComparisoms(path: XmlPath) = XmlPathComparisoms(path)
</td>
          </tr><tr>
            <td class="black">36</td>
            <td>
</td>
          </tr><tr>
            <td class="red">37</td>
            <td>  implicit def fromAPathToAComparisoms(path: AttributePath) = <span class="non">AttributePathComparisoms(path)
</span></td>
          </tr><tr>
            <td class="black">38</td>
            <td>
</td>
          </tr><tr>
            <td class="green">39</td>
            <td>  implicit def fromAttributesToHelpers(paths: Iterable[AttributePath]) = new AttributeHelpers(paths)
</td>
          </tr><tr>
            <td class="black">40</td>
            <td>
</td>
          </tr><tr>
            <td class="black">41</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">42</td>
            <td>   * Mimic the logic of xpath boolean() through typeclass, see AsBoolean / XmlDSL
</td>
          </tr><tr>
            <td class="black">43</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">44</td>
            <td>
</td>
          </tr><tr>
            <td class="red">45</td>
            <td>  implicit val XPathToBoolean = (x: XPath[_]) =&gt; <span class="non">!x.path.nodes.isEmpty
</span></td>
          </tr><tr>
            <td class="black">46</td>
            <td>
</td>
          </tr><tr>
            <td class="green">47</td>
            <td>  implicit val IterableToBoolean = (x: Iterable[_]) =&gt; !x.isEmpty
</td>
          </tr><tr>
            <td class="black">48</td>
            <td>
</td>
          </tr><tr>
            <td class="red">49</td>
            <td>  implicit val StringToBoolean = (x: String) =&gt; <span class="non">x.length &gt; 0
</span></td>
          </tr><tr>
            <td class="black">50</td>
            <td>
</td>
          </tr><tr>
            <td class="red">51</td>
            <td>  implicit val NumberToBoolean = (x: Number) =&gt; <span class="non">x.longValue() &gt; 0
</span></td>
          </tr><tr>
            <td class="black">52</td>
            <td>
</td>
          </tr><tr>
            <td class="red">53</td>
            <td>  implicit val BooleanToBoolean = (x: Boolean) =&gt; <span class="non">x
</span></td>
          </tr><tr>
            <td class="black">54</td>
            <td>
</td>
          </tr><tr>
            <td class="black">55</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">56</td>
            <td>
</td>
          </tr><tr>
            <td class="black">57</td>
            <td><a id="Trait_scales_xml_XmlPaths"></a>trait XmlPaths {
</td>
          </tr><tr>
            <td class="black">58</td>
            <td>
</td>
          </tr><tr>
            <td class="black">59</td>
            <td>  import ScalesXml._
</td>
          </tr><tr>
            <td class="black">60</td>
            <td>
</td>
          </tr><tr>
            <td class="green">61</td>
            <td>  val isText = (x: XmlPath) =&gt; x.isItem == true &amp;&amp; (x.item().isInstanceOf[Text] || x.item().isInstanceOf[CData])
</td>
          </tr><tr>
            <td class="black">62</td>
            <td>
</td>
          </tr><tr>
            <td class="green">63</td>
            <td><a id="Class_scales_xml_XmlPaths_AttributeHelpers"></a>  class AttributeHelpers(attributes: Iterable[AttributePath]) {
</td>
          </tr><tr>
            <td class="black">64</td>
            <td>    /**
</td>
          </tr><tr>
            <td class="black">65</td>
            <td>     * Some if there is one, else none
</td>
          </tr><tr>
            <td class="black">66</td>
            <td>     */
</td>
          </tr><tr>
            <td class="yellow">67</td>
            <td>    def one: Iterable[AttributePath] = if (attributes.size != 1) List<span class="non">() else </span>List(attributes.head)
</td>
          </tr><tr>
            <td class="black">68</td>
            <td>
</td>
          </tr><tr>
            <td class="black">69</td>
            <td>    /**
</td>
          </tr><tr>
            <td class="black">70</td>
            <td>     * Some if there is one, else calls handler (allows decisions based on more than one etc.
</td>
          </tr><tr>
            <td class="black">71</td>
            <td>     */
</td>
          </tr><tr>
            <td class="red">72</td>
            <td>    def oneOr(handler: Iterable[AttributePath] =&gt; Iterable[AttributePath]) = if (<span class="non">attributes.size == 1) List(attributes.head) else handler(attributes)
</span></td>
          </tr><tr>
            <td class="black">73</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">74</td>
            <td>
</td>
          </tr><tr>
            <td class="black">75</td>
            <td><a id="Object_scales_xml_XmlPaths_Attributes"></a>  object Attributes {
</td>
          </tr><tr>
            <td class="black">76</td>
            <td>
</td>
          </tr><tr>
            <td class="black">77</td>
            <td>    /**
</td>
          </tr><tr>
            <td class="black">78</td>
            <td>     * Note the majority of these functions have an implicit arguement that matches the current context of a given predicate.  This allows:
</td>
          </tr><tr>
            <td class="black">79</td>
            <td>     *
</td>
          </tr><tr>
            <td class="black">80</td>
            <td>     *
</td>
          </tr><tr>
            <td class="black">81</td>
            <td>     */
</td>
          </tr><tr>
            <td class="black">82</td>
            <td><a id="Object_scales_xml_XmlPaths_Attributes_Functions"></a>    object Functions {
</td>
          </tr><tr>
            <td class="black">83</td>
            <td>
</td>
          </tr><tr>
            <td class="black">84</td>
            <td>      /** curried to allow direct drop in for predicates */
</td>
          </tr><tr>
            <td class="green">85</td>
            <td>      def localName(localName: String)(implicit attribute: AttributePath): Boolean = attribute.attribute.name.local == localName
</td>
          </tr><tr>
            <td class="black">86</td>
            <td>
</td>
          </tr><tr>
            <td class="black">87</td>
            <td>      /** curried to allow direct drop in for predicates */
</td>
          </tr><tr>
            <td class="red">88</td>
            <td>      def exact(qname: QName)(implicit attribute: AttributePath): Boolean = <span class="non">attribute.attribute.name === qname
</span></td>
          </tr><tr>
            <td class="black">89</td>
            <td>
</td>
          </tr><tr>
            <td class="black">90</td>
            <td>      /** returns the qname of an AttributePath, using implicit scope */
</td>
          </tr><tr>
            <td class="red">91</td>
            <td>      def qname(implicit attribute: AttributePath): String = <span class="non">attribute.attribute.name.qName
</span></td>
          </tr><tr>
            <td class="black">92</td>
            <td>
</td>
          </tr><tr>
            <td class="black">93</td>
            <td>      /** returns the pqName of an AttributePath, using implicit scope */
</td>
          </tr><tr>
            <td class="green">94</td>
            <td>      def pqName(implicit attribute: AttributePath): String = attribute.attribute.name.pqName
</td>
          </tr><tr>
            <td class="black">95</td>
            <td>
</td>
          </tr><tr>
            <td class="black">96</td>
            <td>      /** returns the value of an AttributePath, using implicit scope */
</td>
          </tr><tr>
            <td class="green">97</td>
            <td>      def value(implicit attribute: AttributePath): String = attribute.attribute.value
</td>
          </tr><tr>
            <td class="black">98</td>
            <td>
</td>
          </tr><tr>
            <td class="black">99</td>
            <td>      /** returns the value of an AttributePath, using implicit scope */
</td>
          </tr><tr>
            <td class="green">100</td>
            <td>      def text(implicit attribute: AttributePath) = value
</td>
          </tr><tr>
            <td class="black">101</td>
            <td>
</td>
          </tr><tr>
            <td class="black">102</td>
            <td>      /** true if the element contains this attribute */
</td>
          </tr><tr>
            <td class="green">103</td>
            <td>      def *@(qName: QName)(implicit path: XmlPath) = path.tree.section.attributes.contains(qName)
</td>
          </tr><tr>
            <td class="black">104</td>
            <td>
</td>
          </tr><tr>
            <td class="black">105</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">106</td>
            <td>
</td>
          </tr><tr>
            <td class="green">107</td>
            <td>    val *@ = (qName: QName) =&gt; (path: XmlPath) =&gt; Functions.*@(qName)(path)
</td>
          </tr><tr>
            <td class="green">108</td>
            <td>    val localName = (l: String) =&gt; (a: AttributePath) =&gt; Functions.localName(l)(a)
</td>
          </tr><tr>
            <td class="red">109</td>
            <td>    val exact = (q: QName) =&gt; (a: AttributePath) =&gt; <span class="non">Functions.exact(q)(a)
</span></td>
          </tr><tr>
            <td class="black">110</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">111</td>
            <td>
</td>
          </tr><tr>
            <td class="black">112</td>
            <td><a id="Object_scales_xml_XmlPaths_TextFunctions"></a>  object TextFunctions {
</td>
          </tr><tr>
            <td class="black">113</td>
            <td>
</td>
          </tr><tr>
            <td class="black">114</td>
            <td>    /**
</td>
          </tr><tr>
            <td class="black">115</td>
            <td>     * Either the value of an XmlItem or the direct text subchildren.
</td>
          </tr><tr>
            <td class="black">116</td>
            <td>     * @param xmlpath
</td>
          </tr><tr>
            <td class="black">117</td>
            <td>     * @return
</td>
          </tr><tr>
            <td class="black">118</td>
            <td>     */
</td>
          </tr><tr>
            <td class="black">119</td>
            <td>    def value(implicit xmlpath: XmlPath) =
</td>
          </tr><tr>
            <td class="green">120</td>
            <td>      if (xmlpath.isItem)
</td>
          </tr><tr>
            <td class="green">121</td>
            <td>        xmlpath.item.value
</td>
          </tr><tr>
            <td class="black">122</td>
            <td>      else
</td>
          </tr><tr>
            <td class="green">123</td>
            <td>        xmlpath.flatMap(x =&gt; if (isText(x)) Some(x.item.value)
</td>
          </tr><tr>
            <td class="red">124</td>
            <td>        else <span class="non">None).addString(new StringBuilder()).toString
</span></td>
          </tr><tr>
            <td class="black">125</td>
            <td>
</td>
          </tr><tr>
            <td class="black">126</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">127</td>
            <td>
</td>
          </tr><tr>
            <td class="black">128</td>
            <td>  /** returns the attributes of a given element */
</td>
          </tr><tr>
            <td class="green">129</td>
            <td>  def attributes( implicit path : XmlPath) : Attributes = path.tree.section.attributes
</td>
          </tr><tr>
            <td class="black">130</td>
            <td>
</td>
          </tr><tr>
            <td class="black">131</td>
            <td>  /** returns the Elem at this path */
</td>
          </tr><tr>
            <td class="green">132</td>
            <td>  def elem( implicit path : XmlPath) : Elem = path.tree.section
</td>
          </tr><tr>
            <td class="black">133</td>
            <td>
</td>
          </tr><tr>
            <td class="black">134</td>
            <td><a id="Object_scales_xml_XmlPaths_Elements"></a>  object Elements {
</td>
          </tr><tr>
            <td class="black">135</td>
            <td>
</td>
          </tr><tr>
            <td class="black">136</td>
            <td>    /**
</td>
          </tr><tr>
            <td class="black">137</td>
            <td>     * Only use these items on XmlPaths that are actual trees, doing otherwise is a runtime exception, if used in XPath predicates then they will always be trees.
</td>
          </tr><tr>
            <td class="black">138</td>
            <td>     *
</td>
          </tr><tr>
            <td class="black">139</td>
            <td>     * Note the majority of these functions have an implicit arguement that matches the current context of a given predicate.  This allows:
</td>
          </tr><tr>
            <td class="black">140</td>
            <td>     *
</td>
          </tr><tr>
            <td class="black">141</td>
            <td>     *
</td>
          </tr><tr>
            <td class="black">142</td>
            <td>     */
</td>
          </tr><tr>
            <td class="black">143</td>
            <td><a id="Object_scales_xml_XmlPaths_Elements_Functions"></a>    object Functions {
</td>
          </tr><tr>
            <td class="black">144</td>
            <td>
</td>
          </tr><tr>
            <td class="black">145</td>
            <td>      /** curried to allow direct drop in for predicates, if it is an item then it will return false */
</td>
          </tr><tr>
            <td class="green">146</td>
            <td>      def localName(localName: String)(implicit path: XmlPath): Boolean = path.tree.section.name.local == localName
</td>
          </tr><tr>
            <td class="black">147</td>
            <td>
</td>
          </tr><tr>
            <td class="black">148</td>
            <td>      /** curried to allow direct drop in for predicates, if it is an item then it will return false */
</td>
          </tr><tr>
            <td class="red">149</td>
            <td>      def exact(qname: QName)(implicit path: XmlPath): Boolean = <span class="non">path.tree.section.name === qname
</span></td>
          </tr><tr>
            <td class="black">150</td>
            <td>
</td>
          </tr><tr>
            <td class="black">151</td>
            <td>      /** returns the localname of an XmlPath, using implicit scope */
</td>
          </tr><tr>
            <td class="green">152</td>
            <td>      def localName(implicit path: XmlPath): String = path.tree.section.name.local
</td>
          </tr><tr>
            <td class="black">153</td>
            <td>
</td>
          </tr><tr>
            <td class="black">154</td>
            <td>      /** returns the qname (pre:local) of an XmlPath, using implicit scope */
</td>
          </tr><tr>
            <td class="red">155</td>
            <td>      def qname(implicit path: XmlPath): String = <span class="non">path.tree.section.name.qName
</span></td>
          </tr><tr>
            <td class="black">156</td>
            <td>
</td>
          </tr><tr>
            <td class="black">157</td>
            <td>      /** returns the qualified name ({namespace}local) of an XmlPath, using implicit scope */
</td>
          </tr><tr>
            <td class="green">158</td>
            <td>      def qualifiedName(implicit path: XmlPath): String = path.tree.section.name.qualifiedName
</td>
          </tr><tr>
            <td class="black">159</td>
            <td>
</td>
          </tr><tr>
            <td class="black">160</td>
            <td>      /** returns the qname of an XmlPath with prefix if defined pre:{ns}qname, using implicit scope */
</td>
          </tr><tr>
            <td class="green">161</td>
            <td>      def pqName(implicit path: XmlPath): String = path.tree.section.name.pqName
</td>
          </tr><tr>
            <td class="black">162</td>
            <td>
</td>
          </tr><tr>
            <td class="black">163</td>
            <td>      /** returns the text of an XmlPath, using implicit scope. Returns all text children joined, does not trim whitespace etc */
</td>
          </tr><tr>
            <td class="black">164</td>
            <td>      def text(implicit path: XmlPath): String = {
</td>
          </tr><tr>
            <td class="green">165</td>
            <td>        path.tree.fold(new StringBuilder()) { (walker, sb) =&gt;
</td>
          </tr><tr>
            <td class="green">166</td>
            <td>          if (walker.isLeft) {
</td>
          </tr><tr>
            <td class="green">167</td>
            <td>            walker.left.get match {
</td>
          </tr><tr>
            <td class="green">168</td>
            <td>              case Text(text) =&gt; sb.append(text)
</td>
          </tr><tr>
            <td class="black">169</td>
            <td>              case _ =&gt; ()
</td>
          </tr><tr>
            <td class="black">170</td>
            <td>            }
</td>
          </tr><tr>
            <td class="black">171</td>
            <td>          }
</td>
          </tr><tr>
            <td class="green">172</td>
            <td>          sb
</td>
          </tr><tr>
            <td class="black">173</td>
            <td>        }.toString
</td>
          </tr><tr>
            <td class="black">174</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">175</td>
            <td>
</td>
          </tr><tr>
            <td class="green">176</td>
            <td>      def normalizeSpace(implicit path: XmlPath) = normalizeSpaceS(text)
</td>
          </tr><tr>
            <td class="black">177</td>
            <td>
</td>
          </tr><tr>
            <td class="black">178</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">179</td>
            <td>
</td>
          </tr><tr>
            <td class="black">180</td>
            <td>    val !! = (f: (XmlPath) =&gt; Boolean) =&gt; (a: XmlPath) =&gt; {
</td>
          </tr><tr>
            <td class="red">181</td>
            <td>      val res = <span class="non">f(a)
</span></td>
          </tr><tr>
            <td class="red">182</td>
            <td>      <span class="non">!res
</span></td>
          </tr><tr>
            <td class="black">183</td>
            <td>    }
</td>
          </tr><tr>
            <td class="green">184</td>
            <td>    val localName = (l: String) =&gt; (a: XmlPath) =&gt; Functions.localName(l)(a)
</td>
          </tr><tr>
            <td class="red">185</td>
            <td>    val exact = (q: QName) =&gt; (a: XmlPath) =&gt; <span class="non">Functions.exact(q)(a)
</span></td>
          </tr><tr>
            <td class="black">186</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">187</td>
            <td>
</td>
          </tr><tr>
            <td class="black">188</td>
            <td><a id="Trait_scales_xml_XmlPaths_Axis"></a>  trait Axis {
</td>
          </tr><tr>
            <td class="black">189</td>
            <td>    type T
</td>
          </tr><tr>
            <td class="black">190</td>
            <td>
</td>
          </tr><tr>
            <td class="black">191</td>
            <td>    val path: XPathInfo
</td>
          </tr><tr>
            <td class="black">192</td>
            <td>
</td>
          </tr><tr>
            <td class="black">193</td>
            <td>    def newThis(xpathInfo: XPathInfo): XPath[T]
</td>
          </tr><tr>
            <td class="black">194</td>
            <td>
</td>
          </tr><tr>
            <td class="black">195</td>
            <td>    def process(nodes: Iterable[Iterable[XmlPath]], performSort: Boolean = path.mustBeSorted, filterDuplicates: Boolean = path.filterDuplicates) = {
</td>
          </tr><tr>
            <td class="black">196</td>
            <td>      /*val potentiallySorted = if (performSort)
</td>
          </tr><tr>
            <td class="black">197</td>
            <td>        nodes //sort[XmlItem, Elem](paths = nodes)
</td>
          </tr><tr>
            <td class="black">198</td>
            <td>      else nodes
</td>
          </tr><tr>
            <td class="black">199</td>
            <td>      val res = if (filterDuplicates)
</td>
          </tr><tr>
            <td class="black">200</td>
            <td>        // remove dups, explicitly use ref instead of same paths
</td>
          </tr><tr>
            <td class="black">201</td>
            <td>        DuplicateFilter(potentiallySorted)(org.scales.utils.DuplicateImplicits.sameRef)
</td>
          </tr><tr>
            <td class="black">202</td>
            <td>      else potentiallySorted
</td>
          </tr><tr>
            <td class="green">203</td>
            <td>      */ newThis(XPathInfo(nodes, performSort, filterDuplicates))
</td>
          </tr><tr>
            <td class="black">204</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">205</td>
            <td>
</td>
          </tr><tr>
            <td class="black">206</td>
            <td>    def empty: Iterable[XmlPath]
</td>
          </tr><tr>
            <td class="black">207</td>
            <td>    def just(only: XmlPath): Iterable[XmlPath]
</td>
          </tr><tr>
            <td class="black">208</td>
            <td>
</td>
          </tr><tr>
            <td class="black">209</td>
            <td>    /**
</td>
          </tr><tr>
            <td class="black">210</td>
            <td>     * 0 index based, not spec, but unsure if it should be
</td>
          </tr><tr>
            <td class="black">211</td>
            <td>     */
</td>
          </tr><tr>
            <td class="black">212</td>
            <td>    def pos(pos: =&gt; Int): XPath[T] =
</td>
          </tr><tr>
            <td class="green">213</td>
            <td>      process {
</td>
          </tr><tr>
            <td class="black">214</td>
            <td>        path.nodes.
</td>
          </tr><tr>
            <td class="black">215</td>
            <td>          flatMap { path =&gt;
</td>
          </tr><tr>
            <td class="green">216</td>
            <td>            val n = path.take(pos)
</td>
          </tr><tr>
            <td class="black">217</td>
            <td>            //val res = 
</td>
          </tr><tr>
            <td class="yellow">218</td>
            <td>            if (n.size != pos) <span class="non">empty
</span></td>
          </tr><tr>
            <td class="green">219</td>
            <td>            else List(just(n.last))
</td>
          </tr><tr>
            <td class="black">220</td>
            <td>            // println (&quot;got path &quot; + path + &quot; n &quot; + n +&quot; res &quot; + res)
</td>
          </tr><tr>
            <td class="black">221</td>
            <td>
</td>
          </tr><tr>
            <td class="black">222</td>
            <td>            //res
</td>
          </tr><tr>
            <td class="black">223</td>
            <td>          }
</td>
          </tr><tr>
            <td class="black">224</td>
            <td>        //  path.nodes.drop(pos).take(1) 
</td>
          </tr><tr>
            <td class="black">225</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">226</td>
            <td>
</td>
          </tr><tr>
            <td class="black">227</td>
            <td>    /** Parents of these paths */
</td>
          </tr><tr>
            <td class="black">228</td>
            <td>    def \^ : XPath[T] =
</td>
          </tr><tr>
            <td class="black">229</td>
            <td>      /* must process dups
</td>
          </tr><tr>
            <td class="black">230</td>
            <td>       * flatten, only each elem should get through anyway
</td>
          </tr><tr>
            <td class="black">231</td>
            <td>       */
</td>
          </tr><tr>
            <td class="green">232</td>
            <td>      process(path.nodes.flatMap { path =&gt;
</td>
          </tr><tr>
            <td class="green">233</td>
            <td>        path.flatMap { x =&gt;
</td>
          </tr><tr>
            <td class="yellow">234</td>
            <td>          if (x.top.isLeft) <span class="non">empty
</span></td>
          </tr><tr>
            <td class="green">235</td>
            <td>          else List(just(x.top.right.get))
</td>
          </tr><tr>
            <td class="black">236</td>
            <td>        }
</td>
          </tr><tr>
            <td class="red">237</td>
            <td>      }, filterDuplicates = <span class="non">true)
</span></td>
          </tr><tr>
            <td class="black">238</td>
            <td>
</td>
          </tr><tr>
            <td class="black">239</td>
            <td>    /** simply forwards the current context, element\item specific versions exist that step downwards in document order */
</td>
          </tr><tr>
            <td class="black">240</td>
            <td>    def \ : XPath[T] =
</td>
          </tr><tr>
            <td class="yellow">241</td>
            <td>      newThis(path.copy(initialNode = <span class="non">false))
</span></td>
          </tr><tr>
            <td class="black">242</td>
            <td>
</td>
          </tr><tr>
            <td class="black">243</td>
            <td>    /**
</td>
          </tr><tr>
            <td class="black">244</td>
            <td>     * all children unpacked, normal xpath requires the context in E1/E2, which hugely complicates things, so \ is this, \+ is \ in the case where unpacking is needed
</td>
          </tr><tr>
            <td class="black">245</td>
            <td>     * which just leavres \* varieties for elements.
</td>
          </tr><tr>
            <td class="black">246</td>
            <td>     */
</td>
          </tr><tr>
            <td class="black">247</td>
            <td>    def \+ : XPath[T] =
</td>
          </tr><tr>
            <td class="green">248</td>
            <td>      process(path.nodes.flatMap {
</td>
          </tr><tr>
            <td class="green">249</td>
            <td>        _.flatMap { child =&gt;
</td>
          </tr><tr>
            <td class="yellow">250</td>
            <td>          if (child.isItem) <span class="non">just(child)
</span></td>
          </tr><tr>
            <td class="green">251</td>
            <td>          else List(child) //: Iterable[XmlPath] 
</td>
          </tr><tr>
            <td class="black">252</td>
            <td>        }
</td>
          </tr><tr>
            <td class="black">253</td>
            <td>      })
</td>
          </tr><tr>
            <td class="black">254</td>
            <td>
</td>
          </tr><tr>
            <td class="black">255</td>
            <td>    /** all descendants */
</td>
          </tr><tr>
            <td class="black">256</td>
            <td>    def \\ : XPath[T] = {
</td>
          </tr><tr>
            <td class="black">257</td>
            <td>      // can't be tail recursive :&lt;
</td>
          </tr><tr>
            <td class="black">258</td>
            <td>      //      @scala.annotation.tailrec
</td>
          </tr><tr>
            <td class="black">259</td>
            <td>      def recUnpack(xmlPath: Iterable[XmlPath]): Iterable[XmlPath] =
</td>
          </tr><tr>
            <td class="green">260</td>
            <td>        xmlPath.flatMap { child =&gt;
</td>
          </tr><tr>
            <td class="green">261</td>
            <td>          if (child.isItem) just(child) else {
</td>
          </tr><tr>
            <td class="black">262</td>
            <td>            // child first then its kids
</td>
          </tr><tr>
            <td class="green">263</td>
            <td>            just(child) ++
</td>
          </tr><tr>
            <td class="black">264</td>
            <td>              recUnpack(child: Iterable[XmlPath])
</td>
          </tr><tr>
            <td class="black">265</td>
            <td>          }
</td>
          </tr><tr>
            <td class="black">266</td>
            <td>        }
</td>
          </tr><tr>
            <td class="black">267</td>
            <td>
</td>
          </tr><tr>
            <td class="green">268</td>
            <td>      process(
</td>
          </tr><tr>
            <td class="green">269</td>
            <td>        (if (path.initialNode) path.nodes // crazy initial expression thing 3.2 in http://www.w3.org/TR/xpath20/#id-path-expressions
</td>
          </tr><tr>
            <td class="green">270</td>
            <td>        else List())
</td>
          </tr><tr>
            <td class="green">271</td>
            <td>          ++ path.nodes.flatMap { recUnpack(_) })
</td>
          </tr><tr>
            <td class="black">272</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">273</td>
            <td>
</td>
          </tr><tr>
            <td class="black">274</td>
            <td>    /** filter through the current matches */
</td>
          </tr><tr>
            <td class="black">275</td>
            <td>    def filter(pred: XmlPath =&gt; Boolean): XPath[T] =
</td>
          </tr><tr>
            <td class="green">276</td>
            <td>      process(path.nodes.flatMap { path =&gt;
</td>
          </tr><tr>
            <td class="green">277</td>
            <td>        val res = path.filter(pred)
</td>
          </tr><tr>
            <td class="green">278</td>
            <td>        if (res.isEmpty) List()
</td>
          </tr><tr>
            <td class="green">279</td>
            <td>        else List(res)
</td>
          </tr><tr>
            <td class="black">280</td>
            <td>      })
</td>
          </tr><tr>
            <td class="black">281</td>
            <td>
</td>
          </tr><tr>
            <td class="black">282</td>
            <td>    /** all children with the given predicate */
</td>
          </tr><tr>
            <td class="black">283</td>
            <td>    def node(pred: XmlPath =&gt; Boolean): XPath[T] =
</td>
          </tr><tr>
            <td class="red">284</td>
            <td>      <span class="non">process(path.nodes.flatMap { x =&gt;
</span></td>
          </tr><tr>
            <td class="red">285</td>
            <td>        <span class="non">x.filter(pred(_))
</span></td>
          </tr><tr>
            <td class="black">286</td>
            <td>      })
</td>
          </tr><tr>
            <td class="black">287</td>
            <td>
</td>
          </tr><tr>
            <td class="black">288</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">289</td>
            <td>
</td>
          </tr><tr>
            <td class="black">290</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">291</td>
            <td>   * Unlike XPath spec no reverse axis are directly provided by the dsl
</td>
          </tr><tr>
            <td class="black">292</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">293</td>
            <td><a id="Trait_scales_xml_XmlPaths_SiblingsAxis"></a>  trait SiblingsAxis extends Axis {
</td>
          </tr><tr>
            <td class="black">294</td>
            <td>
</td>
          </tr><tr>
            <td class="black">295</td>
            <td>    /**
</td>
          </tr><tr>
            <td class="black">296</td>
            <td>     * Unlike XPath spec returns all children in document order
</td>
          </tr><tr>
            <td class="black">297</td>
            <td>     * /
</td>
          </tr><tr>
            <td class="black">298</td>
            <td>     * def preceding_sibling_:: : XPath[T] =
</td>
          </tr><tr>
            <td class="black">299</td>
            <td>     * process(path.nodes.flatMap{ path =&gt;
</td>
          </tr><tr>
            <td class="black">300</td>
            <td>     * // each preceding
</td>
          </tr><tr>
            <td class="black">301</td>
            <td>     * val pos = path.node.index
</td>
          </tr><tr>
            <td class="black">302</td>
            <td>     * path.zipUp.splitAt(pos)._1
</td>
          </tr><tr>
            <td class="black">303</td>
            <td>     * })
</td>
          </tr><tr>
            <td class="black">304</td>
            <td>     *
</td>
          </tr><tr>
            <td class="black">305</td>
            <td>     * def following_sibling_:: : XPath[T] =
</td>
          </tr><tr>
            <td class="black">306</td>
            <td>     * process(path.nodes.flatMap{ path =&gt;
</td>
          </tr><tr>
            <td class="black">307</td>
            <td>     * // each preceding
</td>
          </tr><tr>
            <td class="black">308</td>
            <td>     * val pos = path.node.index
</td>
          </tr><tr>
            <td class="black">309</td>
            <td>     * path.zipUp.splitAt(pos)._2.drop(1)
</td>
          </tr><tr>
            <td class="black">310</td>
            <td>     * })
</td>
          </tr><tr>
            <td class="black">311</td>
            <td>     *
</td>
          </tr><tr>
            <td class="black">312</td>
            <td>     * //filter(_.hasPreviousSibling == false))
</td>
          </tr><tr>
            <td class="black">313</td>
            <td>     */
</td>
          </tr><tr>
            <td class="black">314</td>
            <td>    /**
</td>
          </tr><tr>
            <td class="black">315</td>
            <td>     * predicates are in reverse doc order
</td>
          </tr><tr>
            <td class="black">316</td>
            <td>     */
</td>
          </tr><tr>
            <td class="black">317</td>
            <td>    //def preceding_sibling( pred )
</td>
          </tr><tr>
            <td class="black">318</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">319</td>
            <td>
</td>
          </tr><tr>
            <td class="black">320</td>
            <td>  /** The * and @ must be swapped otherwise its an annotation */
</td>
          </tr><tr>
            <td class="black">321</td>
            <td><a id="Trait_scales_xml_XmlPaths_AttributeAxis"></a>  trait AttributeAxis extends Axis {
</td>
          </tr><tr>
            <td class="black">322</td>
            <td>
</td>
          </tr><tr>
            <td class="black">323</td>
            <td>    /** All immediate attributes */
</td>
          </tr><tr>
            <td class="black">324</td>
            <td>    def *@ : Iterable[AttributePath] =
</td>
          </tr><tr>
            <td class="green">325</td>
            <td>      path.nodes.flatMap {
</td>
          </tr><tr>
            <td class="green">326</td>
            <td>        _.flatMap { child =&gt; // we are looking only for immediate attribs, not kids
</td>
          </tr><tr>
            <td class="green">327</td>
            <td>          if (child.isItem == true) List()
</td>
          </tr><tr>
            <td class="green">328</td>
            <td>          else child.tree.section.attributes.map { x =&gt;
</td>
          </tr><tr>
            <td class="green">329</td>
            <td>            AttributePath(x, child);
</td>
          </tr><tr>
            <td class="black">330</td>
            <td>          }
</td>
          </tr><tr>
            <td class="black">331</td>
            <td>        }
</td>
          </tr><tr>
            <td class="black">332</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">333</td>
            <td>
</td>
          </tr><tr>
            <td class="black">334</td>
            <td>    /** Search for all immediate attributes with a matching predicate (allows localName only searches for example) */
</td>
          </tr><tr>
            <td class="black">335</td>
            <td>    def *@(pred: AttributePath =&gt; Boolean): Iterable[AttributePath] =
</td>
          </tr><tr>
            <td class="green">336</td>
            <td>      *@.filter { pred(_) }
</td>
          </tr><tr>
            <td class="black">337</td>
            <td>
</td>
          </tr><tr>
            <td class="black">338</td>
            <td>    /** Special case for AttributeQNames, only local and namespace match */
</td>
          </tr><tr>
            <td class="black">339</td>
            <td>    def *@[T &lt;% AttributeQName](attrQname: T): Iterable[AttributePath] =
</td>
          </tr><tr>
            <td class="green">340</td>
            <td>      *@({ attributePath: AttributePath =&gt; toQName(attributePath.attribute.name) =:= toQName(attrQname) })
</td>
          </tr><tr>
            <td class="black">341</td>
            <td>
</td>
          </tr><tr>
            <td class="black">342</td>
            <td>    /** Loose match for UnprefixedQNames only, only matches local and namespace */
</td>
          </tr><tr>
            <td class="black">343</td>
            <td>    def *@(qname: UnprefixedQName): Iterable[AttributePath] =
</td>
          </tr><tr>
            <td class="green">344</td>
            <td>      *@({ attributePath: AttributePath =&gt; toQName(attributePath.attribute.name) =:= qname })
</td>
          </tr><tr>
            <td class="black">345</td>
            <td>
</td>
          </tr><tr>
            <td class="black">346</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">347</td>
            <td>
</td>
          </tr><tr>
            <td class="black">348</td>
            <td><a id="Trait_scales_xml_XmlPaths_ElementStep"></a>  trait ElementStep extends Axis {
</td>
          </tr><tr>
            <td class="black">349</td>
            <td>
</td>
          </tr><tr>
            <td class="black">350</td>
            <td>    /** all element children */
</td>
          </tr><tr>
            <td class="black">351</td>
            <td>    private[this] def \*- : XPath[T] =
</td>
          </tr><tr>
            <td class="green">352</td>
            <td>      process(path.nodes.flatMap {
</td>
          </tr><tr>
            <td class="green">353</td>
            <td>        _.flatMap { child =&gt;
</td>
          </tr><tr>
            <td class="yellow">354</td>
            <td>          if (child.isItem) <span class="non">empty
</span></td>
          </tr><tr>
            <td class="green">355</td>
            <td>          else List(child) //: Iterable[XmlPath] 
</td>
          </tr><tr>
            <td class="black">356</td>
            <td>        }
</td>
          </tr><tr>
            <td class="black">357</td>
            <td>      })
</td>
          </tr><tr>
            <td class="black">358</td>
            <td>
</td>
          </tr><tr>
            <td class="black">359</td>
            <td>    /** Search for all immediate child elements with a matching qname */
</td>
          </tr><tr>
            <td class="green">360</td>
            <td>    def *(qname: QName): XPath[T] = filter(x =&gt; x.isItem == false &amp;&amp; qname =:= x.tree.section.name)
</td>
          </tr><tr>
            <td class="black">361</td>
            <td>
</td>
          </tr><tr>
            <td class="green">362</td>
            <td>    def \*(qname: QName): XPath[T] = \*-.*(qname)
</td>
          </tr><tr>
            <td class="black">363</td>
            <td>
</td>
          </tr><tr>
            <td class="black">364</td>
            <td>    /** Search for all immediate child elements matching the predicate*/
</td>
          </tr><tr>
            <td class="green">365</td>
            <td>    def *(pred: XmlPath =&gt; Boolean): XPath[T] = filter(x =&gt; x.isItem == false &amp;&amp; pred(x))
</td>
          </tr><tr>
            <td class="black">366</td>
            <td>
</td>
          </tr><tr>
            <td class="green">367</td>
            <td>    def \*(pred: XmlPath =&gt; Boolean): XPath[T] = \*-.*(pred)
</td>
          </tr><tr>
            <td class="black">368</td>
            <td>
</td>
          </tr><tr>
            <td class="black">369</td>
            <td>    /** Immediate child with position pos, should only be an element. NOTE this will always be evaluated in place and is 1 indexed */
</td>
          </tr><tr>
            <td class="black">370</td>
            <td>    def *(pos: Int): XPath[T] = {
</td>
          </tr><tr>
            <td class="green">371</td>
            <td>      val res = path.nodes.flatMap { path =&gt;
</td>
          </tr><tr>
            <td class="green">372</td>
            <td>        val n = path.filter(_.isItem == false).take(pos)
</td>
          </tr><tr>
            <td class="green">373</td>
            <td>        if (n.size != pos) empty
</td>
          </tr><tr>
            <td class="green">374</td>
            <td>        else List(just(n.last))
</td>
          </tr><tr>
            <td class="black">375</td>
            <td>      }
</td>
          </tr><tr>
            <td class="green">376</td>
            <td>      process(res)
</td>
          </tr><tr>
            <td class="black">377</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">378</td>
            <td>
</td>
          </tr><tr>
            <td class="green">379</td>
            <td>    def \*(pos: Int): XPath[T] = \*-.*(pos)
</td>
          </tr><tr>
            <td class="black">380</td>
            <td>
</td>
          </tr><tr>
            <td class="black">381</td>
            <td>    /** all child elements */
</td>
          </tr><tr>
            <td class="black">382</td>
            <td>    def * : XPath[T] =
</td>
          </tr><tr>
            <td class="green">383</td>
            <td>      filter(_.isItem == false)
</td>
          </tr><tr>
            <td class="black">384</td>
            <td>    //process(path.nodes.flatMap{ _.filter(_.isItem == false) })
</td>
          </tr><tr>
            <td class="black">385</td>
            <td>
</td>
          </tr><tr>
            <td class="green">386</td>
            <td>    def \* : XPath[T] = \*-.*
</td>
          </tr><tr>
            <td class="black">387</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">388</td>
            <td>
</td>
          </tr><tr>
            <td class="black">389</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">390</td>
            <td>   * Little depature from standard, rather than duplicate all of the \ and \\ nodes, just a simple \\*() comment() will do
</td>
          </tr><tr>
            <td class="black">391</td>
            <td>   *
</td>
          </tr><tr>
            <td class="black">392</td>
            <td>   * NOTE these have a large performance hit as the must sort and filter the results in order to get doc order.  Better to use specific nodes
</td>
          </tr><tr>
            <td class="black">393</td>
            <td>   * avoiding \\ etc, then use the s for simple functions, sutext etc for simple useful.  Additionally using the non simple versions incurs the cost
</td>
          </tr><tr>
            <td class="black">394</td>
            <td>   * of adding adjacent text node processing as per standard datamodel (all adjacent text nodes are joined and any resulting nodes that are &quot;the zero-length string&quot; '' are removed).
</td>
          </tr><tr>
            <td class="black">395</td>
            <td>   *
</td>
          </tr><tr>
            <td class="black">396</td>
            <td>   * TODO xpath adjacent text node handling
</td>
          </tr><tr>
            <td class="black">397</td>
            <td>   *
</td>
          </tr><tr>
            <td class="black">398</td>
            <td>   * @author Chris
</td>
          </tr><tr>
            <td class="black">399</td>
            <td>   *
</td>
          </tr><tr>
            <td class="black">400</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">401</td>
            <td><a id="Trait_scales_xml_XmlPaths_OtherNodeTypes"></a>  trait OtherNodeTypes extends Axis {
</td>
          </tr><tr>
            <td class="black">402</td>
            <td>    /** all text child elements - not including cdata nodes, neither sorted nor dup filtered */
</td>
          </tr><tr>
            <td class="black">403</td>
            <td>    def textOnly: XPath[T] =
</td>
          </tr><tr>
            <td class="green">404</td>
            <td>      filter(x =&gt; x.isItem == true &amp;&amp; x.item().isInstanceOf[Text])
</td>
          </tr><tr>
            <td class="black">405</td>
            <td>
</td>
          </tr><tr>
            <td class="black">406</td>
            <td>    /** all text child elements - xpath standard way, including cdata nodes, filtered to join adjacent text nodes */
</td>
          </tr><tr>
            <td class="black">407</td>
            <td>    def text: XPath[T] =
</td>
          </tr><tr>
            <td class="green">408</td>
            <td>      filter(isText)
</td>
          </tr><tr>
            <td class="black">409</td>
            <td>
</td>
          </tr><tr>
            <td class="black">410</td>
            <td>    /** all cdata child elements */
</td>
          </tr><tr>
            <td class="black">411</td>
            <td>    def cdata: XPath[T] =
</td>
          </tr><tr>
            <td class="green">412</td>
            <td>      filter(x =&gt; x.isItem == true &amp;&amp; x.item().isInstanceOf[CData])
</td>
          </tr><tr>
            <td class="black">413</td>
            <td>
</td>
          </tr><tr>
            <td class="black">414</td>
            <td>    /** all commnent child elements */
</td>
          </tr><tr>
            <td class="black">415</td>
            <td>    def comment: XPath[T] =
</td>
          </tr><tr>
            <td class="green">416</td>
            <td>      filter(x =&gt; x.isItem == true &amp;&amp; x.item().isInstanceOf[Comment])
</td>
          </tr><tr>
            <td class="black">417</td>
            <td>
</td>
          </tr><tr>
            <td class="black">418</td>
            <td>    /** all pi child elements */
</td>
          </tr><tr>
            <td class="black">419</td>
            <td>    def pi: XPath[T] =
</td>
          </tr><tr>
            <td class="red">420</td>
            <td>      <span class="non">filter(x =&gt; x.isItem == true &amp;&amp; x.item().isInstanceOf[PI])
</span></td>
          </tr><tr>
            <td class="black">421</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">422</td>
            <td>
</td>
          </tr><tr>
            <td class="black">423</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">424</td>
            <td>
</td>
          </tr><tr>
            <td class="black">425</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">426</td>
            <td> * In contrast to the specs reverse axis are not supported.  This puts
</td>
          </tr><tr>
            <td class="black">427</td>
            <td> * an extra effort on the user for translating, but I don't agree with
</td>
          </tr><tr>
            <td class="black">428</td>
            <td> * the design anyway.  It adds both ambiguity for an embedded dsl:
</td>
          </tr><tr>
            <td class="black">429</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">430</td>
            <td> * //a:ShouldRedeclare/../text()[5]/preceding-sibling::text()[1]
</td>
          </tr><tr>
            <td class="black">431</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">432</td>
            <td> * is in reverse order (above is previousSibling in Path), whereas
</td>
          </tr><tr>
            <td class="black">433</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">434</td>
            <td> * (//a:ShouldRedeclare/../text()[5]/preceding-sibling::text())[1]
</td>
          </tr><tr>
            <td class="black">435</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">436</td>
            <td> * is in doc order (the first text child of the parent).  Such an arbritary decision does nothing but irritate.  A simpler design as found in this implementation is that the user can simply use full scala data functions to reverse as needed.
</td>
          </tr><tr>
            <td class="black">437</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">438</td>
            <td> * (Temptation is to provide the base type as SeqLike instead of Iterable as it should be in a sequence with a defined order, also then providing .reverse and friends)
</td>
          </tr><tr>
            <td class="black">439</td>
            <td> */
</td>
          </tr><tr>
            <td class="green">440</td>
            <td><a id="Class_scales_xml_XPath"></a>class XPath[PT &lt;% Iterable[XmlPath]](val path: XPathInfo, val cbf: CanBuildFrom[PT, XmlPath, PT]) extends ElementStep with OtherNodeTypes with AttributeAxis with SiblingsAxis {
</td>
          </tr><tr>
            <td class="black">441</td>
            <td>
</td>
          </tr><tr>
            <td class="black">442</td>
            <td>  type T = PT
</td>
          </tr><tr>
            <td class="black">443</td>
            <td>
</td>
          </tr><tr>
            <td class="black">444</td>
            <td>  def newThis(xpathInfo: XPathInfo): XPath[T] =
</td>
          </tr><tr>
            <td class="green">445</td>
            <td>    new XPath[T](xpathInfo, cbf)
</td>
          </tr><tr>
            <td class="black">446</td>
            <td>
</td>
          </tr><tr>
            <td class="green">447</td>
            <td>  def empty: Iterable[XmlPath] = cbf().result
</td>
          </tr><tr>
            <td class="green">448</td>
            <td>  def just(only: XmlPath): Iterable[XmlPath] = (cbf() += only).result
</td>
          </tr><tr>
            <td class="black">449</td>
            <td>
</td>
          </tr><tr>
            <td class="black">450</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">451</td>
            <td>   * Allow working within the XPath, easily extend and test
</td>
          </tr><tr>
            <td class="black">452</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">453</td>
            <td>  def in(f: (XPath[T]) =&gt; XPath[T]): XPath[T] =
</td>
          </tr><tr>
            <td class="green">454</td>
            <td>    f(this)
</td>
          </tr><tr>
            <td class="black">455</td>
            <td>
</td>
          </tr><tr>
            <td class="black">456</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">457</td>
            <td>   * Allow working within the XPath, easily extend and test
</td>
          </tr><tr>
            <td class="black">458</td>
            <td>   */
</td>
          </tr><tr>
            <td class="green">459</td>
            <td>  def |&gt;(f: (XPath[T]) =&gt; XPath[T]) = in(f)
</td>
          </tr><tr>
            <td class="black">460</td>
            <td>
</td>
          </tr><tr>
            <td class="black">461</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">462</td>
            <td>   * Some when its only one in the result set
</td>
          </tr><tr>
            <td class="black">463</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">464</td>
            <td>  def one: Iterable[XmlPath] = {
</td>
          </tr><tr>
            <td class="green">465</td>
            <td>    val nodes = ScalesXml.fromXPathToIterable(this)
</td>
          </tr><tr>
            <td class="yellow">466</td>
            <td>    if (nodes.size != 1) List<span class="non">()
</span></td>
          </tr><tr>
            <td class="green">467</td>
            <td>    else List(nodes.head)
</td>
          </tr><tr>
            <td class="black">468</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">469</td>
            <td>
</td>
          </tr><tr>
            <td class="black">470</td>
            <td>  def oneOr(handler: XPath[T] =&gt; Iterable[XmlPath]) = {
</td>
          </tr><tr>
            <td class="red">471</td>
            <td>    val nodes = <span class="non">ScalesXml.fromXPathToIterable(this)
</span></td>
          </tr><tr>
            <td class="red">472</td>
            <td>    if (<span class="non">nodes.size == 1) List(nodes.head)
</span></td>
          </tr><tr>
            <td class="red">473</td>
            <td>    else <span class="non">handler(this)
</span></td>
          </tr><tr>
            <td class="black">474</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">475</td>
            <td>
</td>
          </tr><tr>
            <td class="black">476</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">477</td>
            <td>   * Unions are be merged, sorted and filtered for dups
</td>
          </tr><tr>
            <td class="black">478</td>
            <td>   *
</td>
          </tr><tr>
            <td class="black">479</td>
            <td>   * x | x === x
</td>
          </tr><tr>
            <td class="black">480</td>
            <td>   *
</td>
          </tr><tr>
            <td class="black">481</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">482</td>
            <td>  //    def |( other : Iterable[XmlPath]) : Iterable[XmlPath] = {
</td>
          </tr><tr>
            <td class="black">483</td>
            <td>  //      val paths : Iterable[XmlPath] = xmlPath ++ other
</td>
          </tr><tr>
            <td class="black">484</td>
            <td>  //      sortAndFilter(paths)
</td>
          </tr><tr>
            <td class="black">485</td>
            <td>  //    }
</td>
          </tr><tr>
            <td class="black">486</td>
            <td>
</td>
          </tr><tr>
            <td class="black">487</td>
            <td>  // TODO figure out unions of other paths (namespaces / attributes)
</td>
          </tr><tr>
            <td class="black">488</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">489</td>
            <td>
</td>
          </tr><tr>
            <td class="black">490</td>
            <td>/** Only provides parent axis */
</td>
          </tr><tr>
            <td class="green">491</td>
            <td><a id="Class_scales_xml_AttributeParentPath"></a>class AttributeParentPath(val attributes: Iterable[AttributePath]) {
</td>
          </tr><tr>
            <td class="black">492</td>
            <td>  import ScalesXml._
</td>
          </tr><tr>
            <td class="black">493</td>
            <td>  /** Parents of the attributepaths */
</td>
          </tr><tr>
            <td class="green">494</td>
            <td>  def \^(): Iterable[XmlPath] = DuplicateFilter(attributes.map(_.parent))
</td>
          </tr><tr>
            <td class="black">495</td>
            <td>
</td>
          </tr><tr>
            <td class="black">496</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">497</td>
            <td>
</td>
          </tr><tr>
            <td class="black">498</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">499</td>
            <td> * XPaths need sorting upon unions etc, and duplicate filtering on \^ parents
</td>
          </tr><tr>
            <td class="black">500</td>
            <td> */
</td>
          </tr><tr>
            <td class="green">501</td>
            <td>case class XPathInfo(nodes: Iterable[Iterable[XmlPath]], mustBeSorted: Boolean = false, filterDuplicates: Boolean = false, initialNode: Boolean = false)
</td>
          </tr></tbody></table>