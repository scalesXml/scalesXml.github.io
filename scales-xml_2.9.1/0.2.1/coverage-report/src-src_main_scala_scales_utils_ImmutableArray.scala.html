<table class="classes"><tbody><tr>
      <td class="barContainerLeft"><a href="#">&#x200B;scales/&#x200B;utils/<span class="header">&#x200B;ImmutableArray.scala</span></a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">73 %</div>
        <div class="greenBar" style="width:146px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_ImmutableArray.scala.html#Class_scales_utils_IAEmpty"><img src="class.png"></img>IAEmpty</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">80 %</div>
        <div class="greenBar" style="width:160px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_ImmutableArray.scala.html#Class_scales_utils_IAOne"><img src="class.png"></img>IAOne</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_ImmutableArray.scala.html#Class_scales_utils_IAThree"><img src="class.png"></img>IAThree</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_ImmutableArray.scala.html#Class_scales_utils_IATwo"><img src="class.png"></img>IATwo</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_ImmutableArray.scala.html#Class_scales_utils_ImmutableArray"><img src="class.png"></img>ImmutableArray</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_ImmutableArray.scala.html#Object_scales_utils_ImmutableArray"><img src="object.png"></img>ImmutableArray</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_ImmutableArray.scala.html#Class_scales_utils_ImmutableArrayAll"><img src="class.png"></img>ImmutableArrayAll</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_ImmutableArray.scala.html#Class_scales_utils_ImmutableArrayBuilder"><img src="class.png"></img>ImmutableArrayBuilder</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">89 %</div>
        <div class="greenBar" style="width:178px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_ImmutableArray.scala.html#Class_scales_utils_ImmutableArrayProxy"><img src="class.png"></img>ImmutableArrayProxy</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_ImmutableArray.scala.html#Object_scales_utils_ImmutableArrayProxy"><img src="object.png"></img>ImmutableArrayProxy</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_ImmutableArray.scala.html#Trait_scales_utils_ImmutableArrayProxy"><img src="trait.png"></img>ImmutableArrayProxy</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_ImmutableArray.scala.html#Trait_scales_utils_ImmutableArrayProxy_ImmutableArrayProxyCBF"><img src="trait.png"></img>ImmutableArrayProxy.ImmutableArrayProxyCBF</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">50 %</div>
        <div class="greenBar" style="width:100px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_ImmutableArray.scala.html#Class_scales_utils_ImmutableArrayProxyBuilder"><img src="class.png"></img>ImmutableArrayProxyBuilder</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">75 %</div>
        <div class="greenBar" style="width:150px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_ImmutableArray.scala.html#Object_scales_utils_ImmutableArrayProxyBuilder"><img src="object.png"></img>ImmutableArrayProxyBuilder</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_ImmutableArray.scala.html#Trait_scales_utils_ImmutableArrayT"><img src="trait.png"></img>ImmutableArrayT</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">52 %</div>
        <div class="greenBar" style="width:104px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_ImmutableArray.scala.html#Class_scales_utils_VectorImpl"><img src="class.png"></img>VectorImpl</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">45 %</div>
        <div class="greenBar" style="width:90px;">&nbsp;</div>
      </div>
    </div></td>
    </tr></tbody></table><table class="source"><tbody><tr>
            <td class="black">1</td>
            <td>package scales.utils
</td>
          </tr><tr>
            <td class="black">2</td>
            <td>
</td>
          </tr><tr>
            <td class="black">3</td>
            <td>import collection.{IndexedSeqOptimized, IndexedSeqLike, IndexedSeq}
</td>
          </tr><tr>
            <td class="black">4</td>
            <td>import collection.mutable.Builder //{ArrayBuilder, Builder}
</td>
          </tr><tr>
            <td class="black">5</td>
            <td>import collection.generic.{CanBuildFrom, GenericTraversableTemplate, SeqFactory, GenericCompanion}
</td>
          </tr><tr>
            <td class="black">6</td>
            <td>
</td>
          </tr><tr>
            <td class="black">7</td>
            <td>//import scales.collection.immutable.Vector
</td>
          </tr><tr>
            <td class="black">8</td>
            <td>
</td>
          </tr><tr>
            <td class="black">9</td>
            <td><a id="Object_scales_utils_ImmutableArray"></a>object ImmutableArray {
</td>
          </tr><tr>
            <td class="red">10</td>
            <td>  val emptyImmutableArray = <span class="non">new ImmutableArray[Nothing](Array[AnyRef](),0,0)
</span></td>
          </tr><tr>
            <td class="black">11</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">12</td>
            <td>
</td>
          </tr><tr>
            <td class="black">13</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">14</td>
            <td><a id="Class_scales_utils_ImmutableArrayProxyBuilder"></a><a id="Class_scales_utils_ImmutableArrayBuilder"></a><a id="Object_scales_utils_ImmutableArrayProxyBuilder"></a> * Behaves like an ArrayList/ArrayBuffer, growing an internal array as necessary
</td>
          </tr><tr>
            <td class="black">15</td>
            <td> */
</td>
          </tr><tr>
            <td class="green">16</td>
            <td>case class ImmutableArrayBuilder[ A ]() extends Builder[A, ImmutableArray[A]]{
</td>
          </tr><tr>
            <td class="black">17</td>
            <td>
</td>
          </tr><tr>
            <td class="red">18</td>
            <td>  final val gf = <span class="non">0.10
</span></td>
          </tr><tr>
            <td class="red">19</td>
            <td>  final val gp = <span class="non">0.95
</span></td>
          </tr><tr>
            <td class="black">20</td>
            <td>
</td>
          </tr><tr>
            <td class="black">21</td>
            <td>  def resize( orig : Array[AnyRef], newCapacity : Int, len : Int ) = { 
</td>
          </tr><tr>
            <td class="green">22</td>
            <td>    val ar = Array.ofDim[AnyRef](newCapacity)
</td>
          </tr><tr>
            <td class="green">23</td>
            <td>    if (len != 0)
</td>
          </tr><tr>
            <td class="green">24</td>
            <td>      Array.copy(orig, 0, ar, 0, len)
</td>
          </tr><tr>
            <td class="black">25</td>
            <td>
</td>
          </tr><tr>
            <td class="green">26</td>
            <td>    ar
</td>
          </tr><tr>
            <td class="black">27</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">28</td>
            <td>
</td>
          </tr><tr>
            <td class="black">29</td>
            <td>  var buf : Array[AnyRef] = _
</td>
          </tr><tr>
            <td class="black">30</td>
            <td>  
</td>
          </tr><tr>
            <td class="green">31</td>
            <td>  var len = 0
</td>
          </tr><tr>
            <td class="black">32</td>
            <td>
</td>
          </tr><tr>
            <td class="black">33</td>
            <td>  protected def ensureSize( size : Int ) {
</td>
          </tr><tr>
            <td class="green">34</td>
            <td>    if ((buf eq null) || (size &gt; buf.length))
</td>
          </tr><tr>
            <td class="green">35</td>
            <td>      buf = resize( buf, size, len )
</td>
          </tr><tr>
            <td class="green">36</td>
            <td>    else if (size &gt; (buf.length * gp).toInt) {
</td>
          </tr><tr>
            <td class="green">37</td>
            <td>      buf = resize( buf, buf.length + (buf.length.toDouble * gf).toInt, len )
</td>
          </tr><tr>
            <td class="black">38</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">39</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">40</td>
            <td>
</td>
          </tr><tr>
            <td class="black">41</td>
            <td>  override def sizeHint( size : Int ) {
</td>
          </tr><tr>
            <td class="green">42</td>
            <td>    if ((buf eq null) || size &gt; buf.length) // don't grow unless necessary
</td>
          </tr><tr>
            <td class="green">43</td>
            <td>      buf = resize( buf, size, len )
</td>
          </tr><tr>
            <td class="black">44</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">45</td>
            <td>
</td>
          </tr><tr>
            <td class="black">46</td>
            <td>  def result : ImmutableArray[A] = 
</td>
          </tr><tr>
            <td class="green">47</td>
            <td>    if (len == 0)
</td>
          </tr><tr>
            <td class="red">48</td>
            <td>      <span class="non">ImmutableArray.emptyImmutableArray.asInstanceOf[ImmutableArray[A]]
</span></td>
          </tr><tr>
            <td class="black">49</td>
            <td>    else
</td>
          </tr><tr>
            <td class="green">50</td>
            <td>      ImmutableArray(buf, 0, len)
</td>
          </tr><tr>
            <td class="black">51</td>
            <td>
</td>
          </tr><tr>
            <td class="green">52</td>
            <td>  override def ++=(xs: TraversableOnce[A]): this.type = xs match {
</td>
          </tr><tr>
            <td class="black">53</td>
            <td>    case ImmutableArray( base, offset, slen) =&gt;
</td>
          </tr><tr>
            <td class="green">54</td>
            <td>      ensureSize(len + slen)
</td>
          </tr><tr>
            <td class="green">55</td>
            <td>      Array.copy(base, offset, buf, len, slen)
</td>
          </tr><tr>
            <td class="green">56</td>
            <td>      len += slen
</td>
          </tr><tr>
            <td class="green">57</td>
            <td>      this
</td>
          </tr><tr>
            <td class="black">58</td>
            <td>    case _ =&gt;
</td>
          </tr><tr>
            <td class="green">59</td>
            <td>      super.++=(xs)
</td>
          </tr><tr>
            <td class="black">60</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">61</td>
            <td>
</td>
          </tr><tr>
            <td class="black">62</td>
            <td>  def +=( elem : A) : this.type = {
</td>
          </tr><tr>
            <td class="green">63</td>
            <td>    ensureSize(len + 1)
</td>
          </tr><tr>
            <td class="black">64</td>
            <td>    // we know its big enough
</td>
          </tr><tr>
            <td class="green">65</td>
            <td>    buf(len) = elem.asInstanceOf[AnyRef]
</td>
          </tr><tr>
            <td class="green">66</td>
            <td>    len += 1
</td>
          </tr><tr>
            <td class="green">67</td>
            <td>    this
</td>
          </tr><tr>
            <td class="black">68</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">69</td>
            <td>
</td>
          </tr><tr>
            <td class="black">70</td>
            <td>  def clear() {
</td>
          </tr><tr>
            <td class="green">71</td>
            <td>    len = 0
</td>
          </tr><tr>
            <td class="black">72</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">73</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">74</td>
            <td>
</td>
          </tr><tr>
            <td class="green">75</td>
            <td><a id="Class_scales_utils_IAEmpty"></a>case class IAEmpty[ +A ]() extends ImmutableArrayProxy[A] {
</td>
          </tr><tr>
            <td class="green">76</td>
            <td>  def length = 0
</td>
          </tr><tr>
            <td class="black">77</td>
            <td>
</td>
          </tr><tr>
            <td class="red">78</td>
            <td>  def apply(idx : Int) = <span class="non">error(&quot;Can't return an item, as we are empty&quot;)
</span></td>
          </tr><tr>
            <td class="black">79</td>
            <td>
</td>
          </tr><tr>
            <td class="green">80</td>
            <td>  def ar = this  
</td>
          </tr><tr>
            <td class="black">81</td>
            <td>
</td>
          </tr><tr>
            <td class="black">82</td>
            <td>  @inline override def :+[B &gt;: A, That](elem: B)(implicit bf: CanBuildFrom[ImmutableArrayProxy[A], B, That]): That =
</td>
          </tr><tr>
            <td class="green">83</td>
            <td>    IAOne(elem).asInstanceOf[That]
</td>
          </tr><tr>
            <td class="black">84</td>
            <td>
</td>
          </tr><tr>
            <td class="black">85</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">86</td>
            <td>
</td>
          </tr><tr>
            <td class="green">87</td>
            <td><a id="Class_scales_utils_IAOne"></a>case class IAOne[ +A ]( one : A ) extends ImmutableArrayProxy[A] {
</td>
          </tr><tr>
            <td class="black">88</td>
            <td>
</td>
          </tr><tr>
            <td class="green">89</td>
            <td>  def apply(idx : Int) = one
</td>
          </tr><tr>
            <td class="black">90</td>
            <td>
</td>
          </tr><tr>
            <td class="green">91</td>
            <td>  def length = 1
</td>
          </tr><tr>
            <td class="black">92</td>
            <td>
</td>
          </tr><tr>
            <td class="green">93</td>
            <td>  def ar = this
</td>
          </tr><tr>
            <td class="black">94</td>
            <td>
</td>
          </tr><tr>
            <td class="black">95</td>
            <td>  @inline override def :+[B &gt;: A, That](elem: B)(implicit bf: CanBuildFrom[ImmutableArrayProxy[A], B, That]): That =
</td>
          </tr><tr>
            <td class="green">96</td>
            <td>    IATwo(one, elem).asInstanceOf[That]
</td>
          </tr><tr>
            <td class="black">97</td>
            <td>
</td>
          </tr><tr>
            <td class="black">98</td>
            <td>  @inline override def updated[B &gt;: A, That](index: Int, elem: B)(implicit bf: CanBuildFrom[ImmutableArrayProxy[A], B, That]): That =
</td>
          </tr><tr>
            <td class="green">99</td>
            <td>    IAOne(elem).asInstanceOf[That]
</td>
          </tr><tr>
            <td class="black">100</td>
            <td>
</td>
          </tr><tr>
            <td class="black">101</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">102</td>
            <td>
</td>
          </tr><tr>
            <td class="black">103</td>
            <td>import scala.annotation.switch
</td>
          </tr><tr>
            <td class="black">104</td>
            <td>
</td>
          </tr><tr>
            <td class="green">105</td>
            <td><a id="Class_scales_utils_IATwo"></a>case class IATwo[ +A ]( one : A, two : A ) extends ImmutableArrayProxy[A] {
</td>
          </tr><tr>
            <td class="black">106</td>
            <td>
</td>
          </tr><tr>
            <td class="green">107</td>
            <td>  def apply(idx : Int) = (idx : @switch) match {
</td>
          </tr><tr>
            <td class="green">108</td>
            <td>    case 0 =&gt; one
</td>
          </tr><tr>
            <td class="green">109</td>
            <td>    case 1 =&gt; two
</td>
          </tr><tr>
            <td class="black">110</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">111</td>
            <td>
</td>
          </tr><tr>
            <td class="green">112</td>
            <td>  def length = 2
</td>
          </tr><tr>
            <td class="black">113</td>
            <td>
</td>
          </tr><tr>
            <td class="green">114</td>
            <td>  def ar = this
</td>
          </tr><tr>
            <td class="black">115</td>
            <td>
</td>
          </tr><tr>
            <td class="black">116</td>
            <td>  @inline override def :+[B &gt;: A, That](elem: B)(implicit bf: CanBuildFrom[ImmutableArrayProxy[A], B, That]): That =
</td>
          </tr><tr>
            <td class="green">117</td>
            <td>    IAThree(one, two, elem).asInstanceOf[That]
</td>
          </tr><tr>
            <td class="black">118</td>
            <td>
</td>
          </tr><tr>
            <td class="black">119</td>
            <td>  @inline override def updated[B &gt;: A, That](index: Int, elem: B)(implicit bf: CanBuildFrom[ImmutableArrayProxy[A], B, That]): That =
</td>
          </tr><tr>
            <td class="green">120</td>
            <td>     ((index : @switch) match {
</td>
          </tr><tr>
            <td class="green">121</td>
            <td>       case 0 =&gt; IATwo(elem, two)
</td>
          </tr><tr>
            <td class="green">122</td>
            <td>       case 1 =&gt; IATwo(one, elem)
</td>
          </tr><tr>
            <td class="black">123</td>
            <td>     }).asInstanceOf[That]
</td>
          </tr><tr>
            <td class="black">124</td>
            <td>
</td>
          </tr><tr>
            <td class="black">125</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">126</td>
            <td>
</td>
          </tr><tr>
            <td class="green">127</td>
            <td><a id="Class_scales_utils_IAThree"></a>case class IAThree[ +A ]( one : A, two : A, three : A ) extends ImmutableArrayProxy[A] {
</td>
          </tr><tr>
            <td class="black">128</td>
            <td>
</td>
          </tr><tr>
            <td class="green">129</td>
            <td>  def apply(idx : Int) = (idx : @switch) match {
</td>
          </tr><tr>
            <td class="green">130</td>
            <td>    case 0 =&gt; one
</td>
          </tr><tr>
            <td class="green">131</td>
            <td>    case 1 =&gt; two
</td>
          </tr><tr>
            <td class="green">132</td>
            <td>    case 2 =&gt; three
</td>
          </tr><tr>
            <td class="black">133</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">134</td>
            <td>
</td>
          </tr><tr>
            <td class="green">135</td>
            <td>  def length = 3
</td>
          </tr><tr>
            <td class="black">136</td>
            <td>
</td>
          </tr><tr>
            <td class="green">137</td>
            <td>  def ar = this
</td>
          </tr><tr>
            <td class="black">138</td>
            <td>
</td>
          </tr><tr>
            <td class="black">139</td>
            <td>  @inline override def updated[B &gt;: A, That](index: Int, elem: B)(implicit bf: CanBuildFrom[ImmutableArrayProxy[A], B, That]): That =
</td>
          </tr><tr>
            <td class="green">140</td>
            <td>     ((index : @switch) match {
</td>
          </tr><tr>
            <td class="green">141</td>
            <td>       case 0 =&gt; IAThree(elem, two, three)
</td>
          </tr><tr>
            <td class="green">142</td>
            <td>       case 1 =&gt; IAThree(one, elem, three)
</td>
          </tr><tr>
            <td class="green">143</td>
            <td>       case 2 =&gt; IAThree(one, two, elem)
</td>
          </tr><tr>
            <td class="black">144</td>
            <td>     }).asInstanceOf[That]
</td>
          </tr><tr>
            <td class="black">145</td>
            <td>
</td>
          </tr><tr>
            <td class="black">146</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">147</td>
            <td>
</td>
          </tr><tr>
            <td class="black">148</td>
            <td>
</td>
          </tr><tr>
            <td class="black">149</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">150</td>
            <td> * Object arrays are just faster, System.arraycopy doesn't trust you and will type check everything, we can let nsc do that job for us.
</td>
          </tr><tr>
            <td class="black">151</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">152</td>
            <td> * Same as ImmutableArray but for when the base is the entire collection, no offset or len are then needed
</td>
          </tr><tr>
            <td class="black">153</td>
            <td> */ 
</td>
          </tr><tr>
            <td class="black">154</td>
            <td><a id="Trait_scales_utils_ImmutableArrayT"></a>trait ImmutableArrayT[ +A ] extends ImmutableArrayProxy[A] {
</td>
          </tr><tr>
            <td class="black">155</td>
            <td>  val base : Array[AnyRef]
</td>
          </tr><tr>
            <td class="black">156</td>
            <td>  def offset : Int
</td>
          </tr><tr>
            <td class="black">157</td>
            <td>  def len : Int
</td>
          </tr><tr>
            <td class="black">158</td>
            <td>
</td>
          </tr><tr>
            <td class="black">159</td>
            <td>  import ImmutableArrayProxyBuilder._
</td>
          </tr><tr>
            <td class="black">160</td>
            <td>
</td>
          </tr><tr>
            <td class="green">161</td>
            <td>  def apply(idx : Int ) = base(idx + offset).asInstanceOf[A]
</td>
          </tr><tr>
            <td class="black">162</td>
            <td> 
</td>
          </tr><tr>
            <td class="green">163</td>
            <td>  def length = len
</td>
          </tr><tr>
            <td class="black">164</td>
            <td>  
</td>
          </tr><tr>
            <td class="black">165</td>
            <td>  @inline override def +:[B &gt;: A, That](elem: B)(implicit bf: CanBuildFrom[ImmutableArrayProxy[A], B, That]): That =
</td>
          </tr><tr>
            <td class="red">166</td>
            <td>    (<span class="non">if (len == vectorAfter) super.+:(elem)
</span></td>
          </tr><tr>
            <td class="black">167</td>
            <td>    else {
</td>
          </tr><tr>
            <td class="red">168</td>
            <td>      val ar = <span class="non">Array.ofDim[AnyRef](len+1)
</span></td>
          </tr><tr>
            <td class="red">169</td>
            <td>      <span class="non">Array.copy(base, offset, ar, 1, len)
</span></td>
          </tr><tr>
            <td class="red">170</td>
            <td>      <span class="non">ar(0) = elem.asInstanceOf[AnyRef]
</span></td>
          </tr><tr>
            <td class="red">171</td>
            <td>      ImmutableArrayAll<span class="non">[B](ar)
</span></td>
          </tr><tr>
            <td class="black">172</td>
            <td>    }).asInstanceOf[That]
</td>
          </tr><tr>
            <td class="black">173</td>
            <td>  
</td>
          </tr><tr>
            <td class="black">174</td>
            <td>  @inline override def :+[B &gt;: A, That](elem: B)(implicit bf: CanBuildFrom[ImmutableArrayProxy[A], B, That]): That =
</td>
          </tr><tr>
            <td class="green">175</td>
            <td>    (if (len == vectorAfter) super.:+(elem)
</td>
          </tr><tr>
            <td class="black">176</td>
            <td>    else {
</td>
          </tr><tr>
            <td class="green">177</td>
            <td>      val ar = Array.ofDim[AnyRef](len+1)
</td>
          </tr><tr>
            <td class="green">178</td>
            <td>      Array.copy(base, offset, ar, 0, len)
</td>
          </tr><tr>
            <td class="green">179</td>
            <td>      ar(len) = elem.asInstanceOf[AnyRef]
</td>
          </tr><tr>
            <td class="green">180</td>
            <td>      ImmutableArrayAll[B](ar)
</td>
          </tr><tr>
            <td class="black">181</td>
            <td>    }).asInstanceOf[That]
</td>
          </tr><tr>
            <td class="black">182</td>
            <td>
</td>
          </tr><tr>
            <td class="black">183</td>
            <td>  @inline override def take( n : Int ) = 
</td>
          </tr><tr>
            <td class="yellow">184</td>
            <td>    ImmutableArray(base, offset, if (len - n &lt; 0) <span class="non">len else </span>n)
</td>
          </tr><tr>
            <td class="black">185</td>
            <td>
</td>
          </tr><tr>
            <td class="black">186</td>
            <td>  @inline override def drop( n : Int ) = 
</td>
          </tr><tr>
            <td class="yellow">187</td>
            <td>    ImmutableArray(base, offset + n, if (len - n &lt; 0) <span class="non">0 else (</span>len - n))
</td>
          </tr><tr>
            <td class="black">188</td>
            <td>
</td>
          </tr><tr>
            <td class="green">189</td>
            <td>  @inline override def tail = drop(1)
</td>
          </tr><tr>
            <td class="black">190</td>
            <td>
</td>
          </tr><tr>
            <td class="black">191</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">192</td>
            <td>   * we can do better - slice used by many functions in Optimized
</td>
          </tr><tr>
            <td class="black">193</td>
            <td>   */ 
</td>
          </tr><tr>
            <td class="black">194</td>
            <td>  @inline override def slice(from: Int, until: Int) = {
</td>
          </tr><tr>
            <td class="green">195</td>
            <td>    val lo    = math.max(from, 0)
</td>
          </tr><tr>
            <td class="green">196</td>
            <td>    val hi    = math.min(until, len)
</td>
          </tr><tr>
            <td class="green">197</td>
            <td>    val elems = math.max(hi - lo, 0)
</td>
          </tr><tr>
            <td class="green">198</td>
            <td>    ImmutableArray(base, offset, elems)
</td>
          </tr><tr>
            <td class="black">199</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">200</td>
            <td>
</td>
          </tr><tr>
            <td class="black">201</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">202</td>
            <td>   * Basically optimised version for back, hint used directly, one new array creation
</td>
          </tr><tr>
            <td class="black">203</td>
            <td>   */ 
</td>
          </tr><tr>
            <td class="black">204</td>
            <td>  override def updated[B &gt;: A, That](index: Int, elem: B)(implicit bf: CanBuildFrom[ImmutableArrayProxy[A], B, That]): That =
</td>
          </tr><tr>
            <td class="green">205</td>
            <td>    if (bf.isInstanceOf[ImmutableArrayProxy.ImmutableArrayProxyCBF[_]]) {
</td>
          </tr><tr>
            <td class="black">206</td>
            <td>      // we know its objects underneath, we know the relationship is sound
</td>
          </tr><tr>
            <td class="green">207</td>
            <td>      val ar = Array.ofDim[AnyRef](len)
</td>
          </tr><tr>
            <td class="green">208</td>
            <td>      Array.copy(base, offset, ar, 0, len)
</td>
          </tr><tr>
            <td class="green">209</td>
            <td>      ar(index) = elem.asInstanceOf[AnyRef]
</td>
          </tr><tr>
            <td class="green">210</td>
            <td>      ImmutableArrayAll[B](ar).asInstanceOf[That]
</td>
          </tr><tr>
            <td class="black">211</td>
            <td>    } else {
</td>
          </tr><tr>
            <td class="red">212</td>
            <td>      val b = <span class="non">bf(repr)
</span></td>
          </tr><tr>
            <td class="red">213</td>
            <td>      val (<span class="non">prefix, rest) = this.splitAt(index)
</span></td>
          </tr><tr>
            <td class="red">214</td>
            <td>      <span class="non">b.sizeHint(len)
</span></td>
          </tr><tr>
            <td class="red">215</td>
            <td>      <span class="non">b ++= toCollection(prefix)
</span></td>
          </tr><tr>
            <td class="red">216</td>
            <td>      <span class="non">b += elem
</span></td>
          </tr><tr>
            <td class="red">217</td>
            <td>      <span class="non">b ++= toCollection(rest.tail)
</span></td>
          </tr><tr>
            <td class="red">218</td>
            <td>      <span class="non">b.result()
</span></td>
          </tr><tr>
            <td class="black">219</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">220</td>
            <td>
</td>
          </tr><tr>
            <td class="black">221</td>
            <td>  override def toArray[U &gt;: A : ClassManifest]: Array[U] =
</td>
          </tr><tr>
            <td class="red">222</td>
            <td>    if (<span class="non">implicitly[ClassManifest[U]].erasure eq base.getClass.getComponentType) {
</span></td>
          </tr><tr>
            <td class="red">223</td>
            <td>      if ((<span class="non">offset == 0) &amp;&amp; (len == base.length))
</span></td>
          </tr><tr>
            <td class="red">224</td>
            <td>  <span class="non">base.asInstanceOf[Array[U]]
</span></td>
          </tr><tr>
            <td class="black">225</td>
            <td>      else {
</td>
          </tr><tr>
            <td class="red">226</td>
            <td>  val ar = <span class="non">Array.ofDim[U](len)
</span></td>
          </tr><tr>
            <td class="red">227</td>
            <td>  <span class="non">Array.copy(base, offset, ar, 0, len)
</span></td>
          </tr><tr>
            <td class="red">228</td>
            <td>  <span class="non">ar  
</span></td>
          </tr><tr>
            <td class="black">229</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">230</td>
            <td>    } else 
</td>
          </tr><tr>
            <td class="red">231</td>
            <td>      <span class="non">super.toArray[U]
</span></td>
          </tr><tr>
            <td class="black">232</td>
            <td>
</td>
          </tr><tr>
            <td class="black">233</td>
            <td>
</td>
          </tr><tr>
            <td class="green">234</td>
            <td>  def ar = this
</td>
          </tr><tr>
            <td class="black">235</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">236</td>
            <td>
</td>
          </tr><tr>
            <td class="black">237</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">238</td>
            <td> * Don't add the offset and length, for building a dom this save 8 per elem, only matters for large docs (can save 4mb from 54mb), but can't hurt small ones.
</td>
          </tr><tr>
            <td class="black">239</td>
            <td> */ 
</td>
          </tr><tr>
            <td class="green">240</td>
            <td><a id="Class_scales_utils_ImmutableArrayAll"></a>case class ImmutableArrayAll[ +A ]( base : Array[AnyRef]) extends ImmutableArrayT[A] {
</td>
          </tr><tr>
            <td class="green">241</td>
            <td>  @inline final def offset = 0
</td>
          </tr><tr>
            <td class="green">242</td>
            <td>  @inline final def len = base.length
</td>
          </tr><tr>
            <td class="green">243</td>
            <td>  @inline final override def length = base.length
</td>
          </tr><tr>
            <td class="black">244</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">245</td>
            <td>
</td>
          </tr><tr>
            <td class="black">246</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">247</td>
            <td> * Object arrays are just faster, System.arraycopy doesn't trust you and will type check everything, we can let nsc do that job for us.
</td>
          </tr><tr>
            <td class="black">248</td>
            <td> */ 
</td>
          </tr><tr>
            <td class="green">249</td>
            <td><a id="Class_scales_utils_ImmutableArray"></a>case class ImmutableArray[ +A ]( base : Array[AnyRef], offset : Int, len : Int) extends ImmutableArrayT[A]
</td>
          </tr><tr>
            <td class="black">250</td>
            <td>
</td>
          </tr><tr>
            <td class="black">251</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">252</td>
            <td> * Starts an ImmutableArrayProxy and provides the CanBuildFrom
</td>
          </tr><tr>
            <td class="black">253</td>
            <td> */ 
</td>
          </tr><tr>
            <td class="black">254</td>
            <td><a id="Object_scales_utils_ImmutableArrayProxy"></a>object ImmutableArrayProxy extends SeqFactory[ImmutableArrayProxy] {
</td>
          </tr><tr>
            <td class="green">255</td>
            <td>  val emptyImmutableArray = IAEmpty[Nothing]()
</td>
          </tr><tr>
            <td class="black">256</td>
            <td>    //new ImmutableArray[Nothing](Array[AnyRef](),0,0)
</td>
          </tr><tr>
            <td class="black">257</td>
            <td>
</td>
          </tr><tr>
            <td class="green">258</td>
            <td>  @inline final override def empty[ A ] : ImmutableArrayProxy[A]  = emptyImmutableArray.asInstanceOf[ImmutableArrayProxy[A]]
</td>
          </tr><tr>
            <td class="black">259</td>
            <td>
</td>
          </tr><tr>
            <td class="black">260</td>
            <td>  @inline def newBuilder[A]
</td>
          </tr><tr>
            <td class="black">261</td>
            <td>  : Builder[A, ImmutableArrayProxy[A]] =
</td>
          </tr><tr>
            <td class="green">262</td>
            <td>    ImmutableArrayProxyBuilder()
</td>
          </tr><tr>
            <td class="black">263</td>
            <td>  
</td>
          </tr><tr>
            <td class="green">264</td>
            <td><a id="Class_scales_utils_ImmutableArrayProxy"></a>  @inline implicit def canBuildFrom[T](implicit ma: ClassManifest[T]): CanBuildFrom[ImmutableArrayProxy[_], T, ImmutableArrayProxy[T]] = new ImmutableArrayProxyCBF[T]{ val m = ma }
</td>
          </tr><tr>
            <td class="black">265</td>
            <td>
</td>
          </tr><tr>
            <td class="black">266</td>
            <td><a id="Trait_scales_utils_ImmutableArrayProxy_ImmutableArrayProxyCBF"></a>  trait ImmutableArrayProxyCBF[T] extends CanBuildFrom[ImmutableArrayProxy[_], T, ImmutableArrayProxy[T]] {
</td>
          </tr><tr>
            <td class="black">267</td>
            <td>    
</td>
          </tr><tr>
            <td class="black">268</td>
            <td>    val m : ClassManifest[T]
</td>
          </tr><tr>
            <td class="black">269</td>
            <td>
</td>
          </tr><tr>
            <td class="green">270</td>
            <td>    def apply(from: ImmutableArrayProxy[_]): Builder[T, ImmutableArrayProxy[T]] = newBuilder
</td>
          </tr><tr>
            <td class="red">271</td>
            <td>    def apply: Builder[T, ImmutableArrayProxy[T]] = <span class="non">newBuilder
</span></td>
          </tr><tr>
            <td class="black">272</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">273</td>
            <td>    
</td>
          </tr><tr>
            <td class="black">274</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">275</td>
            <td>
</td>
          </tr><tr>
            <td class="black">276</td>
            <td>object ImmutableArrayProxyBuilder {
</td>
          </tr><tr>
            <td class="red">277</td>
            <td>  final val vectorAfter = <span class="non">31
</span></td>
          </tr><tr>
            <td class="black">278</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">279</td>
            <td>
</td>
          </tr><tr>
            <td class="black">280</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">281</td>
            <td> * An attempt to be a little more efficient with ImmutableArray, should make up for update not working?
</td>
          </tr><tr>
            <td class="black">282</td>
            <td> */
</td>
          </tr><tr>
            <td class="green">283</td>
            <td>case class ImmutableArrayProxyBuilder[ A ]() extends Builder[A, ImmutableArrayProxy[A]]{
</td>
          </tr><tr>
            <td class="black">284</td>
            <td>  import ImmutableArrayProxyBuilder._
</td>
          </tr><tr>
            <td class="black">285</td>
            <td>
</td>
          </tr><tr>
            <td class="green">286</td>
            <td>  lazy val arrayBuilder = new ImmutableArrayBuilder[A]()
</td>
          </tr><tr>
            <td class="green">287</td>
            <td>  lazy val vectorBuilder = Vector.newBuilder[A]
</td>
          </tr><tr>
            <td class="black">288</td>
            <td>  
</td>
          </tr><tr>
            <td class="green">289</td>
            <td>  var inVector = false
</td>
          </tr><tr>
            <td class="green">290</td>
            <td>  var haveChosen = false
</td>
          </tr><tr>
            <td class="black">291</td>
            <td>
</td>
          </tr><tr>
            <td class="black">292</td>
            <td>  override def sizeHint( size : Int ) {
</td>
          </tr><tr>
            <td class="green">293</td>
            <td>    if (size &gt; vectorAfter) {
</td>
          </tr><tr>
            <td class="red">294</td>
            <td>      <span class="non">inVector = true
</span></td>
          </tr><tr>
            <td class="red">295</td>
            <td>      <span class="non">haveChosen = true
</span></td>
          </tr><tr>
            <td class="black">296</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">297</td>
            <td>
</td>
          </tr><tr>
            <td class="green">298</td>
            <td>    if (inVector) {
</td>
          </tr><tr>
            <td class="red">299</td>
            <td>      <span class="non">vectorBuilder.sizeHint(size)
</span></td>
          </tr><tr>
            <td class="black">300</td>
            <td>    } else {
</td>
          </tr><tr>
            <td class="green">301</td>
            <td>      arrayBuilder.sizeHint(size)
</td>
          </tr><tr>
            <td class="black">302</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">303</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">304</td>
            <td>
</td>
          </tr><tr>
            <td class="black">305</td>
            <td>  // for the case when we were under 32 but are now over
</td>
          </tr><tr>
            <td class="black">306</td>
            <td>  protected def checkVB() {
</td>
          </tr><tr>
            <td class="green">307</td>
            <td>    if (!inVector) {
</td>
          </tr><tr>
            <td class="green">308</td>
            <td>      if (arrayBuilder.len &gt; vectorAfter) {
</td>
          </tr><tr>
            <td class="green">309</td>
            <td>  moveToVector
</td>
          </tr><tr>
            <td class="black">310</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">311</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">312</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">313</td>
            <td>
</td>
          </tr><tr>
            <td class="black">314</td>
            <td>  protected def moveToVector() {
</td>
          </tr><tr>
            <td class="black">315</td>
            <td>    // copy over
</td>
          </tr><tr>
            <td class="green">316</td>
            <td>    val r = arrayBuilder.result
</td>
          </tr><tr>
            <td class="green">317</td>
            <td>    vectorBuilder.sizeHint(r.len)
</td>
          </tr><tr>
            <td class="green">318</td>
            <td>    vectorBuilder.++=(r)
</td>
          </tr><tr>
            <td class="green">319</td>
            <td>    arrayBuilder.clear
</td>
          </tr><tr>
            <td class="green">320</td>
            <td>    inVector = true
</td>
          </tr><tr>
            <td class="green">321</td>
            <td>    haveChosen = true
</td>
          </tr><tr>
            <td class="black">322</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">323</td>
            <td>
</td>
          </tr><tr>
            <td class="black">324</td>
            <td>  def result : ImmutableArrayProxy[A] =
</td>
          </tr><tr>
            <td class="green">325</td>
            <td>    if (inVector) VectorImpl(vectorBuilder.result)
</td>
          </tr><tr>
            <td class="black">326</td>
            <td>    else { // do it here as this is the correct type
</td>
          </tr><tr>
            <td class="black">327</td>
            <td>      import arrayBuilder.{buf, len}
</td>
          </tr><tr>
            <td class="black">328</td>
            <td>      import scala.annotation.switch  
</td>
          </tr><tr>
            <td class="black">329</td>
            <td>
</td>
          </tr><tr>
            <td class="green">330</td>
            <td>      (len : @switch) match {
</td>
          </tr><tr>
            <td class="black">331</td>
            <td>  case 0 =&gt;
</td>
          </tr><tr>
            <td class="green">332</td>
            <td>    ImmutableArrayProxy.emptyImmutableArray.asInstanceOf[ImmutableArrayProxy[A]]
</td>
          </tr><tr>
            <td class="black">333</td>
            <td>  case 1 =&gt; //TODO this is way too much like optimisation strategy..
</td>
          </tr><tr>
            <td class="green">334</td>
            <td>    IAOne(buf(0).asInstanceOf[A])
</td>
          </tr><tr>
            <td class="black">335</td>
            <td>  case 2 =&gt;
</td>
          </tr><tr>
            <td class="green">336</td>
            <td>    IATwo(buf(0).asInstanceOf[A], buf(1).asInstanceOf[A])
</td>
          </tr><tr>
            <td class="black">337</td>
            <td>  case 3 =&gt;
</td>
          </tr><tr>
            <td class="green">338</td>
            <td>    IAThree(buf(0).asInstanceOf[A], buf(1).asInstanceOf[A], buf(2).asInstanceOf[A])
</td>
          </tr><tr>
            <td class="black">339</td>
            <td>  case _ =&gt; 
</td>
          </tr><tr>
            <td class="green">340</td>
            <td>    if (len != 0 &amp;&amp; len == buf.length)
</td>
          </tr><tr>
            <td class="green">341</td>
            <td>      ImmutableArrayAll[A](buf)
</td>
          </tr><tr>
            <td class="black">342</td>
            <td>    else
</td>
          </tr><tr>
            <td class="green">343</td>
            <td>      arrayBuilder.result
</td>
          </tr><tr>
            <td class="black">344</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">345</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">346</td>
            <td>
</td>
          </tr><tr>
            <td class="black">347</td>
            <td>  override def ++=(xs: TraversableOnce[A]): this.type = {
</td>
          </tr><tr>
            <td class="black">348</td>
            <td>    // if its already a vector don't start with arrays again
</td>
          </tr><tr>
            <td class="green">349</td>
            <td>    if (!haveChosen &amp;&amp; xs.isInstanceOf[VectorImpl[A]]) {
</td>
          </tr><tr>
            <td class="red">350</td>
            <td>      <span class="non">inVector = true
</span></td>
          </tr><tr>
            <td class="red">351</td>
            <td>      <span class="non">haveChosen = true
</span></td>
          </tr><tr>
            <td class="black">352</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">353</td>
            <td>    
</td>
          </tr><tr>
            <td class="green">354</td>
            <td>    xs match {
</td>
          </tr><tr>
            <td class="black">355</td>
            <td>      case p : ImmutableArrayProxy[A] =&gt; 
</td>
          </tr><tr>
            <td class="green">356</td>
            <td>  if (inVector) 
</td>
          </tr><tr>
            <td class="red">357</td>
            <td>    <span class="non">vectorBuilder.++=(p.ar) 
</span></td>
          </tr><tr>
            <td class="black">358</td>
            <td>  else
</td>
          </tr><tr>
            <td class="green">359</td>
            <td>    arrayBuilder.++=(p.ar)
</td>
          </tr><tr>
            <td class="black">360</td>
            <td>      case _ =&gt; 
</td>
          </tr><tr>
            <td class="green">361</td>
            <td>  if (inVector)
</td>
          </tr><tr>
            <td class="red">362</td>
            <td>    <span class="non">vectorBuilder.++=(xs)
</span></td>
          </tr><tr>
            <td class="black">363</td>
            <td>  else
</td>
          </tr><tr>
            <td class="green">364</td>
            <td>    arrayBuilder.++=(xs)
</td>
          </tr><tr>
            <td class="black">365</td>
            <td>    }      
</td>
          </tr><tr>
            <td class="black">366</td>
            <td>
</td>
          </tr><tr>
            <td class="green">367</td>
            <td>    checkVB
</td>
          </tr><tr>
            <td class="green">368</td>
            <td>    this
</td>
          </tr><tr>
            <td class="black">369</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">370</td>
            <td>
</td>
          </tr><tr>
            <td class="black">371</td>
            <td>  def +=( elem : A) : this.type =
</td>
          </tr><tr>
            <td class="green">372</td>
            <td>    if (inVector) {
</td>
          </tr><tr>
            <td class="red">373</td>
            <td>      <span class="non">vectorBuilder.+=(elem)
</span></td>
          </tr><tr>
            <td class="red">374</td>
            <td>      <span class="non">this
</span></td>
          </tr><tr>
            <td class="black">375</td>
            <td>    } else {
</td>
          </tr><tr>
            <td class="green">376</td>
            <td>      arrayBuilder.+=(elem)
</td>
          </tr><tr>
            <td class="green">377</td>
            <td>      checkVB
</td>
          </tr><tr>
            <td class="green">378</td>
            <td>      this
</td>
          </tr><tr>
            <td class="black">379</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">380</td>
            <td>
</td>
          </tr><tr>
            <td class="black">381</td>
            <td>  def clear() {
</td>
          </tr><tr>
            <td class="red">382</td>
            <td>    <span class="non">vectorBuilder.clear
</span></td>
          </tr><tr>
            <td class="red">383</td>
            <td>    <span class="non">arrayBuilder.clear
</span></td>
          </tr><tr>
            <td class="red">384</td>
            <td>    <span class="non">inVector = false
</span></td>
          </tr><tr>
            <td class="red">385</td>
            <td>    <span class="non">haveChosen = false
</span></td>
          </tr><tr>
            <td class="black">386</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">387</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">388</td>
            <td>
</td>
          </tr><tr>
            <td class="black">389</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">390</td>
            <td> * Wraps behaviour of ImmutableArray like objects, when the array is greater than 31 it will be swapped to Vector.
</td>
          </tr><tr>
            <td class="black">391</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">392</td>
            <td> */ 
</td>
          </tr><tr>
            <td class="black">393</td>
            <td><a id="Trait_scales_utils_ImmutableArrayProxy"></a>trait ImmutableArrayProxy[+A] extends IndexedSeq[A] with IndexedSeqOptimized[A, ImmutableArrayProxy[A]] with GenericTraversableTemplate[A, ImmutableArrayProxy] {
</td>
          </tr><tr>
            <td class="black">394</td>
            <td>
</td>
          </tr><tr>
            <td class="green">395</td>
            <td>  @inline override def companion: GenericCompanion[ImmutableArrayProxy] = ImmutableArrayProxy
</td>
          </tr><tr>
            <td class="black">396</td>
            <td>
</td>
          </tr><tr>
            <td class="green">397</td>
            <td>  override protected[this] def newBuilder: Builder[A, ImmutableArrayProxy[A]] = ImmutableArrayProxy.newBuilder[A]
</td>
          </tr><tr>
            <td class="black">398</td>
            <td>
</td>
          </tr><tr>
            <td class="black">399</td>
            <td>  def ar : TraversableOnce[A]
</td>
          </tr><tr>
            <td class="black">400</td>
            <td> 
</td>
          </tr><tr>
            <td class="black">401</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">402</td>
            <td>
</td>
          </tr><tr>
            <td class="black">403</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">404</td>
            <td> * Proxy Vector.  When its in Vector it stays in Vector. 
</td>
          </tr><tr>
            <td class="black">405</td>
            <td> */ 
</td>
          </tr><tr>
            <td class="green">406</td>
            <td><a id="Class_scales_utils_VectorImpl"></a>case class VectorImpl[ +A ](ar : Vector[A]) extends ImmutableArrayProxy[A] {
</td>
          </tr><tr>
            <td class="black">407</td>
            <td>
</td>
          </tr><tr>
            <td class="green">408</td>
            <td>  def apply(idx : Int ) = ar.apply(idx)
</td>
          </tr><tr>
            <td class="black">409</td>
            <td> 
</td>
          </tr><tr>
            <td class="green">410</td>
            <td>  def length = ar.length
</td>
          </tr><tr>
            <td class="black">411</td>
            <td>  
</td>
          </tr><tr>
            <td class="red">412</td>
            <td>  @inline override def +:[B &gt;: A, That](elem: B)(implicit bf: CanBuildFrom[ImmutableArrayProxy[A], B, That]): That = <span class="non">VectorImpl(ar.+:(elem)).asInstanceOf[That]
</span></td>
          </tr><tr>
            <td class="black">413</td>
            <td>  
</td>
          </tr><tr>
            <td class="green">414</td>
            <td>  @inline override def :+[B &gt;: A, That](elem: B)(implicit bf: CanBuildFrom[ImmutableArrayProxy[A], B, That]): That = VectorImpl(ar.:+(elem)).asInstanceOf[That]
</td>
          </tr><tr>
            <td class="black">415</td>
            <td>
</td>
          </tr><tr>
            <td class="red">416</td>
            <td>  @inline override def take( n : Int ) = <span class="non">VectorImpl(ar.take(n))
</span></td>
          </tr><tr>
            <td class="black">417</td>
            <td>
</td>
          </tr><tr>
            <td class="red">418</td>
            <td>  @inline override def drop( n : Int ) = <span class="non">VectorImpl(ar.drop(n))
</span></td>
          </tr><tr>
            <td class="black">419</td>
            <td>
</td>
          </tr><tr>
            <td class="red">420</td>
            <td>  @inline override def tail = <span class="non">VectorImpl(ar.tail)
</span></td>
          </tr><tr>
            <td class="black">421</td>
            <td>
</td>
          </tr><tr>
            <td class="red">422</td>
            <td>  @inline override def slice(from: Int, until: Int) = <span class="non">VectorImpl(ar.slice(from, until))
</span></td>
          </tr><tr>
            <td class="black">423</td>
            <td>
</td>
          </tr><tr>
            <td class="green">424</td>
            <td>  override def updated[B &gt;: A, That](index: Int, elem: B)(implicit bf: CanBuildFrom[ImmutableArrayProxy[A], B, That]): That = VectorImpl(ar.updated(index, elem)).asInstanceOf[That]
</td>
          </tr><tr>
            <td class="black">425</td>
            <td>
</td>
          </tr><tr>
            <td class="red">426</td>
            <td>  override def toArray[U &gt;: A : ClassManifest]: Array[U] = <span class="non">ar.toArray
</span></td>
          </tr><tr>
            <td class="black">427</td>
            <td>
</td>
          </tr><tr>
            <td class="black">428</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">429</td>
            <td>
</td>
          </tr></tbody></table>