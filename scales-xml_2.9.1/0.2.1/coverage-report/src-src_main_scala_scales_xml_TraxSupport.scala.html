<table class="classes"><tbody><tr>
      <td class="barContainerLeft"><a href="#">&#x200B;scales/&#x200B;xml/<span class="header">&#x200B;TraxSupport.scala</span></a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">60 %</div>
        <div class="greenBar" style="width:120px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_TraxSupport.scala.html#Object_scales_xml_EmptyNamespaceContext"><img src="object.png"></img>EmptyNamespaceContext</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">40 %</div>
        <div class="greenBar" style="width:80px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_TraxSupport.scala.html#Object_scales_xml_EmptyStreamLocation"><img src="object.png"></img>EmptyStreamLocation</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_TraxSupport.scala.html#Class_scales_xml_NamespaceContextFunctions"><img src="class.png"></img>NamespaceContextFunctions</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">60 %</div>
        <div class="greenBar" style="width:120px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_TraxSupport.scala.html#Object_scales_xml_NamespaceContextFunctions"><img src="object.png"></img>NamespaceContextFunctions</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_TraxSupport.scala.html#Class_scales_xml_ScalesResult"><img src="class.png"></img>ScalesResult</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_TraxSupport.scala.html#Class_scales_xml_ScalesSource"><img src="class.png"></img>ScalesSource</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_TraxSupport.scala.html#Trait_scales_xml_ScalesStreamReader"><img src="trait.png"></img>ScalesStreamReader</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">48 %</div>
        <div class="greenBar" style="width:96px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_TraxSupport.scala.html#Trait_scales_xml_TNC"><img src="trait.png"></img>TNC</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_TraxSupport.scala.html#Trait_scales_xml_TraxConversionImplicits"><img src="trait.png"></img>TraxConversionImplicits</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">33 %</div>
        <div class="greenBar" style="width:66px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_TraxSupport.scala.html#Class_scales_xml_TraxSourceConversions"><img src="class.png"></img>TraxSourceConversions</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_TraxSupport.scala.html#Trait_scales_xml_TraxSourceConversions"><img src="trait.png"></img>TraxSourceConversions</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">83 %</div>
        <div class="greenBar" style="width:166px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_TraxSupport.scala.html#Object_scales_xml_TraxSourceConversions_End"><img src="object.png"></img>TraxSourceConversions.End</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">50 %</div>
        <div class="greenBar" style="width:100px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_TraxSupport.scala.html#Object_scales_xml_TraxSourceConversions_EndElemS"><img src="object.png"></img>TraxSourceConversions.EndElemS</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_TraxSupport.scala.html#Object_scales_xml_TraxSourceConversions_OnItem"><img src="object.png"></img>TraxSourceConversions.OnItem</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_TraxSupport.scala.html#Object_scales_xml_TraxSourceConversions_StartElem"><img src="object.png"></img>TraxSourceConversions.StartElem</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_TraxSupport.scala.html#Trait_scales_xml_TraxSourceConversions_State"><img src="trait.png"></img>TraxSourceConversions.State</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr></tbody></table><table class="source"><tbody><tr>
            <td class="black">1</td>
            <td>package scales.xml
</td>
          </tr><tr>
            <td class="black">2</td>
            <td>
</td>
          </tr><tr>
            <td class="black">3</td>
            <td>import javax.xml.stream._
</td>
          </tr><tr>
            <td class="black">4</td>
            <td>import scales.utils._
</td>
          </tr><tr>
            <td class="black">5</td>
            <td>import ScalesXml._
</td>
          </tr><tr>
            <td class="black">6</td>
            <td>
</td>
          </tr><tr>
            <td class="black">7</td>
            <td>import javax.xml.namespace.{QName =&gt; JQName, NamespaceContext}
</td>
          </tr><tr>
            <td class="black">8</td>
            <td>
</td>
          </tr><tr>
            <td class="black">9</td>
            <td>import javax.xml.transform.Source
</td>
          </tr><tr>
            <td class="black">10</td>
            <td>import javax.xml.transform.stax._
</td>
          </tr><tr>
            <td class="black">11</td>
            <td>import javax.xml.transform.sax._
</td>
          </tr><tr>
            <td class="black">12</td>
            <td>import javax.xml.transform.stream._
</td>
          </tr><tr>
            <td class="black">13</td>
            <td>
</td>
          </tr><tr>
            <td class="black">14</td>
            <td><a id="Object_scales_xml_EmptyStreamLocation"></a>object EmptyStreamLocation extends Location {
</td>
          </tr><tr>
            <td class="green">15</td>
            <td>  val getCharacterOffset : Int = -1
</td>
          </tr><tr>
            <td class="green">16</td>
            <td>  val getColumnNumber : Int = -1
</td>
          </tr><tr>
            <td class="green">17</td>
            <td>  val getLineNumber : Int = -1
</td>
          </tr><tr>
            <td class="green">18</td>
            <td><a id="Class_scales_xml_ScalesSource"></a><a id="Class_scales_xml_ScalesResult"></a>  val getPublicId : String = null : String 
</td>
          </tr><tr>
            <td class="green">19</td>
            <td>  val getSystemId : String = null : String 
</td>
          </tr><tr>
            <td class="black">20</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">21</td>
            <td>
</td>
          </tr><tr>
            <td class="black">22</td>
            <td><a id="Trait_scales_xml_TNC"></a>trait TNC extends NamespaceContext {
</td>
          </tr><tr>
            <td class="black">23</td>
            <td>  val parent : TNC
</td>
          </tr><tr>
            <td class="black">24</td>
            <td>
</td>
          </tr><tr>
            <td class="black">25</td>
            <td>  val ns : Array[(String, String)]
</td>
          </tr><tr>
            <td class="black">26</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">27</td>
            <td>
</td>
          </tr><tr>
            <td class="black">28</td>
            <td><a id="Object_scales_xml_EmptyNamespaceContext"></a>object EmptyNamespaceContext extends TNC {
</td>
          </tr><tr>
            <td class="black">29</td>
            <td> import scala.collection.JavaConversions._
</td>
          </tr><tr>
            <td class="black">30</td>
            <td>
</td>
          </tr><tr>
            <td class="green">31</td>
            <td> val parent = this
</td>
          </tr><tr>
            <td class="black">32</td>
            <td>   
</td>
          </tr><tr>
            <td class="green">33</td>
            <td> val ns = Array[(String,String)]() 
</td>
          </tr><tr>
            <td class="black">34</td>
            <td>
</td>
          </tr><tr>
            <td class="red">35</td>
            <td> def getNamespaceURI( prefix : String) : String = <span class="non">&quot;&quot;
</span></td>
          </tr><tr>
            <td class="red">36</td>
            <td> def getPrefix( namespaceURI : String) : String = <span class="non">&quot;&quot;
</span></td>
          </tr><tr>
            <td class="red">37</td>
            <td> def getPrefixes(namespaceURI : String) : java.util.Iterator[String] = List<span class="non">().iterator 
</span></td>
          </tr><tr>
            <td class="black">38</td>
            <td> 
</td>
          </tr><tr>
            <td class="black">39</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">40</td>
            <td>
</td>
          </tr><tr>
            <td class="black">41</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">42</td>
            <td> * Provides a namespace context, needs pushing / popping etc
</td>
          </tr><tr>
            <td class="black">43</td>
            <td> */ 
</td>
          </tr><tr>
            <td class="black">44</td>
            <td><a id="Object_scales_xml_NamespaceContextFunctions"></a>object NamespaceContextFunctions {
</td>
          </tr><tr>
            <td class="black">45</td>
            <td>//  def case class ElNamespaceContext( elem : Elem ) 
</td>
          </tr><tr>
            <td class="black">46</td>
            <td>  
</td>
          </tr><tr>
            <td class="green">47</td>
            <td><a id="Class_scales_xml_NamespaceContextFunctions"></a>  def newContext( prev : TNC, elem : Elem ) =  new TNC {
</td>
          </tr><tr>
            <td class="black">48</td>
            <td>    import scala.collection.JavaConversions._
</td>
          </tr><tr>
            <td class="black">49</td>
            <td>
</td>
          </tr><tr>
            <td class="green">50</td>
            <td>    val parent = prev
</td>
          </tr><tr>
            <td class="black">51</td>
            <td>
</td>
          </tr><tr>
            <td class="green">52</td>
            <td>    val ns = preToNS.toArray
</td>
          </tr><tr>
            <td class="black">53</td>
            <td>
</td>
          </tr><tr>
            <td class="black">54</td>
            <td>    lazy val preToNS = elem.attributes.flatMap( a =&gt; a.name.prefix.map( p =&gt; Option((p, a.name.namespace.uri)) ).getOrElse(None) ).toMap ++ elem.namespaces
</td>
          </tr><tr>
            <td class="black">55</td>
            <td>
</td>
          </tr><tr>
            <td class="green">56</td>
            <td>    val nsToPre = preToNS.foldLeft(Map[String, List[String]]()){ 
</td>
          </tr><tr>
            <td class="black">57</td>
            <td>      (x, y) =&gt;
</td>
          </tr><tr>
            <td class="red">58</td>
            <td>      <span class="non">x.updated(y._2, x.get(y._2).map(y._1 :: _ ).
</span></td>
          </tr><tr>
            <td class="black">59</td>
            <td>         getOrElse( List(y._1) ))
</td>
          </tr><tr>
            <td class="black">60</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">61</td>
            <td>    
</td>
          </tr><tr>
            <td class="black">62</td>
            <td>    def getNamespaceURI( prefix : String) : String = preToNS.get(prefix).getOrElse(prev.getNamespaceURI(prefix))
</td>
          </tr><tr>
            <td class="black">63</td>
            <td>    def getPrefix( namespaceURI : String) : String = nsToPre.get(namespaceURI).map(_.head).getOrElse(prev.getPrefix(namespaceURI))
</td>
          </tr><tr>
            <td class="black">64</td>
            <td>    def getPrefixes(namespaceURI : String) : java.util.Iterator[String] = 
</td>
          </tr><tr>
            <td class="black">65</td>
            <td>      nsToPre.get(namespaceURI).getOrElse(List()).iterator
</td>
          </tr><tr>
            <td class="black">66</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">67</td>
            <td>
</td>
          </tr><tr>
            <td class="black">68</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">69</td>
            <td>
</td>
          </tr><tr>
            <td class="black">70</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">71</td>
            <td> * A TrAX Result
</td>
          </tr><tr>
            <td class="black">72</td>
            <td> */ 
</td>
          </tr><tr>
            <td class="green">73</td>
            <td>case class ScalesResult[Token &lt;: OptimisationToken](strategy : PathOptimisationStrategy[Token] = defaultPathOptimisation) extends SAXResult(new scales.xml.Handler[Token](strategy)) {
</td>
          </tr><tr>
            <td class="black">74</td>
            <td>  def doc = {
</td>
          </tr><tr>
            <td class="green">75</td>
            <td>    val handler = getHandler.asInstanceOf[scales.xml.Handler[Token]]
</td>
          </tr><tr>
            <td class="green">76</td>
            <td>    val tp = handler.buf.proxies(0)
</td>
          </tr><tr>
            <td class="black">77</td>
            <td>
</td>
          </tr><tr>
            <td class="green">78</td>
            <td>    Doc(Tree(tp.elem, tp.children)//path.tree()
</td>
          </tr><tr>
            <td class="black">79</td>
            <td>  , handler.prolog, handler.end)
</td>
          </tr><tr>
            <td class="black">80</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">81</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">82</td>
            <td>
</td>
          </tr><tr>
            <td class="black">83</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">84</td>
            <td> * Use as a basis for TrAX or javax.xml.validation and some other services.  Unfortunately XPath isn't one of them, fortunately ScalesXml comes with similar...
</td>
          </tr><tr>
            <td class="black">85</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">86</td>
            <td> * To add to the joy, at time of writing Xalan (2.7.1) uses SAXSource.toInputSource to convert this into a stream, problem is the JVM version (1.6.0_24) doesn't support StAXSource transformation, which is nice.  So until this is fixed users should serialize themselves into a stream and then use for trax if they are using Xalan directly.
</td>
          </tr><tr>
            <td class="black">87</td>
            <td> * 
</td>
          </tr><tr>
            <td class="black">88</td>
            <td> * Only the prolog and endMisc are taken from the document, the rest comes from the stream
</td>
          </tr><tr>
            <td class="black">89</td>
            <td> */ 
</td>
          </tr><tr>
            <td class="green">90</td>
            <td>case class ScalesSource(stream : Iterator[PullType], documentLike : DocLike = EmptyDoc()) extends StAXSource (
</td>
          </tr><tr>
            <td class="green">91</td>
            <td>  new ScalesStreamReader() {
</td>
          </tr><tr>
            <td class="green">92</td>
            <td>    val itr = stream
</td>
          </tr><tr>
            <td class="green">93</td>
            <td>    val docLike = documentLike
</td>
          </tr><tr>
            <td class="black">94</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">95</td>
            <td>)
</td>
          </tr><tr>
            <td class="black">96</td>
            <td>
</td>
          </tr><tr>
            <td class="black">97</td>
            <td><a id="Trait_scales_xml_TraxSourceConversions"></a>trait TraxSourceConversions {
</td>
          </tr><tr>
            <td class="black">98</td>
            <td>
</td>
          </tr><tr>
            <td class="green">99</td>
            <td><a id="Class_scales_xml_TraxSourceConversions"></a>  def convertToStream( tree : XmlTree ) : Iterator[PullType] = new Iterator[PullType]{
</td>
          </tr><tr>
            <td class="black">100</td>
            <td>    
</td>
          </tr><tr>
            <td class="green">101</td>
            <td>    var path = top(tree)
</td>
          </tr><tr>
            <td class="black">102</td>
            <td>
</td>
          </tr><tr>
            <td class="black">103</td>
            <td><a id="Trait_scales_xml_TraxSourceConversions_State"></a>    sealed trait State {
</td>
          </tr><tr>
            <td class="green">104</td>
            <td>      def hasNext : Boolean = true
</td>
          </tr><tr>
            <td class="black">105</td>
            <td>      def next : (State, PullType)
</td>
          </tr><tr>
            <td class="black">106</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">107</td>
            <td>    
</td>
          </tr><tr>
            <td class="black">108</td>
            <td><a id="Object_scales_xml_TraxSourceConversions_StartElem"></a>    case object StartElem extends State {
</td>
          </tr><tr>
            <td class="black">109</td>
            <td>      // always has the start
</td>
          </tr><tr>
            <td class="black">110</td>
            <td>      def next = {
</td>
          </tr><tr>
            <td class="green">111</td>
            <td>  val ev = event
</td>
          </tr><tr>
            <td class="black">112</td>
            <td>  // turn to firstChild map getOrElse  
</td>
          </tr><tr>
            <td class="green">113</td>
            <td>  if (path.hasChildren) {
</td>
          </tr><tr>
            <td class="green">114</td>
            <td>    path = path.firstChild.get
</td>
          </tr><tr>
            <td class="green">115</td>
            <td>    if (path.isItem)
</td>
          </tr><tr>
            <td class="green">116</td>
            <td>      (OnItem, ev)
</td>
          </tr><tr>
            <td class="black">117</td>
            <td>    else
</td>
          </tr><tr>
            <td class="green">118</td>
            <td>      (StartElem, ev)
</td>
          </tr><tr>
            <td class="black">119</td>
            <td>  } else
</td>
          </tr><tr>
            <td class="green">120</td>
            <td>    (EndElemS, ev)
</td>
          </tr><tr>
            <td class="black">121</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">122</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">123</td>
            <td>
</td>
          </tr><tr>
            <td class="black">124</td>
            <td><a id="Object_scales_xml_TraxSourceConversions_OnItem"></a>    case object OnItem extends State {
</td>
          </tr><tr>
            <td class="black">125</td>
            <td>      // always either nextSibling or EndElem
</td>
          </tr><tr>
            <td class="black">126</td>
            <td>      def next = {
</td>
          </tr><tr>
            <td class="green">127</td>
            <td>  val ev = event
</td>
          </tr><tr>
            <td class="black">128</td>
            <td>
</td>
          </tr><tr>
            <td class="green">129</td>
            <td>  if (path.hasNextSibling)
</td>
          </tr><tr>
            <td class="green">130</td>
            <td>    doNext(ev)
</td>
          </tr><tr>
            <td class="black">131</td>
            <td>  else {
</td>
          </tr><tr>
            <td class="black">132</td>
            <td>    // direct zip Up
</td>
          </tr><tr>
            <td class="green">133</td>
            <td>    path = path.top.right.get
</td>
          </tr><tr>
            <td class="green">134</td>
            <td>    (EndElemS, ev)
</td>
          </tr><tr>
            <td class="black">135</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">136</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">137</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">138</td>
            <td>
</td>
          </tr><tr>
            <td class="black">139</td>
            <td><a id="Object_scales_xml_TraxSourceConversions_End"></a>    case object End extends State {
</td>
          </tr><tr>
            <td class="green">140</td>
            <td>      override def hasNext = false
</td>
          </tr><tr>
            <td class="red">141</td>
            <td>      def next = <span class="non">error(&quot;Can't go past the root&quot;)
</span></td>
          </tr><tr>
            <td class="black">142</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">143</td>
            <td>
</td>
          </tr><tr>
            <td class="black">144</td>
            <td>    def end = {
</td>
          </tr><tr>
            <td class="black">145</td>
            <td>      val el = path.tree.section
</td>
          </tr><tr>
            <td class="black">146</td>
            <td>      EndElem(el.name, el.namespaces) : PullType
</td>
          </tr><tr>
            <td class="black">147</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">148</td>
            <td>
</td>
          </tr><tr>
            <td class="black">149</td>
            <td><a id="Object_scales_xml_TraxSourceConversions_EndElemS"></a>    case object EndElemS extends State {
</td>
          </tr><tr>
            <td class="black">150</td>
            <td>      // we will always have at least one last EndElemS before End
</td>
          </tr><tr>
            <td class="black">151</td>
            <td>      def next = {
</td>
          </tr><tr>
            <td class="green">152</td>
            <td>  val ev = end
</td>
          </tr><tr>
            <td class="green">153</td>
            <td>  if (path.hasNextSibling) {
</td>
          </tr><tr>
            <td class="black">154</td>
            <td>    // element without children
</td>
          </tr><tr>
            <td class="green">155</td>
            <td>    doNext(ev)
</td>
          </tr><tr>
            <td class="black">156</td>
            <td>  } else {
</td>
          </tr><tr>
            <td class="green">157</td>
            <td>    if (path.top.isLeft) {
</td>
          </tr><tr>
            <td class="green">158</td>
            <td>      (End, ev) // last event
</td>
          </tr><tr>
            <td class="black">159</td>
            <td>    } else {
</td>
          </tr><tr>
            <td class="black">160</td>
            <td>      // direct zip Up
</td>
          </tr><tr>
            <td class="green">161</td>
            <td>      path = path.top.right.get
</td>
          </tr><tr>
            <td class="green">162</td>
            <td>      (EndElemS, ev)    
</td>
          </tr><tr>
            <td class="black">163</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">164</td>
            <td>  } 
</td>
          </tr><tr>
            <td class="black">165</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">166</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">167</td>
            <td>
</td>
          </tr><tr>
            <td class="black">168</td>
            <td>    def doNext(ev : PullType) : (State, PullType) = {
</td>
          </tr><tr>
            <td class="black">169</td>
            <td>      path = path.nextSibling
</td>
          </tr><tr>
            <td class="black">170</td>
            <td>      if ( path.isItem ) 
</td>
          </tr><tr>
            <td class="black">171</td>
            <td>  (OnItem, ev)
</td>
          </tr><tr>
            <td class="black">172</td>
            <td>      else
</td>
          </tr><tr>
            <td class="black">173</td>
            <td>  (StartElem, ev)
</td>
          </tr><tr>
            <td class="black">174</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">175</td>
            <td>
</td>
          </tr><tr>
            <td class="black">176</td>
            <td>    def event : PullType = path.node.focus.fold(x=&gt;x,y=&gt;y.section)
</td>
          </tr><tr>
            <td class="black">177</td>
            <td>
</td>
          </tr><tr>
            <td class="green">178</td>
            <td>    var nextState : State = StartElem
</td>
          </tr><tr>
            <td class="black">179</td>
            <td>
</td>
          </tr><tr>
            <td class="black">180</td>
            <td>    def hasNext = nextState.hasNext
</td>
          </tr><tr>
            <td class="black">181</td>
            <td>    def next = {
</td>
          </tr><tr>
            <td class="black">182</td>
            <td>      val (ns, ev) = nextState.next
</td>
          </tr><tr>
            <td class="black">183</td>
            <td>      nextState = ns
</td>
          </tr><tr>
            <td class="black">184</td>
            <td>      ev
</td>
          </tr><tr>
            <td class="black">185</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">186</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">187</td>
            <td>
</td>
          </tr><tr>
            <td class="black">188</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">189</td>
            <td>   * When the user really wants a stream source or there is yet another place that jaxp Source support is not complete.
</td>
          </tr><tr>
            <td class="black">190</td>
            <td>   */ 
</td>
          </tr><tr>
            <td class="black">191</td>
            <td>  def asStreamSource[T : SerializeableXml]( xml : T ) : Source = {
</td>
          </tr><tr>
            <td class="green">192</td>
            <td>    val str = asString(xml)
</td>
          </tr><tr>
            <td class="green">193</td>
            <td>    new StreamSource(new java.io.StringReader(str))
</td>
          </tr><tr>
            <td class="black">194</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">195</td>
            <td>
</td>
          </tr><tr>
            <td class="black">196</td>
            <td>  def streamOr[T : SerializeableXml]( xml : T , f : =&gt; Source) : Source =
</td>
          </tr><tr>
            <td class="green">197</td>
            <td>    if (Versions.traxSourceShouldSerialize)
</td>
          </tr><tr>
            <td class="red">198</td>
            <td>      <span class="non">asStreamSource(xml)
</span></td>
          </tr><tr>
            <td class="black">199</td>
            <td>    else 
</td>
          </tr><tr>
            <td class="green">200</td>
            <td>      f
</td>
          </tr><tr>
            <td class="black">201</td>
            <td>  
</td>
          </tr><tr>
            <td class="black">202</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">203</td>
            <td>
</td>
          </tr><tr>
            <td class="black">204</td>
            <td><a id="Trait_scales_xml_TraxConversionImplicits"></a>trait TraxConversionImplicits {
</td>
          </tr><tr>
            <td class="red">205</td>
            <td>  implicit def toStream( tree : XmlTree ) = <span class="non">convertToStream(tree)
</span></td>
          </tr><tr>
            <td class="black">206</td>
            <td>
</td>
          </tr><tr>
            <td class="black">207</td>
            <td>  implicit def treeToSource( tree : XmlTree )(implicit sf : SerializeableXml[XmlTree]) : Source = 
</td>
          </tr><tr>
            <td class="red">208</td>
            <td>    <span class="non">streamOr( tree, ScalesSource(convertToStream(tree)))(sf)
</span></td>
          </tr><tr>
            <td class="black">209</td>
            <td>
</td>
          </tr><tr>
            <td class="black">210</td>
            <td>  implicit def docToSource( doc : Doc )(implicit sf : SerializeableXml[Doc]) : Source = 
</td>
          </tr><tr>
            <td class="green">211</td>
            <td>    streamOr( doc, ScalesSource(convertToStream(doc.rootElem), doc))
</td>
          </tr><tr>
            <td class="black">212</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">213</td>
            <td>
</td>
          </tr><tr>
            <td class="black">214</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">215</td>
            <td> * The trax support, the stream reader in particular
</td>
          </tr><tr>
            <td class="black">216</td>
            <td> * is aimed at allowing xlst transformations, a further
</td>
          </tr><tr>
            <td class="black">217</td>
            <td> * serialization option and conversion to other DOMs
</td>
          </tr><tr>
            <td class="black">218</td>
            <td> */
</td>
          </tr><tr>
            <td class="black">219</td>
            <td>
</td>
          </tr><tr>
            <td class="black">220</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">221</td>
            <td> * Provides a stream reader interface for StAX.  DTD is not supported at this time, contributions welcome.
</td>
          </tr><tr>
            <td class="black">222</td>
            <td> */
</td>
          </tr><tr>
            <td class="black">223</td>
            <td><a id="Trait_scales_xml_ScalesStreamReader"></a>trait ScalesStreamReader extends XMLStreamReader {
</td>
          </tr><tr>
            <td class="black">224</td>
            <td>  import XMLStreamConstants._
</td>
          </tr><tr>
            <td class="black">225</td>
            <td>
</td>
          </tr><tr>
            <td class="black">226</td>
            <td>  protected val itr : Iterator[PullType]
</td>
          </tr><tr>
            <td class="black">227</td>
            <td>  protected var ev : PullType = _
</td>
          </tr><tr>
            <td class="green">228</td>
            <td>  protected var evType : Int = START_DOCUMENT
</td>
          </tr><tr>
            <td class="black">229</td>
            <td>
</td>
          </tr><tr>
            <td class="black">230</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">231</td>
            <td>   * Take just the prolog and end misc
</td>
          </tr><tr>
            <td class="black">232</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">233</td>
            <td>  protected val docLike : DocLike
</td>
          </tr><tr>
            <td class="black">234</td>
            <td>
</td>
          </tr><tr>
            <td class="green">235</td>
            <td>  lazy val prologItr = docLike.prolog.misc.iterator
</td>
          </tr><tr>
            <td class="black">236</td>
            <td>
</td>
          </tr><tr>
            <td class="green">237</td>
            <td>  lazy val endItr = docLike.end.misc.iterator
</td>
          </tr><tr>
            <td class="black">238</td>
            <td>
</td>
          </tr><tr>
            <td class="black">239</td>
            <td>  def setEv() {
</td>
          </tr><tr>
            <td class="black">240</td>
            <td>//    println(&quot;called with ev &quot; + ev )
</td>
          </tr><tr>
            <td class="green">241</td>
            <td>    evType = ev.fold( _ match {
</td>
          </tr><tr>
            <td class="green">242</td>
            <td>      case _ : Elem =&gt; START_ELEMENT
</td>
          </tr><tr>
            <td class="green">243</td>
            <td>      case _ : Text =&gt; CHARACTERS
</td>
          </tr><tr>
            <td class="red">244</td>
            <td>      case _ : CData =&gt; <span class="non">CDATA
</span></td>
          </tr><tr>
            <td class="green">245</td>
            <td>      case _ : Comment =&gt; COMMENT
</td>
          </tr><tr>
            <td class="green">246</td>
            <td>      case _ : PI =&gt; PROCESSING_INSTRUCTION
</td>
          </tr><tr>
            <td class="red">247</td>
            <td>    } , _ =&gt; <span class="non">END_ELEMENT)
</span></td>
          </tr><tr>
            <td class="black">248</td>
            <td>//    println(&quot;set evType &quot; + evType)
</td>
          </tr><tr>
            <td class="black">249</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">250</td>
            <td>
</td>
          </tr><tr>
            <td class="green">251</td>
            <td>  var doEndDoc = false
</td>
          </tr><tr>
            <td class="black">252</td>
            <td>
</td>
          </tr><tr>
            <td class="green">253</td>
            <td>  var shouldPop = false
</td>
          </tr><tr>
            <td class="green">254</td>
            <td>  var nc : TNC = EmptyNamespaceContext
</td>
          </tr><tr>
            <td class="black">255</td>
            <td>
</td>
          </tr><tr>
            <td class="black">256</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">257</td>
            <td>   * Only usable when its an element of course
</td>
          </tr><tr>
            <td class="black">258</td>
            <td>   * We copy to an array for indexed access and keep
</td>
          </tr><tr>
            <td class="black">259</td>
            <td>   * using ev for map access
</td>
          </tr><tr>
            <td class="black">260</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">261</td>
            <td>  protected var attribs : Array[Attribute] = _ 
</td>
          </tr><tr>
            <td class="black">262</td>
            <td>
</td>
          </tr><tr>
            <td class="black">263</td>
            <td>  def close() {}
</td>
          </tr><tr>
            <td class="black">264</td>
            <td>
</td>
          </tr><tr>
            <td class="green">265</td>
            <td>  def getAttributeCount() : Int = attribs.size
</td>
          </tr><tr>
            <td class="green">266</td>
            <td>  def getAttributeLocalName( index : Int ) : String = attribs(index).local
</td>
          </tr><tr>
            <td class="black">267</td>
            <td>  def getAttributeName( index : Int) : JQName = {
</td>
          </tr><tr>
            <td class="red">268</td>
            <td>    val att = <span class="non">attribs(index)
</span></td>
          </tr><tr>
            <td class="red">269</td>
            <td>    <span class="non">new JQName(
</span></td>
          </tr><tr>
            <td class="red">270</td>
            <td>      if (<span class="non">att.namespace eq Default.noNamespace)
</span></td>
          </tr><tr>
            <td class="red">271</td>
            <td>  <span class="non">null : String
</span></td>
          </tr><tr>
            <td class="black">272</td>
            <td>      else
</td>
          </tr><tr>
            <td class="red">273</td>
            <td>  <span class="non">att.namespace.uri,
</span></td>
          </tr><tr>
            <td class="black">274</td>
            <td>      att.local,
</td>
          </tr><tr>
            <td class="black">275</td>
            <td>      att.prefix.getOrElse(null : String)
</td>
          </tr><tr>
            <td class="black">276</td>
            <td>    )
</td>
          </tr><tr>
            <td class="black">277</td>
            <td>  }
</td>
          </tr><tr>
            <td class="green">278</td>
            <td>  def getAttributeNamespace( index : Int) : String = attribs(index).namespace.uri
</td>
          </tr><tr>
            <td class="green">279</td>
            <td>  def getAttributePrefix( index : Int) : String = attribs(index).prefix.getOrElse(null : String)
</td>
          </tr><tr>
            <td class="green">280</td>
            <td>  def getAttributeType( index : Int ) : String = null : String
</td>
          </tr><tr>
            <td class="green">281</td>
            <td>  def getAttributeValue( index : Int ) : String = attribs(index).value
</td>
          </tr><tr>
            <td class="black">282</td>
            <td>  def getAttributeValue(namespaceURI : String, localName : String) : String = 
</td>
          </tr><tr>
            <td class="red">283</td>
            <td>    <span class="non">ev.left.get.asInstanceOf[Elem].attributes(Namespace(namespaceURI).apply(localName)).map(_.value).getOrElse(null : String)
</span></td>
          </tr><tr>
            <td class="black">284</td>
            <td>
</td>
          </tr><tr>
            <td class="red">285</td>
            <td>  def getCharacterEncodingScheme() : String = <span class="non">&quot;UTF-16&quot;
</span></td>
          </tr><tr>
            <td class="black">286</td>
            <td>  
</td>
          </tr><tr>
            <td class="black">287</td>
            <td>  def getElementText() : String = {
</td>
          </tr><tr>
            <td class="red">288</td>
            <td>    if(<span class="non">getEventType() != XMLStreamConstants.START_ELEMENT) {
</span></td>
          </tr><tr>
            <td class="red">289</td>
            <td>      <span class="non">throw new XMLStreamException(
</span></td>
          </tr><tr>
            <td class="black">290</td>
            <td>  &quot;parser must be on START_ELEMENT to read next text&quot;, getLocation());
</td>
          </tr><tr>
            <td class="black">291</td>
            <td>    }
</td>
          </tr><tr>
            <td class="red">292</td>
            <td>    var eventType = <span class="non">next();
</span></td>
          </tr><tr>
            <td class="red">293</td>
            <td>    var buf = <span class="non">new StringBuilder();
</span></td>
          </tr><tr>
            <td class="red">294</td>
            <td>    while(<span class="non">eventType != XMLStreamConstants.END_ELEMENT ) {
</span></td>
          </tr><tr>
            <td class="red">295</td>
            <td>      if(<span class="non">eventType == XMLStreamConstants.CHARACTERS
</span></td>
          </tr><tr>
            <td class="black">296</td>
            <td>   || eventType == XMLStreamConstants.CDATA
</td>
          </tr><tr>
            <td class="black">297</td>
            <td>   || eventType == XMLStreamConstants.SPACE
</td>
          </tr><tr>
            <td class="black">298</td>
            <td>   || eventType == XMLStreamConstants.ENTITY_REFERENCE) {
</td>
          </tr><tr>
            <td class="red">299</td>
            <td>  <span class="non">buf.append(getText());
</span></td>
          </tr><tr>
            <td class="red">300</td>
            <td>      } else if(<span class="non">eventType == XMLStreamConstants.PROCESSING_INSTRUCTION
</span></td>
          </tr><tr>
            <td class="black">301</td>
            <td>    || eventType == XMLStreamConstants.COMMENT) {
</td>
          </tr><tr>
            <td class="black">302</td>
            <td>  // skipping
</td>
          </tr><tr>
            <td class="red">303</td>
            <td>      } else if(<span class="non">eventType == XMLStreamConstants.END_DOCUMENT) {
</span></td>
          </tr><tr>
            <td class="red">304</td>
            <td>  <span class="non">throw new XMLStreamException(
</span></td>
          </tr><tr>
            <td class="black">305</td>
            <td>    &quot;unexpected end of document when reading element text content&quot;);
</td>
          </tr><tr>
            <td class="red">306</td>
            <td>      } else if(<span class="non">eventType == XMLStreamConstants.START_ELEMENT) {
</span></td>
          </tr><tr>
            <td class="red">307</td>
            <td>  <span class="non">throw new XMLStreamException(
</span></td>
          </tr><tr>
            <td class="black">308</td>
            <td>    &quot;element text content may not contain START_ELEMENT&quot;, getLocation());
</td>
          </tr><tr>
            <td class="black">309</td>
            <td>      } else {
</td>
          </tr><tr>
            <td class="red">310</td>
            <td>  <span class="non">throw new XMLStreamException(
</span></td>
          </tr><tr>
            <td class="black">311</td>
            <td>    &quot;Unexpected event type &quot;+eventType, getLocation());
</td>
          </tr><tr>
            <td class="black">312</td>
            <td>      }
</td>
          </tr><tr>
            <td class="red">313</td>
            <td>      <span class="non">eventType = next();
</span></td>
          </tr><tr>
            <td class="black">314</td>
            <td>    }
</td>
          </tr><tr>
            <td class="red">315</td>
            <td>    <span class="non">buf.toString(); 
</span></td>
          </tr><tr>
            <td class="black">316</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">317</td>
            <td>
</td>
          </tr><tr>
            <td class="red">318</td>
            <td>  def getEncoding() : String = <span class="non">&quot;UTF-16&quot;
</span></td>
          </tr><tr>
            <td class="green">319</td>
            <td>  def getEventType() : Int = evType
</td>
          </tr><tr>
            <td class="black">320</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">321</td>
            <td>   * Called for both start element and end element
</td>
          </tr><tr>
            <td class="black">322</td>
            <td>   */ 
</td>
          </tr><tr>
            <td class="black">323</td>
            <td>  def elemName = 
</td>
          </tr><tr>
            <td class="green">324</td>
            <td>    ev.fold(e =&gt; e.asInstanceOf[Elem].name,
</td>
          </tr><tr>
            <td class="red">325</td>
            <td>      ee =&gt; <span class="non">ee.name)
</span></td>
          </tr><tr>
            <td class="black">326</td>
            <td>
</td>
          </tr><tr>
            <td class="green">327</td>
            <td>  def getLocalName() : String = elemName.local
</td>
          </tr><tr>
            <td class="green">328</td>
            <td>  def getLocation() : Location = EmptyStreamLocation
</td>
          </tr><tr>
            <td class="black">329</td>
            <td>  def getName() : JQName = 
</td>
          </tr><tr>
            <td class="red">330</td>
            <td>    <span class="non">new JQName(
</span></td>
          </tr><tr>
            <td class="red">331</td>
            <td>      if (<span class="non">elemName.namespace eq Default.noNamespace)
</span></td>
          </tr><tr>
            <td class="red">332</td>
            <td>  <span class="non">null : String
</span></td>
          </tr><tr>
            <td class="black">333</td>
            <td>      else
</td>
          </tr><tr>
            <td class="red">334</td>
            <td>  <span class="non">elemName.namespace.uri,
</span></td>
          </tr><tr>
            <td class="black">335</td>
            <td>      elemName.local,
</td>
          </tr><tr>
            <td class="black">336</td>
            <td>      getPrefix
</td>
          </tr><tr>
            <td class="black">337</td>
            <td>    )
</td>
          </tr><tr>
            <td class="black">338</td>
            <td>  
</td>
          </tr><tr>
            <td class="red">339</td>
            <td>  def getNamespaceContext() : NamespaceContext = <span class="non">nc
</span></td>
          </tr><tr>
            <td class="green">340</td>
            <td>  def getNamespaceCount() : Int = nc.ns.size
</td>
          </tr><tr>
            <td class="red">341</td>
            <td>  def getNamespacePrefix(index : Int) : String = <span class="non">nc.ns(index)._1
</span></td>
          </tr><tr>
            <td class="green">342</td>
            <td>  def getNamespaceURI() : String = elemName.namespace.uri
</td>
          </tr><tr>
            <td class="red">343</td>
            <td>  def getNamespaceURI( index : Int ) : String = <span class="non">nc.ns(index)._2
</span></td>
          </tr><tr>
            <td class="red">344</td>
            <td>  def getNamespaceURI( prefix : String) : String = <span class="non">nc.getNamespaceURI(prefix)
</span></td>
          </tr><tr>
            <td class="black">345</td>
            <td>
</td>
          </tr><tr>
            <td class="green">346</td>
            <td>  def getPIData() : String = ev.left.get.asInstanceOf[PI].value
</td>
          </tr><tr>
            <td class="green">347</td>
            <td>  def getPITarget() : String = ev.left.get.asInstanceOf[PI].target
</td>
          </tr><tr>
            <td class="black">348</td>
            <td>
</td>
          </tr><tr>
            <td class="green">349</td>
            <td>  def getPrefix() : String = elemName.prefix.getOrElse(&quot;&quot;)//null : String)
</td>
          </tr><tr>
            <td class="red">350</td>
            <td>  def getProperty(name : String) : Object = <span class="non">null
</span></td>
          </tr><tr>
            <td class="green">351</td>
            <td>  def getText() : String = ev.left.get.asInstanceOf[XmlItem].value
</td>
          </tr><tr>
            <td class="green">352</td>
            <td>  def getTextCharacters() : Array[Char] = getText.toArray
</td>
          </tr><tr>
            <td class="black">353</td>
            <td>  def getTextCharacters(sourceStart : Int, target : Array[Char], targetStart : Int, length : Int) : Int = {
</td>
          </tr><tr>
            <td class="red">354</td>
            <td>    if (<span class="non">targetStart &lt; 0 || targetStart &gt; getTextLength())
</span></td>
          </tr><tr>
            <td class="red">355</td>
            <td>      <span class="non">throw new IndexOutOfBoundsException(&quot;TargetStart was out of bounds: &quot;+targetStart+&quot; textLength &quot;+getTextLength())
</span></td>
          </tr><tr>
            <td class="black">356</td>
            <td>    
</td>
          </tr><tr>
            <td class="red">357</td>
            <td>    if (<span class="non">length &lt; 0 || (targetStart + length &gt; getTextLength())) 
</span></td>
          </tr><tr>
            <td class="red">358</td>
            <td>      <span class="non">throw new IndexOutOfBoundsException(&quot;TargetStart and Length was out of bounds: &quot;+targetStart+&quot; length &quot;+length+&quot; textLength &quot;+getTextLength())
</span></td>
          </tr><tr>
            <td class="black">359</td>
            <td>    
</td>
          </tr><tr>
            <td class="red">360</td>
            <td>    <span class="non">System.arraycopy(getTextCharacters(), sourceStart, target, targetStart, length)
</span></td>
          </tr><tr>
            <td class="red">361</td>
            <td>    <span class="non">length
</span></td>
          </tr><tr>
            <td class="black">362</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">363</td>
            <td>
</td>
          </tr><tr>
            <td class="green">364</td>
            <td>  def getTextLength() : Int = getText().size
</td>
          </tr><tr>
            <td class="green">365</td>
            <td>  def getTextStart() : Int = 0
</td>
          </tr><tr>
            <td class="black">366</td>
            <td>
</td>
          </tr><tr>
            <td class="red">367</td>
            <td>  def getVersion() : String  = <span class="non">docLike.prolog.decl.version.version
</span></td>
          </tr><tr>
            <td class="black">368</td>
            <td>
</td>
          </tr><tr>
            <td class="red">369</td>
            <td>  def hasName() : Boolean = <span class="non">evType == START_ELEMENT || evType == END_ELEMENT
</span></td>
          </tr><tr>
            <td class="green">370</td>
            <td>  def hasNext() : Boolean = prologItr.hasNext || itr.hasNext || endItr.hasNext || doEndDoc
</td>
          </tr><tr>
            <td class="red">371</td>
            <td>  def hasText() : Boolean = <span class="non">evType == CDATA || evType == COMMENT || evType == CHARACTERS
</span></td>
          </tr><tr>
            <td class="black">372</td>
            <td>
</td>
          </tr><tr>
            <td class="green">373</td>
            <td>  def isAttributeSpecified(index : Int) : Boolean = false // can't specify this
</td>
          </tr><tr>
            <td class="red">374</td>
            <td>  def isCharacters() : Boolean = <span class="non">evType == CHARACTERS
</span></td>
          </tr><tr>
            <td class="red">375</td>
            <td>  def isEndElement() : Boolean = <span class="non">evType == END_ELEMENT
</span></td>
          </tr><tr>
            <td class="red">376</td>
            <td>  def isStandalone() : Boolean = <span class="non">standaloneSet
</span></td>
          </tr><tr>
            <td class="red">377</td>
            <td>  def isStartElement() : Boolean = <span class="non">evType == START_ELEMENT
</span></td>
          </tr><tr>
            <td class="red">378</td>
            <td>  def isWhiteSpace() : Boolean = <span class="non">getText.trim.size == 0
</span></td>
          </tr><tr>
            <td class="black">379</td>
            <td>
</td>
          </tr><tr>
            <td class="black">380</td>
            <td>  def doPop {
</td>
          </tr><tr>
            <td class="green">381</td>
            <td>    if (shouldPop) {
</td>
          </tr><tr>
            <td class="green">382</td>
            <td>      nc = nc.parent
</td>
          </tr><tr>
            <td class="green">383</td>
            <td>      shouldPop = false
</td>
          </tr><tr>
            <td class="black">384</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">385</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">386</td>
            <td>
</td>
          </tr><tr>
            <td class="black">387</td>
            <td>  def next() : Int = {
</td>
          </tr><tr>
            <td class="green">388</td>
            <td>    if (doEndDoc) {
</td>
          </tr><tr>
            <td class="green">389</td>
            <td>      doEndDoc = false
</td>
          </tr><tr>
            <td class="black">390</td>
            <td>//      println(&quot;doc end&quot;) 
</td>
          </tr><tr>
            <td class="green">391</td>
            <td>      return END_DOCUMENT
</td>
          </tr><tr>
            <td class="black">392</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">393</td>
            <td>
</td>
          </tr><tr>
            <td class="green">394</td>
            <td>    if (prologItr.hasNext) {
</td>
          </tr><tr>
            <td class="green">395</td>
            <td>      ev = prologItr.next.fold(x=&gt;x, y=&gt;y)
</td>
          </tr><tr>
            <td class="green">396</td>
            <td>    } else if (itr.hasNext) {
</td>
          </tr><tr>
            <td class="green">397</td>
            <td>      ev = itr.next
</td>
          </tr><tr>
            <td class="black">398</td>
            <td>    } else {
</td>
          </tr><tr>
            <td class="green">399</td>
            <td>      ev = endItr.next.fold(x=&gt;x, y=&gt;y)
</td>
          </tr><tr>
            <td class="black">400</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">401</td>
            <td>    
</td>
          </tr><tr>
            <td class="green">402</td>
            <td>    setEv
</td>
          </tr><tr>
            <td class="black">403</td>
            <td>
</td>
          </tr><tr>
            <td class="black">404</td>
            <td>    import NamespaceContextFunctions._
</td>
          </tr><tr>
            <td class="black">405</td>
            <td>
</td>
          </tr><tr>
            <td class="green">406</td>
            <td>    evType match {
</td>
          </tr><tr>
            <td class="black">407</td>
            <td>      case START_ELEMENT =&gt; 
</td>
          </tr><tr>
            <td class="black">408</td>
            <td>//  println(&quot; se : &quot;+ev)
</td>
          </tr><tr>
            <td class="green">409</td>
            <td>  val el = ev.left.get.asInstanceOf[Elem]
</td>
          </tr><tr>
            <td class="green">410</td>
            <td>  attribs = el.attributes.toArray
</td>
          </tr><tr>
            <td class="black">411</td>
            <td>  
</td>
          </tr><tr>
            <td class="green">412</td>
            <td>  doPop
</td>
          </tr><tr>
            <td class="green">413</td>
            <td>  nc = newContext(nc, el)
</td>
          </tr><tr>
            <td class="black">414</td>
            <td>      case END_ELEMENT =&gt;
</td>
          </tr><tr>
            <td class="black">415</td>
            <td>//  println(&quot; ee : &quot;+ ev)
</td>
          </tr><tr>
            <td class="green">416</td>
            <td>  shouldPop = true
</td>
          </tr><tr>
            <td class="black">417</td>
            <td>      case _ =&gt; 
</td>
          </tr><tr>
            <td class="black">418</td>
            <td>//  println(&quot; item &quot;+ev)
</td>
          </tr><tr>
            <td class="green">419</td>
            <td>  doPop
</td>
          </tr><tr>
            <td class="black">420</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">421</td>
            <td>
</td>
          </tr><tr>
            <td class="green">422</td>
            <td>    if (!itr.hasNext &amp;&amp; !endItr.hasNext) {
</td>
          </tr><tr>
            <td class="green">423</td>
            <td>      doEndDoc = true
</td>
          </tr><tr>
            <td class="black">424</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">425</td>
            <td>
</td>
          </tr><tr>
            <td class="green">426</td>
            <td>    evType
</td>
          </tr><tr>
            <td class="black">427</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">428</td>
            <td>
</td>
          </tr><tr>
            <td class="black">429</td>
            <td>  // tough one as well, Skips any white space (isWhiteSpace() returns true), COMMENT, or PROCESSING_INSTRUCTION, until a START_ELEMENT or END_ELEMENT is reached.
</td>
          </tr><tr>
            <td class="black">430</td>
            <td>  def nextTag() : Int = {
</td>
          </tr><tr>
            <td class="red">431</td>
            <td>    var eventType = <span class="non">next()
</span></td>
          </tr><tr>
            <td class="red">432</td>
            <td>    while((<span class="non">eventType == XMLStreamConstants.CHARACTERS &amp;&amp; isWhiteSpace()) // skip whitespace
</span></td>
          </tr><tr>
            <td class="black">433</td>
            <td>    || (eventType == XMLStreamConstants.CDATA &amp;&amp; isWhiteSpace()) 
</td>
          </tr><tr>
            <td class="black">434</td>
            <td>    // skip whitespace
</td>
          </tr><tr>
            <td class="black">435</td>
            <td>    || eventType == XMLStreamConstants.SPACE
</td>
          </tr><tr>
            <td class="black">436</td>
            <td>    || eventType == XMLStreamConstants.PROCESSING_INSTRUCTION
</td>
          </tr><tr>
            <td class="black">437</td>
            <td>    || eventType == XMLStreamConstants.COMMENT
</td>
          </tr><tr>
            <td class="black">438</td>
            <td>  ) {
</td>
          </tr><tr>
            <td class="red">439</td>
            <td>      <span class="non">eventType = next()
</span></td>
          </tr><tr>
            <td class="black">440</td>
            <td>    }
</td>
          </tr><tr>
            <td class="red">441</td>
            <td>    if (<span class="non">eventType != XMLStreamConstants.START_ELEMENT &amp;&amp; eventType != XMLStreamConstants.END_ELEMENT) {
</span></td>
          </tr><tr>
            <td class="red">442</td>
            <td>      <span class="non">throw new XMLStreamException(&quot;expected start or end tag&quot;, getLocation())
</span></td>
          </tr><tr>
            <td class="black">443</td>
            <td>    }
</td>
          </tr><tr>
            <td class="red">444</td>
            <td>    <span class="non">eventType
</span></td>
          </tr><tr>
            <td class="black">445</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">446</td>
            <td>
</td>
          </tr><tr>
            <td class="black">447</td>
            <td>  def require(tipe : Int, namespaceURI : String , localName : String) {
</td>
          </tr><tr>
            <td class="red">448</td>
            <td>    if (<span class="non">evType != tipe)
</span></td>
          </tr><tr>
            <td class="red">449</td>
            <td>      <span class="non">throw new XMLStreamException(&quot;Type does not match&quot;, getLocation())
</span></td>
          </tr><tr>
            <td class="black">450</td>
            <td>    
</td>
          </tr><tr>
            <td class="red">451</td>
            <td>    if (<span class="non">namespaceURI != null &amp;&amp; namespaceURI != getNamespaceURI())
</span></td>
          </tr><tr>
            <td class="red">452</td>
            <td>      <span class="non">throw new XMLStreamException(&quot;Namespace does not match&quot;, getLocation())
</span></td>
          </tr><tr>
            <td class="black">453</td>
            <td>
</td>
          </tr><tr>
            <td class="red">454</td>
            <td>    if (<span class="non">localName != null &amp;&amp; localName != getLocalName())
</span></td>
          </tr><tr>
            <td class="red">455</td>
            <td>      <span class="non">throw new XMLStreamException(&quot;LocalName does not match&quot;, getLocation())
</span></td>
          </tr><tr>
            <td class="black">456</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">457</td>
            <td>
</td>
          </tr><tr>
            <td class="red">458</td>
            <td>  def standaloneSet() : Boolean = <span class="non">docLike.prolog.decl.standalone
</span></td>
          </tr><tr>
            <td class="black">459</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">460</td>
            <td>
</td>
          </tr></tbody></table>