<table class="classes"><tbody><tr>
      <td class="barContainerLeft"><a href="#">&#x200B;scales/&#x200B;xml/<span class="header">&#x200B;XmlPaths.scala</span></a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">80 %</div>
        <div class="greenBar" style="width:160px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPaths.scala.html#Class_scales_xml_AttributePath"><img src="class.png"></img>AttributePath</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPaths.scala.html#Class_scales_xml_AttributePathComparisoms"><img src="class.png"></img>AttributePathComparisoms</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPaths.scala.html#Class_scales_xml_AttributePaths"><img src="class.png"></img>AttributePaths</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">55 %</div>
        <div class="greenBar" style="width:110px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPaths.scala.html#Class_scales_xml_XPath"><img src="class.png"></img>XPath</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">66 %</div>
        <div class="greenBar" style="width:132px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPaths.scala.html#Class_scales_xml_XPathInfo"><img src="class.png"></img>XPathInfo</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPaths.scala.html#Class_scales_xml_XmlPathComparisoms"><img src="class.png"></img>XmlPathComparisoms</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPaths.scala.html#Trait_scales_xml_XmlPathImplicits"><img src="trait.png"></img>XmlPathImplicits</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">65 %</div>
        <div class="greenBar" style="width:130px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPaths.scala.html#Trait_scales_xml_XmlPaths"><img src="trait.png"></img>XmlPaths</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">84 %</div>
        <div class="greenBar" style="width:168px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPaths.scala.html#Trait_scales_xml_XmlPaths_AttributeAxis"><img src="trait.png"></img>XmlPaths.AttributeAxis</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPaths.scala.html#Object_scales_xml_XmlPaths_Attributes"><img src="object.png"></img>XmlPaths.Attributes</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">66 %</div>
        <div class="greenBar" style="width:132px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPaths.scala.html#Object_scales_xml_XmlPaths_Attributes_Functions"><img src="object.png"></img>XmlPaths.Attributes.Functions</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">71 %</div>
        <div class="greenBar" style="width:142px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPaths.scala.html#Trait_scales_xml_XmlPaths_Axis"><img src="trait.png"></img>XmlPaths.Axis</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">90 %</div>
        <div class="greenBar" style="width:180px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPaths.scala.html#Trait_scales_xml_XmlPaths_ElementStep"><img src="trait.png"></img>XmlPaths.ElementStep</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPaths.scala.html#Object_scales_xml_XmlPaths_Elements"><img src="object.png"></img>XmlPaths.Elements</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">25 %</div>
        <div class="greenBar" style="width:50px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPaths.scala.html#Object_scales_xml_XmlPaths_Elements_Functions"><img src="object.png"></img>XmlPaths.Elements.Functions</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">83 %</div>
        <div class="greenBar" style="width:166px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPaths.scala.html#Trait_scales_xml_XmlPaths_OtherNodeTypes"><img src="trait.png"></img>XmlPaths.OtherNodeTypes</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">77 %</div>
        <div class="greenBar" style="width:154px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPaths.scala.html#Trait_scales_xml_XmlPaths_SiblingsAxis"><img src="trait.png"></img>XmlPaths.SiblingsAxis</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPaths.scala.html#Object_scales_xml_XmlPaths_TextFunctions"><img src="object.png"></img>XmlPaths.TextFunctions</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">83 %</div>
        <div class="greenBar" style="width:166px;">&nbsp;</div>
      </div>
    </div></td>
    </tr></tbody></table><table class="source"><tbody><tr>
            <td class="black">1</td>
            <td>package scales.xml
</td>
          </tr><tr>
            <td class="black">2</td>
            <td>
</td>
          </tr><tr>
            <td class="black">3</td>
            <td>/** Simple container for keeping relationship between the parent and attribute */
</td>
          </tr><tr>
            <td class="green">4</td>
            <td><a id="Class_scales_xml_AttributePath"></a>case class AttributePath(attribute: Attribute, parent: XmlPath)
</td>
          </tr><tr>
            <td class="black">5</td>
            <td>
</td>
          </tr><tr>
            <td class="green">6</td>
            <td><a id="Class_scales_xml_XmlPathComparisoms"></a>case class XmlPathComparisoms(path: XmlPath) {
</td>
          </tr><tr>
            <td class="green">7</td>
            <td>  def ===(other: String) = Elements.Functions.text(path) == other
</td>
          </tr><tr>
            <td class="black">8</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">9</td>
            <td>
</td>
          </tr><tr>
            <td class="red">10</td>
            <td><a id="Class_scales_xml_AttributePathComparisoms"></a>case class AttributePathComparisoms<span class="non">(path: AttributePath) {
</span></td>
          </tr><tr>
            <td class="red">11</td>
            <td>  def ===(other: String) = <span class="non">Attributes.Functions.text(path) == other
</span></td>
          </tr><tr>
            <td class="black">12</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">13</td>
            <td>
</td>
          </tr><tr>
            <td class="black">14</td>
            <td>import scales.utils._
</td>
          </tr><tr>
            <td class="black">15</td>
            <td><a id="Class_scales_xml_XPathInfo"></a><a id="Class_scales_xml_AttributePaths"></a>import scala.collection.generic.CanBuildFrom
</td>
          </tr><tr>
            <td class="black">16</td>
            <td>import scales.utils.one
</td>
          </tr><tr>
            <td class="black">17</td>
            <td>
</td>
          </tr><tr>
            <td class="black">18</td>
            <td>
</td>
          </tr><tr>
            <td class="black">19</td>
            <td><a id="Trait_scales_xml_XmlPathImplicits"></a>trait XmlPathImplicits {
</td>
          </tr><tr>
            <td class="red">20</td>
            <td>  implicit val samePath: (XmlPath, XmlPath) =&gt; Boolean = <span class="non">comparePaths(_, _)._1 == 0
</span></td>
          </tr><tr>
            <td class="black">21</td>
            <td>
</td>
          </tr><tr>
            <td class="black">22</td>
            <td>  /** Unpack the attribute from the tuple */
</td>
          </tr><tr>
            <td class="green">23</td>
            <td>  implicit def fromAttrPathToAttribute(attrPath: AttributePath): Attribute = attrPath.attribute
</td>
          </tr><tr>
            <td class="black">24</td>
            <td>
</td>
          </tr><tr>
            <td class="black">25</td>
            <td>  /** By default a List, eager/strict evaluation, is used.  The user of the library can simply choose another collection to wrap the xmlPath */
</td>
          </tr><tr>
            <td class="black">26</td>
            <td>  implicit def fromXmlPathToXPath(xmlPath: XmlPath)(
</td>
          </tr><tr>
            <td class="black">27</td>
            <td>    implicit cbf: CanBuildFrom[List[XmlPath], XmlPath, List[XmlPath]]) : XPath[List[XmlPath]] = 
</td>
          </tr><tr>
            <td class="green">28</td>
            <td>    new XPath[List[XmlPath]](
</td>
          </tr><tr>
            <td class="yellow">29</td>
            <td>      XPathInfo(one(one(xmlPath)), initialNode = <span class="non">true, eager = true), cbf)
</span></td>
          </tr><tr>
            <td class="black">30</td>
            <td>//      XPathInfo(one(one(xmlPath).view).view, initialNode = true), cbf)
</td>
          </tr><tr>
            <td class="black">31</td>
            <td>
</td>
          </tr><tr>
            <td class="black">32</td>
            <td>  implicit def fromXPathToIterable(xpath: XPath[_]) : Iterable[XmlPath] = {
</td>
          </tr><tr>
            <td class="green">33</td>
            <td>    val nodes = xpath.path.nodes.flatten
</td>
          </tr><tr>
            <td class="green">34</td>
            <td>    if (nodes.size &lt; 2) nodes // sorting on one or 0 still costs
</td>
          </tr><tr>
            <td class="black">35</td>
            <td>    else
</td>
          </tr><tr>
            <td class="green">36</td>
            <td>      DuplicateFilter(sort[XmlItem, Elem, XCC](paths = nodes)
</td>
          </tr><tr>
            <td class="black">37</td>
            <td>        (ScalesXml.xpathSortingClassManifest))(ScalesUtils.sameRef)
</td>
          </tr><tr>
            <td class="black">38</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">39</td>
            <td>  
</td>
          </tr><tr>
            <td class="black">40</td>
            <td>//  implicit def fromAttributePathToAxis(attrs: Iterable[AttributePath]) = AttributePaths(attrs)
</td>
          </tr><tr>
            <td class="black">41</td>
            <td>
</td>
          </tr><tr>
            <td class="black">42</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">43</td>
            <td>   * Sort in document order.
</td>
          </tr><tr>
            <td class="black">44</td>
            <td>   */ 
</td>
          </tr><tr>
            <td class="black">45</td>
            <td>  implicit def fromAttributePathsToIterable[T &lt;: Iterable[XmlPath]](attrs: AttributePaths[T]) : Iterable[AttributePath] =
</td>
          </tr><tr>
            <td class="green">46</td>
            <td>    if (attrs.attributes.size &lt; 2) attrs.attributes
</td>
          </tr><tr>
            <td class="black">47</td>
            <td>    else
</td>
          </tr><tr>
            <td class="green">48</td>
            <td>      sortT[XmlItem, Elem, XCC, AttributePath](attrs.attributes.map{x =&gt; (x, x.parent)}).map{x =&gt; x._1}
</td>
          </tr><tr>
            <td class="black">49</td>
            <td>
</td>
          </tr><tr>
            <td class="green">50</td>
            <td>  implicit def fromPathToComparisoms(path: XmlPath) = XmlPathComparisoms(path)
</td>
          </tr><tr>
            <td class="black">51</td>
            <td>
</td>
          </tr><tr>
            <td class="red">52</td>
            <td>  implicit def fromAPathToAComparisoms(path: AttributePath) = <span class="non">AttributePathComparisoms(path)
</span></td>
          </tr><tr>
            <td class="black">53</td>
            <td>
</td>
          </tr><tr>
            <td class="black">54</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">55</td>
            <td>   * Mimic the logic of xpath boolean() through typeclass, see AsBoolean / XmlDSL
</td>
          </tr><tr>
            <td class="black">56</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">57</td>
            <td>
</td>
          </tr><tr>
            <td class="red">58</td>
            <td>  implicit val XPathToBoolean = (x: XPath[_]) =&gt; <span class="non">!x.path.nodes.isEmpty
</span></td>
          </tr><tr>
            <td class="black">59</td>
            <td>
</td>
          </tr><tr>
            <td class="green">60</td>
            <td>  implicit val AttributePathsToBoolean = (x: AttributePaths[_]) =&gt; !x.attributes.isEmpty
</td>
          </tr><tr>
            <td class="black">61</td>
            <td>
</td>
          </tr><tr>
            <td class="red">62</td>
            <td>  implicit val IterableToBoolean = (x: Iterable[_]) =&gt; <span class="non">!x.isEmpty
</span></td>
          </tr><tr>
            <td class="black">63</td>
            <td>
</td>
          </tr><tr>
            <td class="red">64</td>
            <td>  implicit val StringToBoolean = (x: String) =&gt; <span class="non">x.length &gt; 0
</span></td>
          </tr><tr>
            <td class="black">65</td>
            <td>
</td>
          </tr><tr>
            <td class="red">66</td>
            <td>  implicit val NumberToBoolean = (x: Number) =&gt; <span class="non">x.longValue() &gt; 0
</span></td>
          </tr><tr>
            <td class="black">67</td>
            <td>
</td>
          </tr><tr>
            <td class="red">68</td>
            <td>  implicit val BooleanToBoolean = (x: Boolean) =&gt; <span class="non">x
</span></td>
          </tr><tr>
            <td class="black">69</td>
            <td>
</td>
          </tr><tr>
            <td class="black">70</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">71</td>
            <td>
</td>
          </tr><tr>
            <td class="black">72</td>
            <td>
</td>
          </tr><tr>
            <td class="black">73</td>
            <td><a id="Trait_scales_xml_XmlPaths"></a>trait XmlPaths {
</td>
          </tr><tr>
            <td class="black">74</td>
            <td>
</td>
          </tr><tr>
            <td class="black">75</td>
            <td>
</td>
          </tr><tr>
            <td class="black">76</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">77</td>
            <td>   * Normally the implicit fromXPathToIterable will provide sorted output, but this can create significant slow down when only the contents are necessary, not their order.
</td>
          </tr><tr>
            <td class="black">78</td>
            <td>   *
</td>
          </tr><tr>
            <td class="black">79</td>
            <td>   * Use raw to convert without forcing sorting or checking for duplicates.
</td>
          </tr><tr>
            <td class="black">80</td>
            <td>   *
</td>
          </tr><tr>
            <td class="black">81</td>
            <td>   * NOTE Any laziness aquired by viewed will also be lost by the flatten
</td>
          </tr><tr>
            <td class="black">82</td>
            <td>   */ 
</td>
          </tr><tr>
            <td class="black">83</td>
            <td>  def raw[T &lt;: Iterable[XmlPath]](xpath: XPath[T]) : Iterable[XmlPath] = 
</td>
          </tr><tr>
            <td class="red">84</td>
            <td>    <span class="non">xpath.path.nodes.flatten
</span></td>
          </tr><tr>
            <td class="black">85</td>
            <td>
</td>
          </tr><tr>
            <td class="black">86</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">87</td>
            <td>   * Normally the implicit fromXPathToIterable will provide sorted output, but this can create significant slow down when only the contents are necessary, not their order.
</td>
          </tr><tr>
            <td class="black">88</td>
            <td>   *
</td>
          </tr><tr>
            <td class="black">89</td>
            <td>   * Use lazyRaw to convert without forcing sorting or checking for duplicates, and to evaluate lazily.
</td>
          </tr><tr>
            <td class="black">90</td>
            <td>   *
</td>
          </tr><tr>
            <td class="black">91</td>
            <td>   * Warning, don't use this version of raw unless your XPath usage costs more than the navigation, its based on Stream and terribly slow (huge memory and stack usage etc).
</td>
          </tr><tr>
            <td class="black">92</td>
            <td>   *
</td>
          </tr><tr>
            <td class="black">93</td>
            <td>   * NOTEs
</td>
          </tr><tr>
            <td class="black">94</td>
            <td>   * Laziness with flatten is achieved by using iterator.toIterable before the flatten (uses Stream internally).
</td>
          </tr><tr>
            <td class="black">95</td>
            <td>   * Its only useful as a lazy evaluator if viewed was used.
</td>
          </tr><tr>
            <td class="black">96</td>
            <td>   */ 
</td>
          </tr><tr>
            <td class="black">97</td>
            <td>  def lazyRaw[T &lt;: Iterable[XmlPath]](xpath: XPath[T]) : Iterable[XmlPath] = 
</td>
          </tr><tr>
            <td class="green">98</td>
            <td>    xpath.path.nodes.iterator.toIterable.flatten
</td>
          </tr><tr>
            <td class="black">99</td>
            <td>
</td>
          </tr><tr>
            <td class="black">100</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">101</td>
            <td>   * Lazy evaluation of XPaths
</td>
          </tr><tr>
            <td class="black">102</td>
            <td>   * 
</td>
          </tr><tr>
            <td class="black">103</td>
            <td>   * View called on nested Lists, but not on xlmPath.
</td>
          </tr><tr>
            <td class="black">104</td>
            <td>   */ 
</td>
          </tr><tr>
            <td class="black">105</td>
            <td>  def viewed(xmlPath: XmlPath)(
</td>
          </tr><tr>
            <td class="black">106</td>
            <td>    implicit cbf: CanBuildFrom[List[XmlPath], XmlPath, List[XmlPath]]) : XPath[List[XmlPath]] = 
</td>
          </tr><tr>
            <td class="green">107</td>
            <td>    new XPath[List[XmlPath]](
</td>
          </tr><tr>
            <td class="yellow">108</td>
            <td>      XPathInfo(one(one(xmlPath).view).view, initialNode = <span class="non">true), cbf)
</span></td>
          </tr><tr>
            <td class="black">109</td>
            <td>
</td>
          </tr><tr>
            <td class="black">110</td>
            <td>  import ScalesXml._
</td>
          </tr><tr>
            <td class="black">111</td>
            <td>
</td>
          </tr><tr>
            <td class="black">112</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">113</td>
            <td>   * Same as fromXmlPathToXPath, an eager evaluation of xpath queries
</td>
          </tr><tr>
            <td class="black">114</td>
            <td>   */ 
</td>
          </tr><tr>
            <td class="black">115</td>
            <td>  def eager(xmlPath: XmlPath)(
</td>
          </tr><tr>
            <td class="black">116</td>
            <td>    implicit cbf: CanBuildFrom[List[XmlPath], XmlPath, List[XmlPath]]) : XPath[List[XmlPath]] = 
</td>
          </tr><tr>
            <td class="green">117</td>
            <td>      fromXmlPathToXPath(xmlPath)
</td>
          </tr><tr>
            <td class="black">118</td>
            <td>
</td>
          </tr><tr>
            <td class="green">119</td>
            <td>  val isText = (x: XmlPath) =&gt; x.isItem == true &amp;&amp; (x.item().isInstanceOf[Text] || x.item().isInstanceOf[CData])
</td>
          </tr><tr>
            <td class="black">120</td>
            <td>
</td>
          </tr><tr>
            <td class="black">121</td>
            <td><a id="Object_scales_xml_XmlPaths_Attributes"></a>  object Attributes {
</td>
          </tr><tr>
            <td class="black">122</td>
            <td>
</td>
          </tr><tr>
            <td class="black">123</td>
            <td>    /**
</td>
          </tr><tr>
            <td class="black">124</td>
            <td>     * Note the majority of these functions have an implicit arguement that matches the current context of a given predicate.  This allows:
</td>
          </tr><tr>
            <td class="black">125</td>
            <td>     *
</td>
          </tr><tr>
            <td class="black">126</td>
            <td>     *
</td>
          </tr><tr>
            <td class="black">127</td>
            <td>     */
</td>
          </tr><tr>
            <td class="black">128</td>
            <td><a id="Object_scales_xml_XmlPaths_Attributes_Functions"></a>    object Functions {
</td>
          </tr><tr>
            <td class="black">129</td>
            <td>
</td>
          </tr><tr>
            <td class="black">130</td>
            <td>      /** curried to allow direct drop in for predicates */
</td>
          </tr><tr>
            <td class="green">131</td>
            <td>      def localName(localName: String)(implicit attribute: AttributePath): Boolean = attribute.attribute.name.local == localName
</td>
          </tr><tr>
            <td class="black">132</td>
            <td>
</td>
          </tr><tr>
            <td class="black">133</td>
            <td>      /** curried to allow direct drop in for predicates */
</td>
          </tr><tr>
            <td class="red">134</td>
            <td>      def exact(qname: QName)(implicit attribute: AttributePath): Boolean = <span class="non">attribute.attribute.name === qname
</span></td>
          </tr><tr>
            <td class="black">135</td>
            <td>
</td>
          </tr><tr>
            <td class="black">136</td>
            <td>      /** returns the qname of an AttributePath, using implicit scope */
</td>
          </tr><tr>
            <td class="red">137</td>
            <td>      def qname(implicit attribute: AttributePath): String = <span class="non">attribute.attribute.name.qName
</span></td>
          </tr><tr>
            <td class="black">138</td>
            <td>
</td>
          </tr><tr>
            <td class="black">139</td>
            <td>      /** returns the pqName of an AttributePath, using implicit scope */
</td>
          </tr><tr>
            <td class="green">140</td>
            <td>      def pqName(implicit attribute: AttributePath): String = attribute.attribute.name.pqName
</td>
          </tr><tr>
            <td class="black">141</td>
            <td>
</td>
          </tr><tr>
            <td class="black">142</td>
            <td>      /** returns the value of an AttributePath, using implicit scope */
</td>
          </tr><tr>
            <td class="green">143</td>
            <td>      def value(implicit attribute: AttributePath): String = attribute.attribute.value
</td>
          </tr><tr>
            <td class="black">144</td>
            <td>
</td>
          </tr><tr>
            <td class="black">145</td>
            <td>      /** returns the value of an AttributePath, using implicit scope */
</td>
          </tr><tr>
            <td class="green">146</td>
            <td>      def text(implicit attribute: AttributePath) = value
</td>
          </tr><tr>
            <td class="black">147</td>
            <td>
</td>
          </tr><tr>
            <td class="black">148</td>
            <td>      /** true if the element contains this attribute */
</td>
          </tr><tr>
            <td class="green">149</td>
            <td>      def *@(qName: QName)(implicit path: XmlPath) = path.tree.section.attributes.contains(qName)
</td>
          </tr><tr>
            <td class="black">150</td>
            <td>
</td>
          </tr><tr>
            <td class="black">151</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">152</td>
            <td>
</td>
          </tr><tr>
            <td class="green">153</td>
            <td>    val *@ = (qName: QName) =&gt; (path: XmlPath) =&gt; Functions.*@(qName)(path)
</td>
          </tr><tr>
            <td class="green">154</td>
            <td>    val localName = (l: String) =&gt; (a: AttributePath) =&gt; Functions.localName(l)(a)
</td>
          </tr><tr>
            <td class="red">155</td>
            <td>    val exact = (q: QName) =&gt; (a: AttributePath) =&gt; <span class="non">Functions.exact(q)(a)
</span></td>
          </tr><tr>
            <td class="black">156</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">157</td>
            <td>
</td>
          </tr><tr>
            <td class="black">158</td>
            <td><a id="Object_scales_xml_XmlPaths_TextFunctions"></a>  object TextFunctions {
</td>
          </tr><tr>
            <td class="black">159</td>
            <td>
</td>
          </tr><tr>
            <td class="black">160</td>
            <td>    /**
</td>
          </tr><tr>
            <td class="black">161</td>
            <td>     * Either the value of an XmlItem or the direct text subchildren.
</td>
          </tr><tr>
            <td class="black">162</td>
            <td>     * @param xmlpath
</td>
          </tr><tr>
            <td class="black">163</td>
            <td>     * @return
</td>
          </tr><tr>
            <td class="black">164</td>
            <td>     */
</td>
          </tr><tr>
            <td class="black">165</td>
            <td>    def value(implicit xmlpath: XmlPath) =
</td>
          </tr><tr>
            <td class="green">166</td>
            <td>      if (xmlpath.isItem)
</td>
          </tr><tr>
            <td class="green">167</td>
            <td>        xmlpath.item.value
</td>
          </tr><tr>
            <td class="black">168</td>
            <td>      else
</td>
          </tr><tr>
            <td class="green">169</td>
            <td>        xmlpath.flatMap(x =&gt; if (isText(x)) Some(x.item.value)
</td>
          </tr><tr>
            <td class="red">170</td>
            <td>        else <span class="non">None).addString(new StringBuilder()).toString
</span></td>
          </tr><tr>
            <td class="black">171</td>
            <td>
</td>
          </tr><tr>
            <td class="black">172</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">173</td>
            <td>
</td>
          </tr><tr>
            <td class="black">174</td>
            <td>  /** returns the attributes of a given element */
</td>
          </tr><tr>
            <td class="green">175</td>
            <td>  def attributes( implicit path : XmlPath) : Attributes = path.tree.section.attributes
</td>
          </tr><tr>
            <td class="black">176</td>
            <td>
</td>
          </tr><tr>
            <td class="black">177</td>
            <td>  /** returns the Elem at this path */
</td>
          </tr><tr>
            <td class="green">178</td>
            <td>  def elem( implicit path : XmlPath) : Elem = path.tree.section
</td>
          </tr><tr>
            <td class="black">179</td>
            <td>
</td>
          </tr><tr>
            <td class="black">180</td>
            <td><a id="Object_scales_xml_XmlPaths_Elements"></a>  object Elements {
</td>
          </tr><tr>
            <td class="black">181</td>
            <td>
</td>
          </tr><tr>
            <td class="black">182</td>
            <td>    /**
</td>
          </tr><tr>
            <td class="black">183</td>
            <td>     * Only use these items on XmlPaths that are actual trees, doing otherwise is a runtime exception, if used in XPath predicates then they will always be trees.
</td>
          </tr><tr>
            <td class="black">184</td>
            <td>     *
</td>
          </tr><tr>
            <td class="black">185</td>
            <td>     * Note the majority of these functions have an implicit arguement that matches the current context of a given predicate.  This allows:
</td>
          </tr><tr>
            <td class="black">186</td>
            <td>     *
</td>
          </tr><tr>
            <td class="black">187</td>
            <td>     *
</td>
          </tr><tr>
            <td class="black">188</td>
            <td>     */
</td>
          </tr><tr>
            <td class="black">189</td>
            <td><a id="Object_scales_xml_XmlPaths_Elements_Functions"></a>    object Functions {
</td>
          </tr><tr>
            <td class="black">190</td>
            <td>
</td>
          </tr><tr>
            <td class="black">191</td>
            <td>      /** curried to allow direct drop in for predicates, if it is an item then it will return false */
</td>
          </tr><tr>
            <td class="green">192</td>
            <td>      def localName(localName: String)(implicit path: XmlPath): Boolean = path.tree.section.name.local == localName
</td>
          </tr><tr>
            <td class="black">193</td>
            <td>
</td>
          </tr><tr>
            <td class="black">194</td>
            <td>      /** curried to allow direct drop in for predicates, if it is an item then it will return false */
</td>
          </tr><tr>
            <td class="red">195</td>
            <td>      def exact(qname: QName)(implicit path: XmlPath): Boolean = <span class="non">path.tree.section.name === qname
</span></td>
          </tr><tr>
            <td class="black">196</td>
            <td>
</td>
          </tr><tr>
            <td class="black">197</td>
            <td>      /** returns the localname of an XmlPath, using implicit scope */
</td>
          </tr><tr>
            <td class="green">198</td>
            <td>      def localName(implicit path: XmlPath): String = path.tree.section.name.local
</td>
          </tr><tr>
            <td class="black">199</td>
            <td>
</td>
          </tr><tr>
            <td class="black">200</td>
            <td>      /** returns the qname (pre:local) of an XmlPath, using implicit scope */
</td>
          </tr><tr>
            <td class="red">201</td>
            <td>      def qname(implicit path: XmlPath): String = <span class="non">path.tree.section.name.qName
</span></td>
          </tr><tr>
            <td class="black">202</td>
            <td>
</td>
          </tr><tr>
            <td class="black">203</td>
            <td>      /** returns the qualified name ({namespace}local) of an XmlPath, using implicit scope */
</td>
          </tr><tr>
            <td class="green">204</td>
            <td>      def qualifiedName(implicit path: XmlPath): String = path.tree.section.name.qualifiedName
</td>
          </tr><tr>
            <td class="black">205</td>
            <td>
</td>
          </tr><tr>
            <td class="black">206</td>
            <td>      /** returns the qname of an XmlPath with prefix if defined pre:{ns}qname, using implicit scope */
</td>
          </tr><tr>
            <td class="green">207</td>
            <td>      def pqName(implicit path: XmlPath): String = path.tree.section.name.pqName
</td>
          </tr><tr>
            <td class="black">208</td>
            <td>
</td>
          </tr><tr>
            <td class="black">209</td>
            <td>      /** returns the text of an XmlPath, using implicit scope. Returns all text children joined, does not trim whitespace etc */
</td>
          </tr><tr>
            <td class="black">210</td>
            <td>      def text(implicit path: XmlPath): String = {
</td>
          </tr><tr>
            <td class="green">211</td>
            <td>        path.tree.fold(new StringBuilder()) { (walker, sb) =&gt;
</td>
          </tr><tr>
            <td class="green">212</td>
            <td>          if (walker.isLeft) {
</td>
          </tr><tr>
            <td class="green">213</td>
            <td>            walker.left.get match {
</td>
          </tr><tr>
            <td class="green">214</td>
            <td>              case Text(text) =&gt; sb.append(text)
</td>
          </tr><tr>
            <td class="black">215</td>
            <td>              case _ =&gt; ()
</td>
          </tr><tr>
            <td class="black">216</td>
            <td>            }
</td>
          </tr><tr>
            <td class="black">217</td>
            <td>          }
</td>
          </tr><tr>
            <td class="green">218</td>
            <td>          sb
</td>
          </tr><tr>
            <td class="black">219</td>
            <td>        }.toString
</td>
          </tr><tr>
            <td class="black">220</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">221</td>
            <td>
</td>
          </tr><tr>
            <td class="green">222</td>
            <td>      def normalizeSpace(implicit path: XmlPath) = normalizeSpaceS(text)
</td>
          </tr><tr>
            <td class="black">223</td>
            <td>
</td>
          </tr><tr>
            <td class="black">224</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">225</td>
            <td>
</td>
          </tr><tr>
            <td class="black">226</td>
            <td>    val !! = (f: (XmlPath) =&gt; Boolean) =&gt; (a: XmlPath) =&gt; {
</td>
          </tr><tr>
            <td class="red">227</td>
            <td>      val res = <span class="non">f(a)
</span></td>
          </tr><tr>
            <td class="red">228</td>
            <td>      <span class="non">!res
</span></td>
          </tr><tr>
            <td class="black">229</td>
            <td>    }
</td>
          </tr><tr>
            <td class="green">230</td>
            <td>    val localName = (l: String) =&gt; (a: XmlPath) =&gt; Functions.localName(l)(a)
</td>
          </tr><tr>
            <td class="red">231</td>
            <td>    val exact = (q: QName) =&gt; (a: XmlPath) =&gt; <span class="non">Functions.exact(q)(a)
</span></td>
          </tr><tr>
            <td class="black">232</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">233</td>
            <td>
</td>
          </tr><tr>
            <td class="black">234</td>
            <td><a id="Trait_scales_xml_XmlPaths_Axis"></a>  trait Axis {
</td>
          </tr><tr>
            <td class="black">235</td>
            <td>    type T &lt;: Iterable[XmlPath]
</td>
          </tr><tr>
            <td class="black">236</td>
            <td>    val cbf: CanBuildFrom[T, XmlPath, T]
</td>
          </tr><tr>
            <td class="black">237</td>
            <td>
</td>
          </tr><tr>
            <td class="black">238</td>
            <td>    val path: XPathInfo
</td>
          </tr><tr>
            <td class="black">239</td>
            <td>
</td>
          </tr><tr>
            <td class="black">240</td>
            <td>    def newThis(xpathInfo: XPathInfo): XPath[T]
</td>
          </tr><tr>
            <td class="black">241</td>
            <td>
</td>
          </tr><tr>
            <td class="black">242</td>
            <td>    def process(nodes: Iterable[Iterable[XmlPath]], performSort: Boolean = path.mustBeSorted, filterDuplicates: Boolean = path.filterDuplicates) = {
</td>
          </tr><tr>
            <td class="black">243</td>
            <td>      /*val potentiallySorted = if (performSort)
</td>
          </tr><tr>
            <td class="black">244</td>
            <td>        nodes //sort[XmlItem, Elem](paths = nodes)
</td>
          </tr><tr>
            <td class="black">245</td>
            <td>      else nodes
</td>
          </tr><tr>
            <td class="black">246</td>
            <td>      val res = if (filterDuplicates)
</td>
          </tr><tr>
            <td class="black">247</td>
            <td>        // remove dups, explicitly use ref instead of same paths
</td>
          </tr><tr>
            <td class="black">248</td>
            <td>        DuplicateFilter(potentiallySorted)(org.scales.utils.DuplicateImplicits.sameRef)
</td>
          </tr><tr>
            <td class="black">249</td>
            <td>      else potentiallySorted
</td>
          </tr><tr>
            <td class="green">250</td>
            <td>      */ newThis(XPathInfo(nodes, performSort, filterDuplicates))
</td>
          </tr><tr>
            <td class="black">251</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">252</td>
            <td>
</td>
          </tr><tr>
            <td class="black">253</td>
            <td>    def empty: Iterable[XmlPath]
</td>
          </tr><tr>
            <td class="black">254</td>
            <td>    def just(only: XmlPath): Iterable[XmlPath]
</td>
          </tr><tr>
            <td class="black">255</td>
            <td>
</td>
          </tr><tr>
            <td class="black">256</td>
            <td>    /**
</td>
          </tr><tr>
            <td class="black">257</td>
            <td>     * 0 index based, not spec, but unsure if it should be
</td>
          </tr><tr>
            <td class="black">258</td>
            <td>     */
</td>
          </tr><tr>
            <td class="black">259</td>
            <td>    def pos(pos: =&gt; Int): XPath[T] =
</td>
          </tr><tr>
            <td class="green">260</td>
            <td>      process {
</td>
          </tr><tr>
            <td class="black">261</td>
            <td>        path.nodes.
</td>
          </tr><tr>
            <td class="black">262</td>
            <td>          flatMap { path =&gt;
</td>
          </tr><tr>
            <td class="green">263</td>
            <td>            val n = path.take(pos)
</td>
          </tr><tr>
            <td class="black">264</td>
            <td>            //val res = 
</td>
          </tr><tr>
            <td class="yellow">265</td>
            <td>            if (n.size != pos) <span class="non">empty
</span></td>
          </tr><tr>
            <td class="green">266</td>
            <td>            else one(just(n.last))
</td>
          </tr><tr>
            <td class="black">267</td>
            <td>            // println (&quot;got path &quot; + path + &quot; n &quot; + n +&quot; res &quot; + res)
</td>
          </tr><tr>
            <td class="black">268</td>
            <td>
</td>
          </tr><tr>
            <td class="black">269</td>
            <td>            //res
</td>
          </tr><tr>
            <td class="black">270</td>
            <td>          }
</td>
          </tr><tr>
            <td class="black">271</td>
            <td>        //  path.nodes.drop(pos).take(1) 
</td>
          </tr><tr>
            <td class="black">272</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">273</td>
            <td>
</td>
          </tr><tr>
            <td class="black">274</td>
            <td>    /** Parents of these paths */
</td>
          </tr><tr>
            <td class="black">275</td>
            <td>    def \^ : XPath[T] =
</td>
          </tr><tr>
            <td class="black">276</td>
            <td>      /* must process dups
</td>
          </tr><tr>
            <td class="black">277</td>
            <td>       * flatten, only each elem should get through anyway
</td>
          </tr><tr>
            <td class="black">278</td>
            <td>       */
</td>
          </tr><tr>
            <td class="green">279</td>
            <td>      process(path.nodes.flatMap { path =&gt;
</td>
          </tr><tr>
            <td class="green">280</td>
            <td>  path.flatMap { x =&gt;
</td>
          </tr><tr>
            <td class="yellow">281</td>
            <td>          if (x.top.isLeft) <span class="non">empty
</span></td>
          </tr><tr>
            <td class="green">282</td>
            <td>          else one(just(x.top.right.get))
</td>
          </tr><tr>
            <td class="black">283</td>
            <td>        }
</td>
          </tr><tr>
            <td class="red">284</td>
            <td>      }, filterDuplicates = <span class="non">true)
</span></td>
          </tr><tr>
            <td class="black">285</td>
            <td>
</td>
          </tr><tr>
            <td class="black">286</td>
            <td>    /** simply forwards the current context, element\item specific versions exist that step downwards in document order */
</td>
          </tr><tr>
            <td class="black">287</td>
            <td>    def \ : XPath[T] =
</td>
          </tr><tr>
            <td class="yellow">288</td>
            <td>      newThis(path.copy(initialNode = <span class="non">false))
</span></td>
          </tr><tr>
            <td class="black">289</td>
            <td>
</td>
          </tr><tr>
            <td class="black">290</td>
            <td>    /**
</td>
          </tr><tr>
            <td class="black">291</td>
            <td>     * all children unpacked, normal xpath requires the context in E1/E2, which hugely complicates things, so \ is this, \+ is \ in the case where unpacking is needed
</td>
          </tr><tr>
            <td class="black">292</td>
            <td>     * which just leaves \* varieties for elements.
</td>
          </tr><tr>
            <td class="black">293</td>
            <td>     */
</td>
          </tr><tr>
            <td class="black">294</td>
            <td>    def \+ : XPath[T] =
</td>
          </tr><tr>
            <td class="green">295</td>
            <td>      process(path.nodes.flatMap {
</td>
          </tr><tr>
            <td class="green">296</td>
            <td>        _.flatMap { child =&gt;
</td>
          </tr><tr>
            <td class="yellow">297</td>
            <td>          if (child.isItem) <span class="non">just(child)
</span></td>
          </tr><tr>
            <td class="green">298</td>
            <td>          else one(child) //: Iterable[XmlPath] 
</td>
          </tr><tr>
            <td class="black">299</td>
            <td>        }
</td>
          </tr><tr>
            <td class="black">300</td>
            <td>      })
</td>
          </tr><tr>
            <td class="black">301</td>
            <td>
</td>
          </tr><tr>
            <td class="black">302</td>
            <td>    /** all descendants on the basis that we are eager */
</td>
          </tr><tr>
            <td class="black">303</td>
            <td>    def e_\\ : XPath[T] = {
</td>
          </tr><tr>
            <td class="black">304</td>
            <td>
</td>
          </tr><tr>
            <td class="black">305</td>
            <td>      // can't be tail recursive :&lt;
</td>
          </tr><tr>
            <td class="black">306</td>
            <td>      //      @scala.annotation.tailrec
</td>
          </tr><tr>
            <td class="black">307</td>
            <td>      def recUnpack(xmlPath: Iterable[XmlPath]): List[XmlPath] = {
</td>
          </tr><tr>
            <td class="green">308</td>
            <td>        var res : List[XmlPath] = Nil
</td>
          </tr><tr>
            <td class="black">309</td>
            <td>
</td>
          </tr><tr>
            <td class="green">310</td>
            <td>  val i = xmlPath.iterator
</td>
          </tr><tr>
            <td class="green">311</td>
            <td>  while(i.hasNext) {
</td>
          </tr><tr>
            <td class="green">312</td>
            <td>    val child = i.next
</td>
          </tr><tr>
            <td class="green">313</td>
            <td>    if (child.isItem) res = child :: res
</td>
          </tr><tr>
            <td class="black">314</td>
            <td>    else {
</td>
          </tr><tr>
            <td class="black">315</td>
            <td>            // child first then its kids
</td>
          </tr><tr>
            <td class="green">316</td>
            <td>            res = (child :: res ).reverse_::: (
</td>
          </tr><tr>
            <td class="black">317</td>
            <td>        recUnpack(child: Iterable[XmlPath]) )
</td>
          </tr><tr>
            <td class="black">318</td>
            <td>          }
</td>
          </tr><tr>
            <td class="black">319</td>
            <td>  }
</td>
          </tr><tr>
            <td class="green">320</td>
            <td>  res
</td>
          </tr><tr>
            <td class="black">321</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">322</td>
            <td>
</td>
          </tr><tr>
            <td class="green">323</td>
            <td>      process(
</td>
          </tr><tr>
            <td class="green">324</td>
            <td>        (if (path.initialNode) path.nodes // crazy initial expression thing 3.2 in http://www.w3.org/TR/xpath20/#id-path-expressions
</td>
          </tr><tr>
            <td class="green">325</td>
            <td>        else List())
</td>
          </tr><tr>
            <td class="green">326</td>
            <td>          ++ path.nodes.flatMap { recUnpack(_) })
</td>
          </tr><tr>
            <td class="black">327</td>
            <td>    } 
</td>
          </tr><tr>
            <td class="black">328</td>
            <td>
</td>
          </tr><tr>
            <td class="black">329</td>
            <td>    /** all descendants on the basis that we are probably lazy */
</td>
          </tr><tr>
            <td class="black">330</td>
            <td>    def l_\\ : XPath[T] = {
</td>
          </tr><tr>
            <td class="black">331</td>
            <td>      // can't be tail recursive :&lt;
</td>
          </tr><tr>
            <td class="black">332</td>
            <td>      //      @scala.annotation.tailrec
</td>
          </tr><tr>
            <td class="black">333</td>
            <td>      def recUnpack(xmlPath: Iterable[XmlPath]): Iterable[XmlPath] =
</td>
          </tr><tr>
            <td class="green">334</td>
            <td>        xmlPath.flatMap { child =&gt;
</td>
          </tr><tr>
            <td class="green">335</td>
            <td>          if (child.isItem) just(child) 
</td>
          </tr><tr>
            <td class="black">336</td>
            <td>    else {
</td>
          </tr><tr>
            <td class="black">337</td>
            <td>            // child first then its kids
</td>
          </tr><tr>
            <td class="green">338</td>
            <td>            just(child) ++
</td>
          </tr><tr>
            <td class="black">339</td>
            <td>              recUnpack(child: Iterable[XmlPath])
</td>
          </tr><tr>
            <td class="black">340</td>
            <td>          }
</td>
          </tr><tr>
            <td class="black">341</td>
            <td>        }
</td>
          </tr><tr>
            <td class="black">342</td>
            <td>
</td>
          </tr><tr>
            <td class="green">343</td>
            <td>      process(
</td>
          </tr><tr>
            <td class="green">344</td>
            <td>        (if (path.initialNode) path.nodes // crazy initial expression thing 3.2 in http://www.w3.org/TR/xpath20/#id-path-expressions
</td>
          </tr><tr>
            <td class="green">345</td>
            <td>        else List())
</td>
          </tr><tr>
            <td class="green">346</td>
            <td>          ++ path.nodes.flatMap { recUnpack(_) })
</td>
          </tr><tr>
            <td class="black">347</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">348</td>
            <td>
</td>
          </tr><tr>
            <td class="black">349</td>
            <td>    /**
</td>
          </tr><tr>
            <td class="black">350</td>
            <td>     * All descendants, uses XPathInfo eager to choose an implementation
</td>
          </tr><tr>
            <td class="black">351</td>
            <td>     */ 
</td>
          </tr><tr>
            <td class="black">352</td>
            <td>    def \\ : XPath[T] =
</td>
          </tr><tr>
            <td class="green">353</td>
            <td>      if (path.eager) e_\\
</td>
          </tr><tr>
            <td class="green">354</td>
            <td>      else l_\\
</td>
          </tr><tr>
            <td class="black">355</td>
            <td>
</td>
          </tr><tr>
            <td class="black">356</td>
            <td>
</td>
          </tr><tr>
            <td class="black">357</td>
            <td>    /** filter through the current matches */
</td>
          </tr><tr>
            <td class="black">358</td>
            <td>    def filter(pred: XmlPath =&gt; Boolean): XPath[T] =
</td>
          </tr><tr>
            <td class="green">359</td>
            <td>      process(path.nodes.map{ path =&gt; path.filter(pred) })
</td>
          </tr><tr>
            <td class="black">360</td>
            <td>
</td>
          </tr><tr>
            <td class="black">361</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">362</td>
            <td>
</td>
          </tr><tr>
            <td class="black">363</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">364</td>
            <td>   * Unlike XPath spec no reverse axis are directly provided by the dsl
</td>
          </tr><tr>
            <td class="black">365</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">366</td>
            <td><a id="Trait_scales_xml_XmlPaths_SiblingsAxis"></a>  trait SiblingsAxis extends Axis {
</td>
          </tr><tr>
            <td class="black">367</td>
            <td>
</td>
          </tr><tr>
            <td class="black">368</td>
            <td>    /**
</td>
          </tr><tr>
            <td class="black">369</td>
            <td>     * Unlike XPath spec returns all children in document order
</td>
          </tr><tr>
            <td class="black">370</td>
            <td>     * /
</td>
          </tr><tr>
            <td class="black">371</td>
            <td>     * def preceding_sibling_:: : XPath[T] =
</td>
          </tr><tr>
            <td class="black">372</td>
            <td>     * process(path.nodes.flatMap{ path =&gt;
</td>
          </tr><tr>
            <td class="black">373</td>
            <td>     * // each preceding
</td>
          </tr><tr>
            <td class="black">374</td>
            <td>     * val pos = path.node.index
</td>
          </tr><tr>
            <td class="black">375</td>
            <td>     * path.zipUp.splitAt(pos)._1
</td>
          </tr><tr>
            <td class="black">376</td>
            <td>     * })
</td>
          </tr><tr>
            <td class="black">377</td>
            <td>     *
</td>
          </tr><tr>
            <td class="black">378</td>
            <td>     * def following_sibling_:: : XPath[T] =
</td>
          </tr><tr>
            <td class="black">379</td>
            <td>     * process(path.nodes.flatMap{ path =&gt;
</td>
          </tr><tr>
            <td class="black">380</td>
            <td>     * // each preceding
</td>
          </tr><tr>
            <td class="black">381</td>
            <td>     * val pos = path.node.index
</td>
          </tr><tr>
            <td class="black">382</td>
            <td>     * path.zipUp.splitAt(pos)._2.drop(1)
</td>
          </tr><tr>
            <td class="black">383</td>
            <td>     * })
</td>
          </tr><tr>
            <td class="black">384</td>
            <td>     *
</td>
          </tr><tr>
            <td class="black">385</td>
            <td>     * //filter(_.hasPreviousSibling == false))
</td>
          </tr><tr>
            <td class="black">386</td>
            <td>     */
</td>
          </tr><tr>
            <td class="black">387</td>
            <td>    /**
</td>
          </tr><tr>
            <td class="black">388</td>
            <td>     * predicates are in reverse doc order
</td>
          </tr><tr>
            <td class="black">389</td>
            <td>     */
</td>
          </tr><tr>
            <td class="black">390</td>
            <td>    //def preceding_sibling( pred )
</td>
          </tr><tr>
            <td class="black">391</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">392</td>
            <td>
</td>
          </tr><tr>
            <td class="black">393</td>
            <td>  /** The * and @ must be swapped otherwise its an annotation */
</td>
          </tr><tr>
            <td class="black">394</td>
            <td><a id="Trait_scales_xml_XmlPaths_AttributeAxis"></a>  trait AttributeAxis extends Axis {
</td>
          </tr><tr>
            <td class="black">395</td>
            <td>
</td>
          </tr><tr>
            <td class="black">396</td>
            <td>    def i_*@ : Iterable[AttributePath] =
</td>
          </tr><tr>
            <td class="green">397</td>
            <td>      path.nodes.flatMap {
</td>
          </tr><tr>
            <td class="green">398</td>
            <td>        _.flatMap { child =&gt; // we are looking only for immediate attribs, not kids
</td>
          </tr><tr>
            <td class="green">399</td>
            <td>          if (child.isItem == true) Nil
</td>
          </tr><tr>
            <td class="green">400</td>
            <td>          else child.tree.section.attributes.map { x =&gt;
</td>
          </tr><tr>
            <td class="green">401</td>
            <td>            AttributePath(x, child);
</td>
          </tr><tr>
            <td class="black">402</td>
            <td>          }
</td>
          </tr><tr>
            <td class="black">403</td>
            <td>        }
</td>
          </tr><tr>
            <td class="black">404</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">405</td>
            <td>    
</td>
          </tr><tr>
            <td class="black">406</td>
            <td>
</td>
          </tr><tr>
            <td class="black">407</td>
            <td>    /** All immediate attributes */
</td>
          </tr><tr>
            <td class="black">408</td>
            <td>    def *@ : AttributePaths[T] =
</td>
          </tr><tr>
            <td class="green">409</td>
            <td>      AttributePaths(i_*@, path, cbf)
</td>
          </tr><tr>
            <td class="black">410</td>
            <td>
</td>
          </tr><tr>
            <td class="black">411</td>
            <td>    /** Search for all immediate attributes with a matching predicate (allows localName only searches for example) */
</td>
          </tr><tr>
            <td class="black">412</td>
            <td>    def *@(pred: AttributePath =&gt; Boolean): AttributePaths[T] =
</td>
          </tr><tr>
            <td class="green">413</td>
            <td>      AttributePaths(i_*@.filter { pred(_) }, path, cbf)
</td>
          </tr><tr>
            <td class="black">414</td>
            <td>
</td>
          </tr><tr>
            <td class="black">415</td>
            <td>    /** Special case for AttributeQNames, only local and namespace match */
</td>
          </tr><tr>
            <td class="black">416</td>
            <td>    def *@[QT &lt;% AttributeQName](attrQname: QT): AttributePaths[T] =
</td>
          </tr><tr>
            <td class="green">417</td>
            <td>      *@({ attributePath: AttributePath =&gt; toQName(attributePath.attribute.name) =:= toQName(attrQname) })
</td>
          </tr><tr>
            <td class="black">418</td>
            <td>
</td>
          </tr><tr>
            <td class="black">419</td>
            <td>    /** Loose match for UnprefixedQNames only, only matches local and namespace */
</td>
          </tr><tr>
            <td class="black">420</td>
            <td>    def *@(qname: UnprefixedQName): AttributePaths[T] =
</td>
          </tr><tr>
            <td class="green">421</td>
            <td>      *@({ attributePath: AttributePath =&gt; toQName(attributePath.attribute.name) =:= qname })
</td>
          </tr><tr>
            <td class="black">422</td>
            <td>
</td>
          </tr><tr>
            <td class="black">423</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">424</td>
            <td>
</td>
          </tr><tr>
            <td class="black">425</td>
            <td><a id="Trait_scales_xml_XmlPaths_ElementStep"></a>  trait ElementStep extends Axis {
</td>
          </tr><tr>
            <td class="black">426</td>
            <td>
</td>
          </tr><tr>
            <td class="black">427</td>
            <td>    /** all element children */
</td>
          </tr><tr>
            <td class="black">428</td>
            <td>    private[this] def \*- : XPath[T] =
</td>
          </tr><tr>
            <td class="green">429</td>
            <td>      process(path.nodes.flatMap {
</td>
          </tr><tr>
            <td class="green">430</td>
            <td>  _.filter {!_.isItem}
</td>
          </tr><tr>
            <td class="black">431</td>
            <td>      })
</td>
          </tr><tr>
            <td class="black">432</td>
            <td>
</td>
          </tr><tr>
            <td class="black">433</td>
            <td>    /** Search for all immediate child elements with a matching qname */
</td>
          </tr><tr>
            <td class="green">434</td>
            <td>    def *(qname: QName): XPath[T] = filter(x =&gt; x.isItem == false &amp;&amp; qname =:= x.tree.section.name)
</td>
          </tr><tr>
            <td class="black">435</td>
            <td>
</td>
          </tr><tr>
            <td class="black">436</td>
            <td>    def \*(qname: QName): XPath[T] = 
</td>
          </tr><tr>
            <td class="green">437</td>
            <td>       \*-.*(qname)
</td>
          </tr><tr>
            <td class="black">438</td>
            <td>
</td>
          </tr><tr>
            <td class="black">439</td>
            <td>    /** Search for all immediate child elements matching the predicate*/
</td>
          </tr><tr>
            <td class="green">440</td>
            <td>    def *(pred: XmlPath =&gt; Boolean): XPath[T] = filter(x =&gt; x.isItem == false &amp;&amp; pred(x))
</td>
          </tr><tr>
            <td class="black">441</td>
            <td>
</td>
          </tr><tr>
            <td class="green">442</td>
            <td>    def \*(pred: XmlPath =&gt; Boolean): XPath[T] = \*-.*(pred)
</td>
          </tr><tr>
            <td class="black">443</td>
            <td>
</td>
          </tr><tr>
            <td class="black">444</td>
            <td>    /** Immediate child with position pos, should only be an element. NOTE this will always be evaluated in place and is 1 indexed */
</td>
          </tr><tr>
            <td class="black">445</td>
            <td>    def *(pos: Int): XPath[T] = {
</td>
          </tr><tr>
            <td class="green">446</td>
            <td>      val res = path.nodes.flatMap { path =&gt;
</td>
          </tr><tr>
            <td class="green">447</td>
            <td>        val n = path.filter(_.isItem == false).take(pos)
</td>
          </tr><tr>
            <td class="green">448</td>
            <td>        if (n.size != pos) empty
</td>
          </tr><tr>
            <td class="green">449</td>
            <td>        else one(just(n.last))
</td>
          </tr><tr>
            <td class="black">450</td>
            <td>      }
</td>
          </tr><tr>
            <td class="green">451</td>
            <td>      process(res)
</td>
          </tr><tr>
            <td class="black">452</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">453</td>
            <td>
</td>
          </tr><tr>
            <td class="green">454</td>
            <td>    def \*(pos: Int): XPath[T] = \*-.*(pos)
</td>
          </tr><tr>
            <td class="black">455</td>
            <td>
</td>
          </tr><tr>
            <td class="black">456</td>
            <td>    /** all child elements */
</td>
          </tr><tr>
            <td class="black">457</td>
            <td>    def * : XPath[T] =
</td>
          </tr><tr>
            <td class="green">458</td>
            <td>      filter(_.isItem == false)
</td>
          </tr><tr>
            <td class="black">459</td>
            <td>    //process(path.nodes.flatMap{ _.filter(_.isItem == false) })
</td>
          </tr><tr>
            <td class="black">460</td>
            <td>
</td>
          </tr><tr>
            <td class="green">461</td>
            <td>    def \* : XPath[T] = \*-.*
</td>
          </tr><tr>
            <td class="black">462</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">463</td>
            <td>
</td>
          </tr><tr>
            <td class="black">464</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">465</td>
            <td>   * Little depature from standard, rather than duplicate all of the \ and \\ nodes, just a simple \\*() comment() will do
</td>
          </tr><tr>
            <td class="black">466</td>
            <td>   *
</td>
          </tr><tr>
            <td class="black">467</td>
            <td>   * NOTE these have a large performance hit as the must sort and filter the results in order to get doc order.  Better to use specific nodes
</td>
          </tr><tr>
            <td class="black">468</td>
            <td>   * avoiding \\ etc, then use the s for simple functions, sutext etc for simple useful.  Additionally using the non simple versions incurs the cost
</td>
          </tr><tr>
            <td class="black">469</td>
            <td>   * of adding adjacent text node processing as per standard datamodel (all adjacent text nodes are joined and any resulting nodes that are &quot;the zero-length string&quot; '' are removed).
</td>
          </tr><tr>
            <td class="black">470</td>
            <td>   *
</td>
          </tr><tr>
            <td class="black">471</td>
            <td>   * TODO xpath adjacent text node handling
</td>
          </tr><tr>
            <td class="black">472</td>
            <td>   *
</td>
          </tr><tr>
            <td class="black">473</td>
            <td>   * @author Chris
</td>
          </tr><tr>
            <td class="black">474</td>
            <td>   *
</td>
          </tr><tr>
            <td class="black">475</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">476</td>
            <td><a id="Trait_scales_xml_XmlPaths_OtherNodeTypes"></a>  trait OtherNodeTypes extends Axis {
</td>
          </tr><tr>
            <td class="black">477</td>
            <td>    /** all text child elements - not including cdata nodes, neither sorted nor dup filtered */
</td>
          </tr><tr>
            <td class="black">478</td>
            <td>    def textOnly: XPath[T] =
</td>
          </tr><tr>
            <td class="green">479</td>
            <td>      filter(x =&gt; x.isItem == true &amp;&amp; x.item().isInstanceOf[Text])
</td>
          </tr><tr>
            <td class="black">480</td>
            <td>
</td>
          </tr><tr>
            <td class="black">481</td>
            <td>    /** all text child elements - xpath standard way, including cdata nodes, filtered to join adjacent text nodes */
</td>
          </tr><tr>
            <td class="black">482</td>
            <td>    def text: XPath[T] =
</td>
          </tr><tr>
            <td class="green">483</td>
            <td>      filter(isText)
</td>
          </tr><tr>
            <td class="black">484</td>
            <td>
</td>
          </tr><tr>
            <td class="black">485</td>
            <td>    /** all cdata child elements */
</td>
          </tr><tr>
            <td class="black">486</td>
            <td>    def cdata: XPath[T] =
</td>
          </tr><tr>
            <td class="green">487</td>
            <td>      filter(x =&gt; x.isItem == true &amp;&amp; x.item().isInstanceOf[CData])
</td>
          </tr><tr>
            <td class="black">488</td>
            <td>
</td>
          </tr><tr>
            <td class="black">489</td>
            <td>    /** all commnent child elements */
</td>
          </tr><tr>
            <td class="black">490</td>
            <td>    def comment: XPath[T] =
</td>
          </tr><tr>
            <td class="green">491</td>
            <td>      filter(x =&gt; x.isItem == true &amp;&amp; x.item().isInstanceOf[Comment])
</td>
          </tr><tr>
            <td class="black">492</td>
            <td>
</td>
          </tr><tr>
            <td class="black">493</td>
            <td>    /** all pi child elements */
</td>
          </tr><tr>
            <td class="black">494</td>
            <td>    def pi: XPath[T] =
</td>
          </tr><tr>
            <td class="red">495</td>
            <td>      <span class="non">filter(x =&gt; x.isItem == true &amp;&amp; x.item().isInstanceOf[PI])
</span></td>
          </tr><tr>
            <td class="black">496</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">497</td>
            <td>
</td>
          </tr><tr>
            <td class="black">498</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">499</td>
            <td>
</td>
          </tr><tr>
            <td class="black">500</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">501</td>
            <td> * In contrast to the specs reverse axis are not supported.  This puts
</td>
          </tr><tr>
            <td class="black">502</td>
            <td> * an extra effort on the user for translating, but I don't agree with
</td>
          </tr><tr>
            <td class="black">503</td>
            <td> * the design anyway.  It adds both ambiguity for an embedded dsl:
</td>
          </tr><tr>
            <td class="black">504</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">505</td>
            <td> * //a:ShouldRedeclare/../text()[5]/preceding-sibling::text()[1]
</td>
          </tr><tr>
            <td class="black">506</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">507</td>
            <td> * is in reverse order (above is previousSibling in Path), whereas
</td>
          </tr><tr>
            <td class="black">508</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">509</td>
            <td> * (//a:ShouldRedeclare/../text()[5]/preceding-sibling::text())[1]
</td>
          </tr><tr>
            <td class="black">510</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">511</td>
            <td> * is in doc order (the first text child of the parent).  Such an arbritary decision does nothing but irritate.  A simpler design as found in this implementation is that the user can simply use full scala data functions to reverse as needed.
</td>
          </tr><tr>
            <td class="black">512</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">513</td>
            <td> * (Temptation is to provide the base type as SeqLike instead of Iterable as it should be in a sequence with a defined order, also then providing .reverse and friends)
</td>
          </tr><tr>
            <td class="black">514</td>
            <td> */
</td>
          </tr><tr>
            <td class="green">515</td>
            <td><a id="Class_scales_xml_XPath"></a>class XPath[PT &lt;: Iterable[XmlPath]](val path: XPathInfo, val cbf: CanBuildFrom[PT, XmlPath, PT]) extends ElementStep with OtherNodeTypes with AttributeAxis with SiblingsAxis {
</td>
          </tr><tr>
            <td class="black">516</td>
            <td>
</td>
          </tr><tr>
            <td class="black">517</td>
            <td>  type T = PT
</td>
          </tr><tr>
            <td class="black">518</td>
            <td>
</td>
          </tr><tr>
            <td class="black">519</td>
            <td>  def newThis(xpathInfo: XPathInfo): XPath[T] =
</td>
          </tr><tr>
            <td class="green">520</td>
            <td>    new XPath[T](xpathInfo, cbf)
</td>
          </tr><tr>
            <td class="black">521</td>
            <td>
</td>
          </tr><tr>
            <td class="green">522</td>
            <td>  def empty: Iterable[XmlPath] = cbf().result
</td>
          </tr><tr>
            <td class="green">523</td>
            <td>  def just(only: XmlPath): Iterable[XmlPath] = (cbf() += only).result
</td>
          </tr><tr>
            <td class="black">524</td>
            <td>
</td>
          </tr><tr>
            <td class="black">525</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">526</td>
            <td>   * Allow working within the XPath, easily extend and test
</td>
          </tr><tr>
            <td class="black">527</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">528</td>
            <td>  def in(f: (XPath[T]) =&gt; XPath[T]): XPath[T] =
</td>
          </tr><tr>
            <td class="green">529</td>
            <td>    f(this)
</td>
          </tr><tr>
            <td class="black">530</td>
            <td>
</td>
          </tr><tr>
            <td class="black">531</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">532</td>
            <td>   * Allow working within the XPath, easily extend and test
</td>
          </tr><tr>
            <td class="black">533</td>
            <td>   */
</td>
          </tr><tr>
            <td class="green">534</td>
            <td>  def |&gt;(f: (XPath[T]) =&gt; XPath[T]) = in(f)
</td>
          </tr><tr>
            <td class="black">535</td>
            <td>
</td>
          </tr><tr>
            <td class="black">536</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">537</td>
            <td>   * Some when its only one in the result set
</td>
          </tr><tr>
            <td class="black">538</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">539</td>
            <td>  def one: Iterable[XmlPath] = {
</td>
          </tr><tr>
            <td class="green">540</td>
            <td>    val nodes = ScalesXml.fromXPathToIterable(this)
</td>
          </tr><tr>
            <td class="yellow">541</td>
            <td>    if (nodes.size != 1) <span class="non">Nil
</span></td>
          </tr><tr>
            <td class="green">542</td>
            <td>    else scales.utils.one(nodes.head)
</td>
          </tr><tr>
            <td class="black">543</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">544</td>
            <td>
</td>
          </tr><tr>
            <td class="black">545</td>
            <td>  def oneOr(handler: XPath[T] =&gt; Iterable[XmlPath]) = {
</td>
          </tr><tr>
            <td class="red">546</td>
            <td>    val nodes = <span class="non">ScalesXml.fromXPathToIterable(this)
</span></td>
          </tr><tr>
            <td class="red">547</td>
            <td>    if (<span class="non">nodes.size == 1) scales.utils.one(nodes.head)
</span></td>
          </tr><tr>
            <td class="red">548</td>
            <td>    else <span class="non">handler(this)
</span></td>
          </tr><tr>
            <td class="black">549</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">550</td>
            <td>
</td>
          </tr><tr>
            <td class="black">551</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">552</td>
            <td>   * Union of the two paths, they must use the same type however
</td>
          </tr><tr>
            <td class="black">553</td>
            <td>   *
</td>
          </tr><tr>
            <td class="black">554</td>
            <td>   * x | x === x but only when apply fromXPathToIterable (default behaviour anyway)
</td>
          </tr><tr>
            <td class="black">555</td>
            <td>   *
</td>
          </tr><tr>
            <td class="black">556</td>
            <td>   * For attribute paths only ++ on an iterable is supported.
</td>
          </tr><tr>
            <td class="black">557</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">558</td>
            <td>  def |( other : XPath[T] ) : XPath[T] = 
</td>
          </tr><tr>
            <td class="green">559</td>
            <td>    new XPath(XPathInfo( 
</td>
          </tr><tr>
            <td class="black">560</td>
            <td>      nodes = path.nodes ++ other.path.nodes, 
</td>
          </tr><tr>
            <td class="black">561</td>
            <td>      mustBeSorted = true, filterDuplicates = true, initialNode = false, eager = path.eager | other.path.eager), cbf)
</td>
          </tr><tr>
            <td class="black">562</td>
            <td>  
</td>
          </tr><tr>
            <td class="black">563</td>
            <td>  // TODO figure out unions of other paths (namespaces / attributes)
</td>
          </tr><tr>
            <td class="black">564</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">565</td>
            <td>
</td>
          </tr><tr>
            <td class="black">566</td>
            <td>/** Attributes that have been selected */
</td>
          </tr><tr>
            <td class="green">567</td>
            <td>case class AttributePaths[PT &lt;: Iterable[XmlPath]](attributes: Iterable[AttributePath], path: XPathInfo, cbf: CanBuildFrom[PT, XmlPath, PT]) {
</td>
          </tr><tr>
            <td class="black">568</td>
            <td>  import ScalesXml._
</td>
          </tr><tr>
            <td class="black">569</td>
            <td>  /** Parents of the attributepaths */
</td>
          </tr><tr>
            <td class="green">570</td>
            <td>  def \^(): XPath[PT] = new XPath[PT](path.copy(nodes = List(attributes.map(_.parent))), cbf)
</td>
          </tr><tr>
            <td class="black">571</td>
            <td>
</td>
          </tr><tr>
            <td class="black">572</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">573</td>
            <td>   * Some if there is one, else none
</td>
          </tr><tr>
            <td class="black">574</td>
            <td>   */
</td>
          </tr><tr>
            <td class="yellow">575</td>
            <td>  def one: Iterable[AttributePath] = if (attributes.size != 1) <span class="non">Nil else </span>scales.utils.one(attributes.head)
</td>
          </tr><tr>
            <td class="black">576</td>
            <td>
</td>
          </tr><tr>
            <td class="black">577</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">578</td>
            <td>   * Some if there is one, else calls handler (allows decisions based on more than one etc.
</td>
          </tr><tr>
            <td class="black">579</td>
            <td>   */
</td>
          </tr><tr>
            <td class="red">580</td>
            <td>  def oneOr(handler: Iterable[AttributePath] =&gt; Iterable[AttributePath]) = if (<span class="non">attributes.size == 1) scales.utils.one(attributes.head) else handler(attributes)
</span></td>
          </tr><tr>
            <td class="black">581</td>
            <td>
</td>
          </tr><tr>
            <td class="black">582</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">583</td>
            <td>
</td>
          </tr><tr>
            <td class="black">584</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">585</td>
            <td> * XPaths need sorting upon unions etc, and duplicate filtering on \^ parents
</td>
          </tr><tr>
            <td class="black">586</td>
            <td> */
</td>
          </tr><tr>
            <td class="green">587</td>
            <td>case class XPathInfo(nodes: Iterable[Iterable[XmlPath]], mustBeSorted: Boolean = false, filterDuplicates: Boolean = false, initialNode: Boolean = false, eager : Boolean = false)
</td>
          </tr></tbody></table>