<?xml version="1.0" encoding="utf-8"?>
			<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>scales\utils\Paths.scala</title>
        <script type="text/javascript" src="../../jquery-all.js"></script>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style"></link>
    
<style id="linesStyle">
.lineHighlight {
  background-color: #a5a5a5;
}
</style>
<script type="text/javascript">
function selectedLine() {
    var loca = /^.*#l(.*)/.exec(location.href);
    return loca ? loca[1] : '0';
}

function highlightLine(ln){
  $('#l'+ln).toggleClass('lineHighlight');
}

function gotoLine(ln){
  $('#l'+ln).focus();
}

$(function(){
  var line = selectedLine();
  if (line != '0') highlightLine(line)
});
</script></head>
    <body>
        <pre>
<!-- SXR_LINES --><a href="l1"></a><span id="l1"><span class="keyword">package</span> scales.utils</span>
<a href="l2"></a><span id="l2"></span>
<a href="l3"></a><span id="l3"><span class="keyword">import</span> scales.utils._</span>
<a href="l4"></a><span id="l4"></span>
<a href="l5"></a><span id="l5"><span class="keyword">import</span> scala.collection.immutable.Stack</span>
<a href="l6"></a><span id="l6"><span class="keyword">import</span> scala.collection.IndexedSeqLike</span>
<a href="l7"></a><span id="l7"><span class="keyword">import</span> scala.collection.generic.CanBuildFrom</span>
<a href="l8"></a><span id="l8"></span>
<a href="l9"></a><span id="l9"><span class="keyword">trait</span> <a title="trait Paths extends java.lang.Object with ScalaObject" id="10509">Paths</a> <span title="ScalaObject" class="delimiter">{</span></span>
<a href="l10"></a><span id="l10">  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](implicit cbf: scales.utils.package.TreeCBF[Item,Section,CC])scales.utils.Path[Item,Section,CC]" id="12204">noPath</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="12208">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="12209">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="12210">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="79452">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span></span>
<a href="l11"></a><span id="l11">    <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scales.utils.package.TreeCBF[Item,Section,CC]" id="79448">cbf</a> : <span title="scales.utils.package.TreeCBF[Item,Section,CC]">TreeCBF</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>  = <a href="#79451" title="scales.utils.Path[Item,Section,CC]" class="keyword">new</a> <a title="anonymous class $anon extends scales.utils.Path[Item,Section,CC]" id="79451">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">(</span><a href="#84613" title="()scales.utils.Top[Item,Section,CC]">Top</a><span class="delimiter">(</span><span class="delimiter">)</span>, <a href="#84597" title="(index: Int, focus: scales.utils.package.ItemOrTree[Item,Section,CC])scales.utils.Node[Item,Section,CC]">Node</a><span class="delimiter">(</span>-<span title="Int(-1)" class="int">1</span>, <span title="Null(null)" class="keyword">null</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="scales.utils.package.ItemOrTree[Item,Section,CC]" class="delimiter">[</span><a href="EitherLike.scala.html#10328" title="scales.utils.package.ItemOrTree[Item,Section,CC]">ItemOrTree</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span></span>
<a href="l12"></a><span id="l12">  <span class="delimiter">}</span></span>
<a href="l13"></a><span id="l13"></span>
<a href="l14"></a><span id="l14">  <span class="comment">/**</span>
<a href="l15"></a><span id="l15">   * Returns the root path for its input, uses zipUp to ensure changes are kept</span>
<a href="l16"></a><span id="l16">   */</span></span>
<a href="l17"></a><span id="l17">  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](path: scales.utils.Path[Item,Section,CC])scales.utils.Path[Item,Section,CC]" id="12211">rootPath</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="12215">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="12216">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="12217">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="79539">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC]" id="79538">path</a>: <a href="#84591" title="scales.utils.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#84591" title="scales.utils.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> = <span class="delimiter">{</span></span>
<a href="l18"></a><span id="l18">    <span class="keyword">var</span> <a title="scales.utils.Path[Item,Section,CC]" id="79542">newPath</a> = <a href="#79538" title="scales.utils.Path[Item,Section,CC]">path</a></span>
<a href="l19"></a><span id="l19">    <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#79542" title="scales.utils.Path[Item,Section,CC]">newPath</a>.<a href="#67394" title="=&gt; scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]]">top</a>.<a href="EitherLike.scala.html#39633" title="=&gt; Boolean">isLeft</a><span class="delimiter">)</span></span>
<a href="l20"></a><span id="l20">      <a href="#79542" title="scales.utils.Path[Item,Section,CC]">newPath</a> = <a href="#79542" title="scales.utils.Path[Item,Section,CC]">newPath</a>.<a href="#39615" title="()scales.utils.Path[Item,Section,CC]">zipUp</a></span>
<a href="l21"></a><span id="l21">    <a href="#79542" title="scales.utils.Path[Item,Section,CC]">newPath</a></span>
<a href="l22"></a><span id="l22">  <span class="delimiter">}</span></span>
<a href="l23"></a><span id="l23"></span>
<a href="l24"></a><span id="l24">  <span class="comment">/**</span>
<a href="l25"></a><span id="l25">   * Navigates the path until the new position is reached, throws if either its a new root or the position is not reachable</span>
<a href="l26"></a><span id="l26">   */</span></span>
<a href="l27"></a><span id="l27">  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](path: scales.utils.Path[Item,Section,CC], newPos: scales.utils.Position[Item,Section,CC])(implicit cbf: scales.utils.package.TreeCBF[Item,Section,CC])scales.utils.Path[Item,Section,CC]" id="12218">moveTo</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="12222">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="12223">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="12224">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="79548">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC]" id="79545">path</a>: <a href="#84591" title="scales.utils.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, <a title="scales.utils.Position[Item,Section,CC]" id="79546">newPos</a>: <a href="#10517" title="scales.utils.Position[Item,Section,CC]">Position</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span></span>
<a href="l28"></a><span id="l28">    <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scales.utils.package.TreeCBF[Item,Section,CC]" id="79547">cbf</a> : <span title="scales.utils.package.TreeCBF[Item,Section,CC]">TreeCBF</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> : <a href="#84591" title="scales.utils.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> = <span class="delimiter">{</span></span>
<a href="l29"></a><span id="l29"></span>
<a href="l30"></a><span id="l30">    <span class="keyword">val</span> <a title="scales.utils.Path[Item,Section,CC]" id="79553">root</a> = <a href="#12211" title="(path: scales.utils.Path[Item,Section,CC])scales.utils.Path[Item,Section,CC]">rootPath</a><span class="delimiter">(</span><a href="#79545" title="scales.utils.Path[Item,Section,CC]">path</a><span class="delimiter">)</span></span>
<a href="l31"></a><span id="l31">    <span class="comment">// cheaty way, crap but quick enough</span></span>
<a href="l32"></a><span id="l32">    <span class="comment">// TODO come back to this and properly move,</span></span>
<a href="l33"></a><span id="l33">    <a href="#79546" title="scales.utils.Position[Item,Section,CC]">newPos</a>.<a href="#39264" title="=&gt; scala.collection.immutable.Stack[Int]">position</a>.<span title="=&gt; scala.collection.immutable.Stack[Int]">pop</span>.<span title="(z: scales.utils.Path[Item,Section,CC])(f: (scales.utils.Path[Item,Section,CC], Int) =&gt; scales.utils.Path[Item,Section,CC])scales.utils.Path[Item,Section,CC]">foldLeft</span><span class="delimiter">(</span><a href="#79553" title="scales.utils.Path[Item,Section,CC]">root</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC]" id="79674">path</a>, <a title="Int" id="79675">pos</a><span class="delimiter">)</span> =&gt;</span>
<a href="l34"></a><span id="l34">      <a href="#84591" title="(top: scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]], node: scales.utils.Node[Item,Section,CC])(implicit cbf: scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]])scales.utils.Path[Item,Section,CC]">Path</a><a href="#79547" title="scales.utils.package.TreeCBF[Item,Section,CC]" class="delimiter">(</a><a href="#79674" title="scales.utils.Path[Item,Section,CC]">path</a>, <a href="#84597" title="(index: Int, focus: scales.utils.package.ItemOrTree[Item,Section,CC])scales.utils.Node[Item,Section,CC]">Node</a><span class="delimiter">(</span><a href="#79675" title="Int">pos</a>, <a href="#79674" title="scales.utils.Path[Item,Section,CC]">path</a>.<a href="#39605" title="(idx: Int)scales.utils.package.ItemOrTree[Item,Section,CC]">children</a><span class="delimiter">(</span><a href="#79675" title="Int">pos</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l35"></a><span id="l35">    <span class="delimiter">}</span></span>
<a href="l36"></a><span id="l36">  <span class="delimiter">}</span></span>
<a href="l37"></a><span id="l37"></span>
<a href="l38"></a><span id="l38">  <span class="keyword">type</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]]Either[scales.utils.Path[Item,Section,CC],scales.utils.FoldError]" id="12225">FoldR</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="12226">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="12227">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="12228">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="67513">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> = <span title="Either[scales.utils.Path[Item,Section,CC],scales.utils.FoldError]">Either</span><span class="delimiter">[</span>Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, FoldError<span class="delimiter">]</span></span>
<a href="l39"></a><span id="l39"></span>
<a href="l40"></a><span id="l40">  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](base: scales.utils.Position[Item,Section,CC], x: scales.utils.Position[Item,Section,CC], by: Int)scales.utils.Position[Item,Section,CC]" id="12229">shiftWithBase</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="12233">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="12234">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="12235">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="79737">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="scales.utils.Position[Item,Section,CC]" id="79734">base</a>: <a href="#10517" title="scales.utils.Position[Item,Section,CC]">Position</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, <a title="scales.utils.Position[Item,Section,CC]" id="79735">x</a>: <a href="#10517" title="scales.utils.Position[Item,Section,CC]">Position</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, <a title="Int" id="79736">by</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#10517" title="scales.utils.Position[Item,Section,CC]">Position</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> = <span class="delimiter">{</span></span>
<a href="l41"></a><span id="l41">    <span class="keyword">val</span> <a title="scala.collection.immutable.Stack[Int]" id="79742">up</a> = <a href="#79734" title="scales.utils.Position[Item,Section,CC]">base</a>.<a href="#39264" title="=&gt; scala.collection.immutable.Stack[Int]">position</a>.<span title="=&gt; scala.collection.immutable.Stack[Int]">reverse</span>.<span title="=&gt; scala.collection.immutable.Stack[Int]">pop</span>.<span title="=&gt; scala.collection.immutable.Stack[Int]">reverse</span> <span class="comment">// stack needs to be flipped to get parent</span></span>
<a href="l42"></a><span id="l42">    <span title="scales.utils.Position[Item,Section,CC]" class="keyword">if</span> <span class="delimiter">(</span><a href="StackUtils.scala.html#12096" title="(test: scala.collection.immutable.Stack[Int], against: scala.collection.immutable.Stack[Int])Boolean">sameBase</a><span class="delimiter">(</span><a href="#79742" title="scala.collection.immutable.Stack[Int]">up</a>, <a href="#79735" title="scales.utils.Position[Item,Section,CC]">x</a>.<a href="#39264" title="=&gt; scala.collection.immutable.Stack[Int]">position</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span></span>
<a href="l43"></a><span id="l43">      <span class="keyword">val</span> <a href="#79769" title="(scala.collection.immutable.Stack[Int], scala.collection.immutable.Stack[Int])" class="delimiter">(</a><a href="#79768" title="scala.collection.immutable.Stack[Int]" id="79769">above</a>, <a href="#79768" title="scala.collection.immutable.Stack[Int]" id="79770">below</a><span class="delimiter">)</span> = <a href="#79735" title="scales.utils.Position[Item,Section,CC]">x</a>.<a href="#39264" title="=&gt; scala.collection.immutable.Stack[Int]">position</a>.<span title="(n: Int)(scala.collection.immutable.Stack[Int], scala.collection.immutable.Stack[Int])">splitAt</span><span title="(scala.collection.immutable.Stack[Int], scala.collection.immutable.Stack[Int]) @unchecked" class="delimiter">(</span><a href="#79742" title="scala.collection.immutable.Stack[Int]">up</a>.<span title="=&gt; Int">size</span><span class="delimiter">)</span></span>
<a href="l44"></a><span id="l44">      <span class="keyword">val</span> <a title="Int" id="79771">oldv</a> = <a href="#79770" title="scala.collection.immutable.Stack[Int]">below</a>.<span title="=&gt; Int">top</span></span>
<a href="l45"></a><span id="l45">      <span class="keyword">val</span> <a title="scala.collection.immutable.Stack[Int]" id="79772">old</a> = <a href="#79770" title="scala.collection.immutable.Stack[Int]">below</a>.<span title="=&gt; scala.collection.immutable.Stack[Int]">pop</span></span>
<a href="l46"></a><span id="l46">      <span class="keyword">val</span> <a title="scala.collection.immutable.Stack[Int]" id="79773">newpos</a> = <a href="#79769" title="scala.collection.immutable.Stack[Int]">above</a> <span title="(that: scala.collection.GenTraversableOnce[Int])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stack[Int],Int,scala.collection.immutable.Stack[Int]])scala.collection.immutable.Stack[Int]">++</span> <span class="delimiter">(</span><a href="#79772" title="scala.collection.immutable.Stack[Int]">old</a>.<span title="(elem: Int)scala.collection.immutable.Stack[Int]">push</span><span class="delimiter">(</span><a href="#79771" title="Int">oldv</a> <span title="(x: Int)Int">+</span> <a href="#79736" title="Int">by</a><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l47"></a><span id="l47">      <span title="scales.utils.PositionImpl[Item,Section,CC]" class="keyword">new</span> <a href="#84609" title="scales.utils.PositionImpl[Item,Section,CC]">PositionImpl</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">(</span></span>
<a href="l48"></a><span id="l48">        <a href="#79773" title="scala.collection.immutable.Stack[Int]">newpos</a>,</span>
<a href="l49"></a><span id="l49">        <a href="#79735" title="scales.utils.Position[Item,Section,CC]">x</a>.<a href="#39263" title="=&gt; scales.utils.Path[Item,Section,CC]">root</a><span class="delimiter">)</span></span>
<a href="l50"></a><span id="l50">    <span class="delimiter">}</span> <span class="keyword">else</span> <a href="#79735" title="scales.utils.Position[Item,Section,CC]">x</a></span>
<a href="l51"></a><span id="l51">  <span class="delimiter">}</span></span>
<a href="l52"></a><span id="l52"></span>
<a href="l53"></a><span id="l53">  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](positions: Seq[scales.utils.Position[Item,Section,CC]])Seq[scales.utils.Position[Item,Section,CC]]" id="12236">cleanBelow</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="12240">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="12241">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="12242">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="80062">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[scales.utils.Position[Item,Section,CC]]" id="80061">positions</a>: <span title="Seq[scales.utils.Position[Item,Section,CC]]">Seq</span><span class="delimiter">[</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Seq[scales.utils.Position[Item,Section,CC]]">Seq</span><span class="delimiter">[</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#80061" title="Seq[scales.utils.Position[Item,Section,CC]]">positions</a>.<span title="(p: scales.utils.Position[Item,Section,CC] =&gt; Boolean)Seq[scales.utils.Position[Item,Section,CC]]">dropWhile</span> <span class="delimiter">{</span> <a title="scales.utils.Position[Item,Section,CC]" id="80068">x</a> =&gt;</span>
<a href="l54"></a><span id="l54">    <a href="StackUtils.scala.html#12096" title="(test: scala.collection.immutable.Stack[Int], against: scala.collection.immutable.Stack[Int])Boolean">sameBase</a><span class="delimiter">(</span><a href="#80061" title="Seq[scales.utils.Position[Item,Section,CC]]">positions</a>.<span title="=&gt; scales.utils.Position[Item,Section,CC]">head</span>.<a href="#39264" title="=&gt; scala.collection.immutable.Stack[Int]">position</a>, <a href="#80068" title="scales.utils.Position[Item,Section,CC]">x</a>.<a href="#39264" title="=&gt; scala.collection.immutable.Stack[Int]">position</a><span class="delimiter">)</span></span>
<a href="l55"></a><span id="l55">  <span class="delimiter">}</span></span>
<a href="l56"></a><span id="l56"></span>
<a href="l57"></a><span id="l57">  <span class="keyword">type</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]]scales.utils.Path[Item,Section,CC] =&gt; Paths.this.FoldR[Item,Section,CC]" id="12243">PathFoldR</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="12244">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="12245">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="12246">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="67301">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">(</span>Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; FoldR<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span></span>
<a href="l58"></a><span id="l58"></span>
<a href="l59"></a><span id="l59">  <span class="comment">/**</span>
<a href="l60"></a><span id="l60">   * Folds over positions within a single path, for example all given children.  As such positions must be calculated.</span>
<a href="l61"></a><span id="l61">   *</span>
<a href="l62"></a><span id="l62">   * Takes the first root, returning Right(NoSingleRoot) if any of the subsequent roots don't match.</span>
<a href="l63"></a><span id="l63">   *</span>
<a href="l64"></a><span id="l64">   * folder retrieves the current path</span>
<a href="l65"></a><span id="l65">   *</span>
<a href="l66"></a><span id="l66">   * Each iteration folds the resulting tree back into the path. As this function must maintain the Path it does not expose the new path root until the result.</span>
<a href="l67"></a><span id="l67">   */</span></span>
<a href="l68"></a><span id="l68">  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]], ACC](locations: Iterable[scales.utils.Path[Item,Section,CC]], accumulator: ACC)(folder: (ACC, scales.utils.Path[Item,Section,CC]) =&gt; (ACC, scales.utils.FoldOperation[Item,Section,CC]))(implicit cbf: scales.utils.package.TreeCBF[Item,Section,CC], implicit cm: ClassManifest[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])])Either[(ACC, scales.utils.Path[Item,Section,CC]),scales.utils.FoldError]" id="12247">foldPositions</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="12252">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="12253">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="12254">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="39587">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="12255">ACC</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Iterable[scales.utils.Path[Item,Section,CC]]" id="39582">locations</a>: <span title="Iterable[scales.utils.Path[Item,Section,CC]]">Iterable</span><span class="delimiter">[</span>Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="ACC" id="39583">accumulator</a>: <a href="#12255" title="ACC">ACC</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(ACC, scales.utils.Path[Item,Section,CC]) =&gt; (ACC, scales.utils.FoldOperation[Item,Section,CC])" id="39584">folder</a>: <span class="delimiter">(</span>ACC, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; <span class="delimiter">(</span>ACC, FoldOperation<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scales.utils.package.TreeCBF[Item,Section,CC]" id="39585">cbf</a> : <span title="scales.utils.package.TreeCBF[Item,Section,CC]">TreeCBF</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, <a title="ClassManifest[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])]" id="39586">cm</a> : <span title="ClassManifest[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])]">ClassManifest</span><span class="delimiter">[</span><span class="delimiter">(</span>scales.utils.Position<span class="delimiter">[</span>Item,Section,CC<span class="delimiter">]</span>, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span>  : <span title="Either[(ACC, scales.utils.Path[Item,Section,CC]),scales.utils.FoldError]">Either</span><span class="delimiter">[</span><span class="delimiter">(</span>ACC, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>, FoldError<span class="delimiter">]</span> = <span class="delimiter">{</span></span>
<a href="l69"></a><span id="l69">    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#39582" title="Iterable[scales.utils.Path[Item,Section,CC]]">locations</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <span title="(b: scales.utils.NoPaths.type)Right[Nothing,scales.utils.NoPaths.type]">Right</span><span class="delimiter">(</span><a href="#84492" title="object scales.utils.NoPaths">NoPaths</a><span class="delimiter">)</span></span>
<a href="l70"></a><span id="l70"></span>
<a href="l71"></a><span id="l71">    <span class="keyword">val</span> <a title="Iterable[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])]" id="80078">sorted</a> = <a href="#12327" title="(paths: Iterable[scales.utils.Path[Item,Section,CC]], isDescending: Boolean)(implicit cm: ClassManifest[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])])Iterable[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])]">sortPositions</a><a href="#39586" title="ClassManifest[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])]" class="delimiter">(</a><a href="#39582" title="Iterable[scales.utils.Path[Item,Section,CC]]">locations</a><span class="delimiter">)</span></span>
<a href="l72"></a><span id="l72"></span>
<a href="l73"></a><span id="l73">    <span class="keyword">val</span> <a title="(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])" id="80079">head</a> = <a href="#80078" title="Iterable[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])]">sorted</a>.<span title="=&gt; (scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])">head</span></span>
<a href="l74"></a><span id="l74">    <span class="keyword">var</span> <a title="ACC" id="80080">accum</a> = <a href="#39583" title="ACC">accumulator</a></span>
<a href="l75"></a><span id="l75"></span>
<a href="l76"></a><span id="l76">    <span class="keyword">val</span> <a title="scales.utils.Position[Item,Section,CC]" id="80081">rootPosition</a> = <a href="#80079" title="(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])">head</a>.<span title="=&gt; scales.utils.Position[Item,Section,CC]">_1</span></span>
<a href="l77"></a><span id="l77">    <span class="keyword">val</span> <a title="Boolean" id="80082">differentRoot</a> = <a href="#80078" title="Iterable[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])]">sorted</a>.<span title="(p: (scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC]) =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><a title="(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])" id="80141">p</a> =&gt; <a href="#80141" title="(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])">p</a>.<span title="=&gt; scales.utils.Position[Item,Section,CC]">_1</span>.<a href="#39263" title="=&gt; scales.utils.Path[Item,Section,CC]">root</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#80081" title="scales.utils.Position[Item,Section,CC]">rootPosition</a>.<a href="#39263" title="=&gt; scales.utils.Path[Item,Section,CC]">root</a><span class="delimiter">)</span></span>
<a href="l78"></a><span id="l78">    <span title="Either[(ACC, scales.utils.Path[Item,Section,CC]),scales.utils.FoldError]" class="keyword">if</span> <span class="delimiter">(</span><a href="#80082" title="Boolean">differentRoot</a><span class="delimiter">)</span></span>
<a href="l79"></a><span id="l79">      <span title="(b: scales.utils.NoSingleRoot.type)Right[Nothing,scales.utils.NoSingleRoot.type]">Right</span><span class="delimiter">(</span><a href="#84504" title="object scales.utils.NoSingleRoot">NoSingleRoot</a><span class="delimiter">)</span></span>
<a href="l80"></a><span id="l80">    <span class="keyword">else</span> <span class="delimiter">{</span></span>
<a href="l81"></a><span id="l81"></span>
<a href="l82"></a><span id="l82">      <span class="comment">// fold over positions, with the path from head, let each foldop decide what the next position sequence looks like</span></span>
<a href="l83"></a><span id="l83">      <span class="keyword">var</span> <a title="Seq[scales.utils.Position[Item,Section,CC]]" id="80147">positions</a> = <a href="#80078" title="Iterable[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])]">sorted</a>.<span title="(f: (scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC]) =&gt; scales.utils.Position[Item,Section,CC])(implicit bf: scala.collection.generic.CanBuildFrom[Iterable[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])],scales.utils.Position[Item,Section,CC],Iterable[scales.utils.Position[Item,Section,CC]]])Iterable[scales.utils.Position[Item,Section,CC]]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Iterable.Coll,scales.utils.Position[Item,Section,CC],Iterable[scales.utils.Position[Item,Section,CC]]]" class="delimiter">(</span><a href="#80166" title="(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])">_</a>.<span title="=&gt; scales.utils.Position[Item,Section,CC]">_1</span><span class="delimiter">)</span>.<span title="=&gt; Seq[scales.utils.Position[Item,Section,CC]]">toSeq</span></span>
<a href="l84"></a><span id="l84">      <span class="keyword">var</span> <a title="scales.utils.Path[Item,Section,CC]" id="80148">path</a> = <a href="#80079" title="(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])">head</a>.<span title="=&gt; scales.utils.Path[Item,Section,CC]">_2</span></span>
<a href="l85"></a><span id="l85">      <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#80147" title="Seq[scales.utils.Position[Item,Section,CC]]">positions</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#80149" title="()Unit" class="delimiter">{</a></span>
<a href="l86"></a><span id="l86"></span>
<a href="l87"></a><span id="l87">        <span class="keyword">val</span> <a href="#80237" title="(ACC, scales.utils.FoldOperation[Item,Section,CC])" class="delimiter">(</a><a href="#80236" title="ACC" id="80237">accf</a>, <a href="#80236" title="scales.utils.FoldOperation[Item,Section,CC]" id="80238">res</a><span class="delimiter">)</span> = <a href="#39584" title="(v1: ACC, v2: scales.utils.Path[Item,Section,CC])(ACC, scales.utils.FoldOperation[Item,Section,CC])">folder</a><span title="(ACC, scales.utils.FoldOperation[Item,Section,CC]) @unchecked" class="delimiter">(</span><a href="#80080" title="ACC">accum</a>, <a href="#80148" title="scales.utils.Path[Item,Section,CC]">path</a><span class="delimiter">)</span></span>
<a href="l88"></a><span id="l88">        <a href="#80080" title="ACC">accum</a> = <a href="#80237" title="ACC">accf</a></span>
<a href="l89"></a><span id="l89">        <span class="keyword">val</span> <a title="scales.utils.package.FoldR[Item,Section,CC]" id="80239">matched</a> = <a href="#80238" title="scales.utils.FoldOperation[Item,Section,CC]">res</a>.<a href="#80076" title="(path: scales.utils.Path[Item,Section,CC])scales.utils.package.FoldR[Item,Section,CC]">perform</a><span class="delimiter">(</span><a href="#80148" title="scales.utils.Path[Item,Section,CC]">path</a><span class="delimiter">)</span> <span class="comment">//matchIt( res, path )</span></span>
<a href="l90"></a><span id="l90"></span>
<a href="l91"></a><span id="l91">        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#80239" title="scales.utils.package.FoldR[Item,Section,CC]">matched</a>.<span title="=&gt; Boolean">isLeft</span><span class="delimiter">)</span> <span class="delimiter">{</span></span>
<a href="l92"></a><span id="l92">          <a href="#80148" title="scales.utils.Path[Item,Section,CC]">path</a> = <a href="#80239" title="scales.utils.package.FoldR[Item,Section,CC]">matched</a>.<span title="=&gt; Either.LeftProjection[scales.utils.Path[Item,Section,CC],scales.utils.FoldError]">left</span>.<span title="=&gt; scales.utils.Path[Item,Section,CC]">get</span></span>
<a href="l93"></a><span id="l93">          <a href="#80147" title="Seq[scales.utils.Position[Item,Section,CC]]">positions</a> = <a href="#80238" title="scales.utils.FoldOperation[Item,Section,CC]">res</a>.<a href="#80075" title="(positions: Seq[scales.utils.Position[Item,Section,CC]])Seq[scales.utils.Position[Item,Section,CC]]">adjust</a><span class="delimiter">(</span><a href="#80147" title="Seq[scales.utils.Position[Item,Section,CC]]">positions</a><span class="delimiter">)</span></span>
<a href="l94"></a><span id="l94">          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#80147" title="Seq[scales.utils.Position[Item,Section,CC]]">positions</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span class="delimiter">{</span></span>
<a href="l95"></a><span id="l95">            <a href="#80148" title="scales.utils.Path[Item,Section,CC]">path</a> = <a href="#12218" title="(path: scales.utils.Path[Item,Section,CC], newPos: scales.utils.Position[Item,Section,CC])(implicit cbf: scales.utils.package.TreeCBF[Item,Section,CC])scales.utils.Path[Item,Section,CC]">moveTo</a><a href="#39585" title="scales.utils.package.TreeCBF[Item,Section,CC]" class="delimiter">(</a><a href="#80148" title="scales.utils.Path[Item,Section,CC]">path</a>, <a href="#80147" title="Seq[scales.utils.Position[Item,Section,CC]]">positions</a>.<span title="=&gt; scales.utils.Position[Item,Section,CC]">head</span><span class="delimiter">)</span> <span class="comment">// else nothing we keep path to call root</span></span>
<a href="l96"></a><span id="l96">          <span class="delimiter">}</span></span>
<a href="l97"></a><span id="l97">        <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Nothing" class="keyword">return</span> <span title="(b: scales.utils.FoldError)Right[Nothing,scales.utils.FoldError]">Right</span><span class="delimiter">(</span><a href="#80239" title="scales.utils.package.FoldR[Item,Section,CC]">matched</a>.<span title="=&gt; Either.RightProjection[scales.utils.Path[Item,Section,CC],scales.utils.FoldError]">right</span>.<span title="=&gt; scales.utils.FoldError">get</span><span class="delimiter">)</span></span>
<a href="l98"></a><span id="l98">      <span class="delimiter">}</span></span>
<a href="l99"></a><span id="l99">      <span title="(a: (ACC, scales.utils.Path[Item,Section,CC]))Left[(ACC, scales.utils.Path[Item,Section,CC]),Nothing]">Left</span><span class="delimiter">(</span><span title="(_1: ACC, _2: scales.utils.Path[Item,Section,CC])(ACC, scales.utils.Path[Item,Section,CC])" class="delimiter">(</span><a href="#80080" title="ACC">accum</a>, <a href="#12211" title="(path: scales.utils.Path[Item,Section,CC])scales.utils.Path[Item,Section,CC]">rootPath</a><span class="delimiter">(</span><a href="#80148" title="scales.utils.Path[Item,Section,CC]">path</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l100"></a><span id="l100">    <span class="delimiter">}</span></span>
<a href="l101"></a><span id="l101">  <span class="delimiter">}</span></span>
<a href="l102"></a><span id="l102"></span>
<a href="l103"></a><span id="l103">  <span class="comment">/**</span>
<a href="l104"></a><span id="l104">   * Folds over positions within a single path, for example all given children.  As such positions must be calculated.</span>
<a href="l105"></a><span id="l105">   *</span>
<a href="l106"></a><span id="l106">   * Takes the first root, returning Right(NoSingleRoot) if any of the subsequent roots don't match.</span>
<a href="l107"></a><span id="l107">   *</span>
<a href="l108"></a><span id="l108">   * folder retrieves the current path</span>
<a href="l109"></a><span id="l109">   *</span>
<a href="l110"></a><span id="l110">   * Each iteration folds the resulting tree back into the path. As this function must maintain the Path it does not expose the new path root until the result.</span>
<a href="l111"></a><span id="l111">   */</span></span>
<a href="l112"></a><span id="l112">  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](locations: Iterable[scales.utils.Path[Item,Section,CC]])(folder: scales.utils.Path[Item,Section,CC] =&gt; scales.utils.FoldOperation[Item,Section,CC])(implicit cbf: scales.utils.package.TreeCBF[Item,Section,CC], implicit cm: ClassManifest[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])])Paths.this.FoldR[Item,Section,CC]" id="12256">foldPositions</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="12260">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="12261">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="12262">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="39448">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="Iterable[scales.utils.Path[Item,Section,CC]]" id="39275">locations</a>: <span title="Iterable[scales.utils.Path[Item,Section,CC]]">Iterable</span><span class="delimiter">[</span>Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC] =&gt; scales.utils.FoldOperation[Item,Section,CC]" id="39276">folder</a>: <span class="delimiter">(</span>Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; FoldOperation<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scales.utils.package.TreeCBF[Item,Section,CC]" id="39277">cbf</a> : <span title="scales.utils.package.TreeCBF[Item,Section,CC]">TreeCBF</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, <a title="ClassManifest[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])]" id="39278">cm</a> : <span title="ClassManifest[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])]">ClassManifest</span><span class="delimiter">[</span><span class="delimiter">(</span>scales.utils.Position<span class="delimiter">[</span>Item,Section,CC<span class="delimiter">]</span>, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span> : <span title="Paths.this.FoldR[Item,Section,CC]">FoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> =</span>
<a href="l113"></a><span id="l113">    <a href="#12247" title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]], ACC](locations: Iterable[scales.utils.Path[Item,Section,CC]], accumulator: ACC)(folder: (ACC, scales.utils.Path[Item,Section,CC]) =&gt; (ACC, scales.utils.FoldOperation[Item,Section,CC]))(implicit cbf: scales.utils.package.TreeCBF[Item,Section,CC], implicit cm: ClassManifest[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])])Either[(ACC, scales.utils.Path[Item,Section,CC]),scales.utils.FoldError]">foldPositions</a><span title="(locations: Iterable[scales.utils.Path[Item,Section,CC]], accumulator: Unit)(folder: (Unit, scales.utils.Path[Item,Section,CC]) =&gt; (Unit, scales.utils.FoldOperation[Item,Section,CC]))(implicit cbf: scales.utils.package.TreeCBF[Item,Section,CC], implicit cm: ClassManifest[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])])Either[(Unit, scales.utils.Path[Item,Section,CC]),scales.utils.FoldError]" class="delimiter">[</span><a href="#12260" title="Item">Item</a>, <a href="#12261" title="Section">Section</a>, <a href="#12262" title="CC">CC</a>, <span title="Unit">Unit</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#39275" title="Iterable[scales.utils.Path[Item,Section,CC]]">locations</a>, <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><a href="#39277" title="scales.utils.package.TreeCBF[Item,Section,CC]" class="delimiter">(</a><span class="delimiter">(</span><a title="Unit" id="80376">u</a>, <a title="scales.utils.Path[Item,Section,CC]" id="80377">p</a><span class="delimiter">)</span> =&gt; <span title="(_1: Unit, _2: scales.utils.FoldOperation[Item,Section,CC])(Unit, scales.utils.FoldOperation[Item,Section,CC])" class="delimiter">(</span><span title="Unit" class="delimiter">(</span><span class="delimiter">)</span>, <a href="#39276" title="(v1: scales.utils.Path[Item,Section,CC])scales.utils.FoldOperation[Item,Section,CC]">folder</a><span class="delimiter">(</span><a href="#80377" title="scales.utils.Path[Item,Section,CC]">p</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>.</span>
<a href="l114"></a><span id="l114">      <span title="(fa: (Unit, scales.utils.Path[Item,Section,CC]) =&gt; Product with Serializable with Either[scales.utils.Path[Item,Section,CC],scales.utils.FoldError], fb: scales.utils.FoldError =&gt; Product with Serializable with Either[scales.utils.Path[Item,Section,CC],scales.utils.FoldError])Product with Serializable with Either[scales.utils.Path[Item,Section,CC],scales.utils.FoldError]">fold</span><span class="delimiter">(</span><a title="(Unit, scales.utils.Path[Item,Section,CC])" id="80393">x</a> =&gt; <span title="(a: scales.utils.Path[Item,Section,CC])Left[scales.utils.Path[Item,Section,CC],Nothing]">Left</span><span class="delimiter">(</span><a href="#80393" title="(Unit, scales.utils.Path[Item,Section,CC])">x</a>.<span title="=&gt; scales.utils.Path[Item,Section,CC]">_2</span><span class="delimiter">)</span>, <span title="(b: scales.utils.FoldError)Right[Nothing,scales.utils.FoldError]">Right</span><span class="delimiter">(</span><a href="#80405" title="scales.utils.FoldError">_</a><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l115"></a><span id="l115"></span>
<a href="l116"></a><span id="l116">  <span class="keyword">val</span> <a title="Int" id="12263">NotSameRoot</a> = <span title="Int(1000)" class="int">1000</span></span>
<a href="l117"></a><span id="l117"></span>
<a href="l118"></a><span id="l118">  <span class="comment">/**</span>
<a href="l119"></a><span id="l119">   * When paths are not in the same root, they are compared based on the identity hash of the given roots.  Of course this relies on that function</span>
<a href="l120"></a><span id="l120">   * having a decent vm implementation.</span>
<a href="l121"></a><span id="l121">   *</span>
<a href="l122"></a><span id="l122">   * @param path1</span>
<a href="l123"></a><span id="l123">   * @param path2</span>
<a href="l124"></a><span id="l124">   * @return 1 if path1 is before path2, -1 if path2 is before path1, 0 if they are the same and NotSameRoot+-1 if they are not in the same root</span>
<a href="l125"></a><span id="l125">   */</span></span>
<a href="l126"></a><span id="l126">  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](path1: scales.utils.Position[Item,Section,CC], path2: scales.utils.Position[Item,Section,CC])Int" id="12265">comparePathPositions</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="12269">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="12270">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="12271">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="80427">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="scales.utils.Position[Item,Section,CC]" id="80424">path1</a>: <a href="#10517" title="scales.utils.Position[Item,Section,CC]">Position</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, <a title="scales.utils.Position[Item,Section,CC]" id="80425">path2</a>: <a href="#10517" title="scales.utils.Position[Item,Section,CC]">Position</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <span class="delimiter">{</span></span>
<a href="l127"></a><span id="l127"></span>
<a href="l128"></a><span id="l128">    <span title="Int" class="keyword">if</span> <span class="delimiter">(</span><a href="#80424" title="scales.utils.Position[Item,Section,CC]">path1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#80425" title="scales.utils.Position[Item,Section,CC]">path2</a><span class="delimiter">)</span> <span title="Int(0)" class="int">0</span></span>
<a href="l129"></a><span id="l129">    <span class="keyword">else</span> <span class="delimiter">{</span></span>
<a href="l130"></a><span id="l130">      <span title="Int" class="keyword">if</span> <span class="delimiter">(</span><a href="#80424" title="scales.utils.Position[Item,Section,CC]">path1</a>.<a href="#39263" title="=&gt; scales.utils.Path[Item,Section,CC]">root</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#80425" title="scales.utils.Position[Item,Section,CC]">path2</a>.<a href="#39263" title="=&gt; scales.utils.Path[Item,Section,CC]">root</a><span class="delimiter">)</span> <span class="delimiter">{</span></span>
<a href="l131"></a><span id="l131">        <span class="keyword">val</span> <a title="Int" id="80430">p1R</a> = <span title="object java.lang.System">System</span>.<span title="(x$1: Any)Int">identityHashCode</span><span class="delimiter">(</span><a href="#80424" title="scales.utils.Position[Item,Section,CC]">path1</a>.<a href="#39263" title="=&gt; scales.utils.Path[Item,Section,CC]">root</a><span class="delimiter">)</span></span>
<a href="l132"></a><span id="l132">        <span class="keyword">val</span> <a title="Int" id="80431">p2R</a> = <span title="object java.lang.System">System</span>.<span title="(x$1: Any)Int">identityHashCode</span><span class="delimiter">(</span><a href="#80425" title="scales.utils.Position[Item,Section,CC]">path2</a>.<a href="#39263" title="=&gt; scales.utils.Path[Item,Section,CC]">root</a><span class="delimiter">)</span></span>
<a href="l133"></a><span id="l133">        <a href="#12263" title="=&gt; Int">NotSameRoot</a> <span title="(x: Int)Int">+</span> <span class="delimiter">(</span><span title="Int" class="keyword">if</span> <span class="delimiter">(</span><a href="#80430" title="Int">p1R</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#80431" title="Int">p2R</a><span class="delimiter">)</span> <span title="Int(1)" class="int">1</span> <span class="keyword">else</span> -<span title="Int(-1)" class="int">1</span><span class="delimiter">)</span></span>
<a href="l134"></a><span id="l134">      <span class="delimiter">}</span> <span class="keyword">else</span></span>
<a href="l135"></a><span id="l135">        <a href="StackUtils.scala.html#12095" title="(p1: scala.collection.immutable.Stack[Int], p2: scala.collection.immutable.Stack[Int])Int">compareStack</a><span class="delimiter">(</span><a href="#80424" title="scales.utils.Position[Item,Section,CC]">path1</a>.<a href="#39264" title="=&gt; scala.collection.immutable.Stack[Int]">position</a>, <a href="#80425" title="scales.utils.Position[Item,Section,CC]">path2</a>.<a href="#39264" title="=&gt; scala.collection.immutable.Stack[Int]">position</a><span class="delimiter">)</span></span>
<a href="l136"></a><span id="l136">    <span class="delimiter">}</span></span>
<a href="l137"></a><span id="l137">  <span class="delimiter">}</span></span>
<a href="l138"></a><span id="l138"></span>
<a href="l139"></a><span id="l139">  <span class="comment">/**</span>
<a href="l140"></a><span id="l140">   * When paths are not in the same root, they are compared based on the identity hash of the given roots.  Of course this relies on that function</span>
<a href="l141"></a><span id="l141">   * having a decent vm implementation. See http://www.w3.org/TR/2007/REC-xpath20-20070123/#dt-document-order, tree order must remain constant.  Its</span>
<a href="l142"></a><span id="l142">   * also a pretty sensible approach for non xml trees.</span>
<a href="l143"></a><span id="l143">   *</span>
<a href="l144"></a><span id="l144">   * @param path1</span>
<a href="l145"></a><span id="l145">   * @param path2</span>
<a href="l146"></a><span id="l146">   * @return 1 if path1 is before path2, -1 if path2 is before path1, 0 if they are the same and NotSameRoot+-1 if they are not in the same root</span>
<a href="l147"></a><span id="l147">   */</span></span>
<a href="l148"></a><span id="l148">  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](path1: scales.utils.Path[Item,Section,CC], path2: scales.utils.Path[Item,Section,CC])(Int, scales.utils.Position[Item,Section,CC], scales.utils.Position[Item,Section,CC])" id="12272">comparePaths</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="12276">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="12277">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="12278">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="39269">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC]" id="39267">path1</a>: <a href="#84591" title="scales.utils.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, <a title="scales.utils.Path[Item,Section,CC]" id="39268">path2</a>: <a href="#84591" title="scales.utils.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(Int, scales.utils.Position[Item,Section,CC], scales.utils.Position[Item,Section,CC])" class="delimiter">(</span>Int, Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> =</span>
<a href="l149"></a><span id="l149">    <a href="#12279" title="(path1: (scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC]), path2: (scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC]))(Int, scales.utils.Position[Item,Section,CC], scales.utils.Position[Item,Section,CC])">comparePaths</a><span class="delimiter">(</span><span title="(_1: scales.utils.Position[Item,Section,CC], _2: scales.utils.Path[Item,Section,CC])(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])" class="delimiter">(</span><a href="#39267" title="scales.utils.Path[Item,Section,CC]">path1</a>.<a href="#39618" title="()scales.utils.Position[Item,Section,CC]">position</a>, <a href="#39267" title="scales.utils.Path[Item,Section,CC]">path1</a><span class="delimiter">)</span>, <span title="(_1: scales.utils.Position[Item,Section,CC], _2: scales.utils.Path[Item,Section,CC])(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])" class="delimiter">(</span><a href="#39268" title="scales.utils.Path[Item,Section,CC]">path2</a>.<a href="#39618" title="()scales.utils.Position[Item,Section,CC]">position</a>, <a href="#39268" title="scales.utils.Path[Item,Section,CC]">path2</a><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l150"></a><span id="l150"></span>
<a href="l151"></a><span id="l151">  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](path1: (scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC]), path2: (scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC]))(Int, scales.utils.Position[Item,Section,CC], scales.utils.Position[Item,Section,CC])" id="12279">comparePaths</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="12283">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="12284">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="12285">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="39261">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])" id="39259">path1</a>: <span title="(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])" class="delimiter">(</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>, <a title="(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])" id="39260">path2</a>: <span title="(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])" class="delimiter">(</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span>: <span title="(Int, scales.utils.Position[Item,Section,CC], scales.utils.Position[Item,Section,CC])" class="delimiter">(</span>Int, Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span></span>
<a href="l152"></a><span id="l152">    <span title="(Int, scales.utils.Position[Item,Section,CC], scales.utils.Position[Item,Section,CC])" class="keyword">if</span> <span class="delimiter">(</span><a href="#39259" title="(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])">path1</a>.<span title="=&gt; scales.utils.Path[Item,Section,CC]">_2</span> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#39260" title="(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])">path2</a>.<span title="=&gt; scales.utils.Path[Item,Section,CC]">_2</span><span class="delimiter">)</span> <span class="delimiter">{</span></span>
<a href="l153"></a><span id="l153">      <span class="keyword">val</span> <a title="scales.utils.Position[Item,Section,CC]" id="80737">pos</a> = <a href="#39259" title="(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])">path1</a>.<span title="=&gt; scales.utils.Position[Item,Section,CC]">_1</span></span>
<a href="l154"></a><span id="l154">      <span title="(_1: Int, _2: scales.utils.Position[Item,Section,CC], _3: scales.utils.Position[Item,Section,CC])(Int, scales.utils.Position[Item,Section,CC], scales.utils.Position[Item,Section,CC])" class="delimiter">(</span><span title="Int(0)" class="int">0</span>, <a href="#80737" title="scales.utils.Position[Item,Section,CC]">pos</a>, <a href="#80737" title="scales.utils.Position[Item,Section,CC]">pos</a><span class="delimiter">)</span></span>
<a href="l155"></a><span id="l155">    <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span></span>
<a href="l156"></a><span id="l156">      <span class="keyword">val</span> <a href="#80748" title="(scales.utils.Position[Item,Section,CC], scales.utils.Position[Item,Section,CC])" class="delimiter">(</a><a href="#80747" title="scales.utils.Position[Item,Section,CC]" id="80748">pos1</a>, <a href="#80747" title="scales.utils.Position[Item,Section,CC]" id="80749">pos2</a><span class="delimiter">)</span> = <span title="(_1: scales.utils.Position[Item,Section,CC], _2: scales.utils.Position[Item,Section,CC])(scales.utils.Position[Item,Section,CC], scales.utils.Position[Item,Section,CC])" class="delimiter">(</span><a href="#39259" title="(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])">path1</a>.<span title="=&gt; scales.utils.Position[Item,Section,CC]">_1</span>, <a href="#39260" title="(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])">path2</a>.<span title="=&gt; scales.utils.Position[Item,Section,CC]">_1</span><span class="delimiter">)</span></span>
<a href="l157"></a><span id="l157">      <span title="(_1: Int, _2: scales.utils.Position[Item,Section,CC], _3: scales.utils.Position[Item,Section,CC])(Int, scales.utils.Position[Item,Section,CC], scales.utils.Position[Item,Section,CC])" class="delimiter">(</span><a href="#12265" title="(path1: scales.utils.Position[Item,Section,CC], path2: scales.utils.Position[Item,Section,CC])Int">comparePathPositions</a><span class="delimiter">(</span><a href="#80748" title="scales.utils.Position[Item,Section,CC]">pos1</a>, <a href="#80749" title="scales.utils.Position[Item,Section,CC]">pos2</a><span class="delimiter">)</span>, <a href="#80748" title="scales.utils.Position[Item,Section,CC]">pos1</a>, <a href="#80749" title="scales.utils.Position[Item,Section,CC]">pos2</a><span class="delimiter">)</span></span>
<a href="l158"></a><span id="l158">    <span class="delimiter">}</span></span>
<a href="l159"></a><span id="l159">  <span class="delimiter">}</span></span>
<a href="l160"></a><span id="l160"></span>
<a href="l161"></a><span id="l161">  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]], T](path1: (scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC])), path2: (scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC])))(Int, scales.utils.Position[Item,Section,CC], scales.utils.Position[Item,Section,CC])" id="12286">comparePathsT</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="12291">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="12292">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="12293">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="80790">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="12294">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC]))" id="80788">path1</a>: <span title="(scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC]))" class="delimiter">(</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, <span class="delimiter">(</span>T, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a title="(scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC]))" id="80789">path2</a>: <span title="(scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC]))" class="delimiter">(</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, <span class="delimiter">(</span>T, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>: <span title="(Int, scales.utils.Position[Item,Section,CC], scales.utils.Position[Item,Section,CC])" class="delimiter">(</span>Int, Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span></span>
<a href="l162"></a><span id="l162">    <span title="(Int, scales.utils.Position[Item,Section,CC], scales.utils.Position[Item,Section,CC])" class="keyword">if</span> <span class="delimiter">(</span><a href="#80788" title="(scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC]))">path1</a>.<span title="=&gt; (T, scales.utils.Path[Item,Section,CC])">_2</span>.<span title="=&gt; scales.utils.Path[Item,Section,CC]">_2</span> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#80789" title="(scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC]))">path2</a>.<span title="=&gt; (T, scales.utils.Path[Item,Section,CC])">_2</span>.<span title="=&gt; scales.utils.Path[Item,Section,CC]">_2</span><span class="delimiter">)</span> <span class="delimiter">{</span></span>
<a href="l163"></a><span id="l163">      <span class="keyword">val</span> <a title="scales.utils.Position[Item,Section,CC]" id="80794">pos</a> = <a href="#80788" title="(scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC]))">path1</a>.<span title="=&gt; scales.utils.Position[Item,Section,CC]">_1</span></span>
<a href="l164"></a><span id="l164">      <span title="(_1: Int, _2: scales.utils.Position[Item,Section,CC], _3: scales.utils.Position[Item,Section,CC])(Int, scales.utils.Position[Item,Section,CC], scales.utils.Position[Item,Section,CC])" class="delimiter">(</span><span title="Int(0)" class="int">0</span>, <a href="#80794" title="scales.utils.Position[Item,Section,CC]">pos</a>, <a href="#80794" title="scales.utils.Position[Item,Section,CC]">pos</a><span class="delimiter">)</span></span>
<a href="l165"></a><span id="l165">    <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span></span>
<a href="l166"></a><span id="l166">      <span class="keyword">val</span> <a href="#80805" title="(scales.utils.Position[Item,Section,CC], scales.utils.Position[Item,Section,CC])" class="delimiter">(</a><a href="#80804" title="scales.utils.Position[Item,Section,CC]" id="80805">pos1</a>, <a href="#80804" title="scales.utils.Position[Item,Section,CC]" id="80806">pos2</a><span class="delimiter">)</span> = <span title="(_1: scales.utils.Position[Item,Section,CC], _2: scales.utils.Position[Item,Section,CC])(scales.utils.Position[Item,Section,CC], scales.utils.Position[Item,Section,CC])" class="delimiter">(</span><a href="#80788" title="(scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC]))">path1</a>.<span title="=&gt; scales.utils.Position[Item,Section,CC]">_1</span>, <a href="#80789" title="(scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC]))">path2</a>.<span title="=&gt; scales.utils.Position[Item,Section,CC]">_1</span><span class="delimiter">)</span></span>
<a href="l167"></a><span id="l167">      <span title="(_1: Int, _2: scales.utils.Position[Item,Section,CC], _3: scales.utils.Position[Item,Section,CC])(Int, scales.utils.Position[Item,Section,CC], scales.utils.Position[Item,Section,CC])" class="delimiter">(</span><a href="#12265" title="(path1: scales.utils.Position[Item,Section,CC], path2: scales.utils.Position[Item,Section,CC])Int">comparePathPositions</a><span class="delimiter">(</span><a href="#80805" title="scales.utils.Position[Item,Section,CC]">pos1</a>, <a href="#80806" title="scales.utils.Position[Item,Section,CC]">pos2</a><span class="delimiter">)</span>, <a href="#80805" title="scales.utils.Position[Item,Section,CC]">pos1</a>, <a href="#80806" title="scales.utils.Position[Item,Section,CC]">pos2</a><span class="delimiter">)</span></span>
<a href="l168"></a><span id="l168">    <span class="delimiter">}</span></span>
<a href="l169"></a><span id="l169">  <span class="delimiter">}</span></span>
<a href="l170"></a><span id="l170"></span>
<a href="l171"></a><span id="l171">  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](tree: scales.utils.Tree[Item,Section,CC])(implicit cbf: scales.utils.package.TreeCBF[Item,Section,CC])scales.utils.Path[Item,Section,CC]" id="12295">top</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="12299">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="12300">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="12301">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="80847">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="scales.utils.Tree[Item,Section,CC]" id="80845">tree</a>: <a href="Trees.scala.html#10655" title="scales.utils.Tree[Item,Section,CC]">Tree</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span></span>
<a href="l172"></a><span id="l172">    <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scales.utils.package.TreeCBF[Item,Section,CC]" id="80846">cbf</a> : <span title="scales.utils.package.TreeCBF[Item,Section,CC]">TreeCBF</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> : <a href="#84591" title="scales.utils.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> =</span>
<a href="l173"></a><span id="l173">    <a href="#84591" title="(top: scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]], node: scales.utils.Node[Item,Section,CC])(implicit cbf: scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]])scales.utils.Path[Item,Section,CC]">Path</a><a href="#80846" title="scales.utils.package.TreeCBF[Item,Section,CC]" class="delimiter">(</a><a href="#84613" title="()scales.utils.Top[Item,Section,CC]">Top</a><span class="delimiter">(</span><span class="delimiter">)</span>, <a href="#84597" title="(index: Int, focus: scales.utils.package.ItemOrTree[Item,Section,CC])scales.utils.Node[Item,Section,CC]">Node</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span>, <a href="#80845" title="scales.utils.Tree[Item,Section,CC]">tree</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="comment">//Right(tree)))</span></span>
<a href="l174"></a><span id="l174"></span>
<a href="l175"></a><span id="l175">  <span class="comment">/**</span>
<a href="l176"></a><span id="l176">   * positions with tuples (T, Path)</span>
<a href="l177"></a><span id="l177">   */</span> </span>
<a href="l178"></a><span id="l178">  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]], T](paths: Iterable[(T, scales.utils.Path[Item,Section,CC])])Iterable[(scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC]))]" id="12302">positionsT</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="12307">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="12308">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="12309">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="80914">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="12310">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Iterable[(T, scales.utils.Path[Item,Section,CC])]" id="80913">paths</a>: <span title="Iterable[(T, scales.utils.Path[Item,Section,CC])]">Iterable</span><span class="delimiter">[</span><span class="delimiter">(</span>T, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Iterable[(scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC]))]">Iterable</span><span class="delimiter">[</span><span class="delimiter">(</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, <span class="delimiter">(</span>T,Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">]</span> =</span>
<a href="l179"></a><span id="l179">    <a href="#80913" title="Iterable[(T, scales.utils.Path[Item,Section,CC])]">paths</a>.<span title="(f: (T, scales.utils.Path[Item,Section,CC]) =&gt; (scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC])))(implicit bf: scala.collection.generic.CanBuildFrom[Iterable[(T, scales.utils.Path[Item,Section,CC])],(scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC])),Iterable[(scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC]))]])Iterable[(scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC]))]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Iterable.Coll,(scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC])),Iterable[(scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC]))]]" class="delimiter">(</span><a title="(T, scales.utils.Path[Item,Section,CC])" id="80939">x</a> =&gt; <span title="(_1: scales.utils.Position[Item,Section,CC], _2: (T, scales.utils.Path[Item,Section,CC]))(scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC]))" class="delimiter">(</span><a href="#80939" title="(T, scales.utils.Path[Item,Section,CC])">x</a>.<span title="=&gt; scales.utils.Path[Item,Section,CC]">_2</span>.<a href="#39618" title="()scales.utils.Position[Item,Section,CC]">position</a>, <a href="#80939" title="(T, scales.utils.Path[Item,Section,CC])">x</a><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l180"></a><span id="l180"></span>
<a href="l181"></a><span id="l181">  <span class="comment">/**</span>
<a href="l182"></a><span id="l182">   * Obtain the positions for the paths</span>
<a href="l183"></a><span id="l183">   */</span> </span>
<a href="l184"></a><span id="l184">  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](paths: Iterable[scales.utils.Path[Item,Section,CC]])Iterable[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])]" id="12311">positions</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="12315">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="12316">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="12317">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="80966">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="Iterable[scales.utils.Path[Item,Section,CC]]" id="80965">paths</a>: <span title="Iterable[scales.utils.Path[Item,Section,CC]]">Iterable</span><span class="delimiter">[</span>Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Iterable[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])]">Iterable</span><span class="delimiter">[</span><span class="delimiter">(</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span> =</span>
<a href="l185"></a><span id="l185">    <a href="#80965" title="Iterable[scales.utils.Path[Item,Section,CC]]">paths</a>.<span title="(f: scales.utils.Path[Item,Section,CC] =&gt; (scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC]))(implicit bf: scala.collection.generic.CanBuildFrom[Iterable[scales.utils.Path[Item,Section,CC]],(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC]),Iterable[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])]])Iterable[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Iterable.Coll,(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC]),Iterable[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])]]" class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC]" id="80991">x</a> =&gt; <span title="(_1: scales.utils.Position[Item,Section,CC], _2: scales.utils.Path[Item,Section,CC])(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])" class="delimiter">(</span><a href="#80991" title="scales.utils.Path[Item,Section,CC]">x</a>.<a href="#39618" title="()scales.utils.Position[Item,Section,CC]">position</a>, <a href="#80991" title="scales.utils.Path[Item,Section,CC]">x</a><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l186"></a><span id="l186"></span>
<a href="l187"></a><span id="l187">  <span class="comment">/**</span>
<a href="l188"></a><span id="l188">   * sortPositions with a  tuple T, Path</span>
<a href="l189"></a><span id="l189">   */</span></span>
<a href="l190"></a><span id="l190">  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]], T](paths: Iterable[(T, scales.utils.Path[Item,Section,CC])], isDescending: Boolean)(implicit cm: ClassManifest[(scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC]))])Iterable[(scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC]))]" id="12318">sortPositionsT</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="81033">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="81034">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="81035">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="82083">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="81036">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Iterable[(T, scales.utils.Path[Item,Section,CC])]" id="81023">paths</a>: <span title="Iterable[(T, scales.utils.Path[Item,Section,CC])]">Iterable</span><span class="delimiter">[</span><span class="delimiter">(</span>T,Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span>,</span>
<a href="l191"></a><span id="l191">    <a title="Boolean" id="81028">isDescending</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="ClassManifest[(scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC]))]" id="81025">cm</a> : <span title="ClassManifest[(scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC]))]">ClassManifest</span><span class="delimiter">[</span><span class="delimiter">(</span>scales.utils.Position<span class="delimiter">[</span>Item,Section,CC<span class="delimiter">]</span>, <span class="delimiter">(</span>T, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Iterable[(scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC]))]">Iterable</span><span class="delimiter">[</span><span class="delimiter">(</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, <span class="delimiter">(</span>T, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">]</span> =</span>
<a href="l192"></a><span id="l192">    <span class="comment">// Have to force them anyway</span></span>
<a href="l193"></a><span id="l193">    scala.util.<span title="object scala.util.Sorting">Sorting</span>.<span title="(a: Seq[(scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC]))], f: ((scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC])), (scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC]))) =&gt; Boolean)(implicit evidence$5: scala.reflect.ClassManifest[(scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC]))])Array[(scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC]))]">stableSort</span><span class="delimiter">(</span><a href="#12302" title="(paths: Iterable[(T, scales.utils.Path[Item,Section,CC])])Iterable[(scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC]))]">positionsT</a><span class="delimiter">(</span><a href="#81023" title="Iterable[(T, scales.utils.Path[Item,Section,CC])]">paths</a><span class="delimiter">)</span>.<span title="=&gt; Seq[(scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC]))]">toSeq</span>, <span class="delimiter">(</span>p1: <span title="(scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC]))" class="delimiter">(</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, <span class="delimiter">(</span>T,Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span>, p2: <span title="(scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC]))" class="delimiter">(</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, <span class="delimiter">(</span>T,Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span></span>
<a href="l194"></a><span id="l194">      <span class="keyword">val</span> <a href="#81587" title="(Int, scales.utils.Position[Item,Section,CC], scales.utils.Position[Item,Section,CC])" class="delimiter">(</a><a href="#81586" title="Int" id="81587">res</a>, <a href="#81586" title="scales.utils.Position[Item,Section,CC]" id="81588">pos1</a>, <a href="#81586" title="scales.utils.Position[Item,Section,CC]" id="81589">pos2</a><span class="delimiter">)</span> = <a href="#12286" title="(path1: (scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC])), path2: (scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC])))(Int, scales.utils.Position[Item,Section,CC], scales.utils.Position[Item,Section,CC])">comparePathsT</a><span title="(Int, scales.utils.Position[Item,Section,CC], scales.utils.Position[Item,Section,CC]) @unchecked" class="delimiter">(</span><a href="#81584" title="(scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC]))">p1</a>, <a href="#81585" title="(scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC]))">p2</a><span class="delimiter">)</span> <span class="comment">//compareFunction(p1, p2)</span></span>
<a href="l195"></a><span id="l195">      <span class="keyword">val</span> <a title="Boolean" id="81590">order</a> = <span class="delimiter">(</span><a href="#81587" title="Int">res</a> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span> <span title="(x: Boolean)Boolean">||</span> <a href="#81587" title="Int">res</a> <span title="(x: Int)Boolean">==</span> <span class="delimiter">(</span><a href="#12263" title="=&gt; Int">NotSameRoot</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l196"></a><span id="l196">      <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#81028" title="Boolean">isDescending</a><span class="delimiter">)</span> <a href="#81590" title="Boolean">order</a> <span class="keyword">else</span> <span title="=&gt; Boolean">!</span><a href="#81590" title="Boolean">order</a></span>
<a href="l197"></a><span id="l197">    <span class="delimiter">}</span><span class="delimiter">)</span><span title="(xs: Array[(scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC]))])scala.collection.mutable.WrappedArray[(scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC]))]" class="delimiter">(</span><a href="#81025" title="ClassManifest[(scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC]))]">cm</a><span class="delimiter">)</span></span>
<a href="l198"></a><span id="l198"></span>
<a href="l199"></a><span id="l199">  <span class="comment">/**</span>
<a href="l200"></a><span id="l200">   * Sorts according to position of each path item, descending or descending based on a depth first then rightwise order.</span>
<a href="l201"></a><span id="l201">   */</span></span>
<a href="l202"></a><span id="l202">  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](paths: Iterable[scales.utils.Path[Item,Section,CC]], isDescending: Boolean)(implicit cm: ClassManifest[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])])Iterable[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])]" id="12327">sortPositions</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="80096">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="80097">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="80098">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="80111">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="Iterable[scales.utils.Path[Item,Section,CC]]" id="80087">paths</a>: <span title="Iterable[scales.utils.Path[Item,Section,CC]]">Iterable</span><span class="delimiter">[</span>Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>,</span>
<a href="l203"></a><span id="l203">    <span class="comment">//			compareFunction : (Path[Item, Section], Path[Item, Section]) =&gt; Integer = comparePaths _, </span></span>
<a href="l204"></a><span id="l204">    <a title="Boolean" id="80092">isDescending</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="ClassManifest[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])]" id="80089">cm</a> : <span title="ClassManifest[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])]">ClassManifest</span><span class="delimiter">[</span><span class="delimiter">(</span>scales.utils.Position<span class="delimiter">[</span>Item,Section,CC<span class="delimiter">]</span>, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Iterable[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])]">Iterable</span><span class="delimiter">[</span><span class="delimiter">(</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span> =</span>
<a href="l205"></a><span id="l205"></span>
<a href="l206"></a><span id="l206">    <span class="comment">// Have to force them anyway</span></span>
<a href="l207"></a><span id="l207">    scala.util.<span title="object scala.util.Sorting">Sorting</span>.<span title="(a: Seq[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])], f: ((scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC]), (scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])) =&gt; Boolean)(implicit evidence$5: scala.reflect.ClassManifest[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])])Array[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])]">stableSort</span><span class="delimiter">(</span><a href="#12311" title="(paths: Iterable[scales.utils.Path[Item,Section,CC]])Iterable[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])]">positions</a><span class="delimiter">(</span><a href="#80087" title="Iterable[scales.utils.Path[Item,Section,CC]]">paths</a><span class="delimiter">)</span>.<span title="=&gt; Seq[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])]">toSeq</span>, <span class="delimiter">(</span>p1: <span title="(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])" class="delimiter">(</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>, p2: <span title="(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])" class="delimiter">(</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span></span>
<a href="l208"></a><span id="l208">      <span class="keyword">val</span> <a href="#81761" title="(Int, scales.utils.Position[Item,Section,CC], scales.utils.Position[Item,Section,CC])" class="delimiter">(</a><a href="#81760" title="Int" id="81761">res</a>, <a href="#81760" title="scales.utils.Position[Item,Section,CC]" id="81762">pos1</a>, <a href="#81760" title="scales.utils.Position[Item,Section,CC]" id="81763">pos2</a><span class="delimiter">)</span> = <a href="#12279" title="(path1: (scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC]), path2: (scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC]))(Int, scales.utils.Position[Item,Section,CC], scales.utils.Position[Item,Section,CC])">comparePaths</a><span title="(Int, scales.utils.Position[Item,Section,CC], scales.utils.Position[Item,Section,CC]) @unchecked" class="delimiter">(</span><a href="#81758" title="(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])">p1</a>, <a href="#81759" title="(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])">p2</a><span class="delimiter">)</span> <span class="comment">//compareFunction(p1, p2)</span></span>
<a href="l209"></a><span id="l209">      <span class="keyword">val</span> <a title="Boolean" id="81764">order</a> = <span class="delimiter">(</span><a href="#81761" title="Int">res</a> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span> <span title="(x: Boolean)Boolean">||</span> <a href="#81761" title="Int">res</a> <span title="(x: Int)Boolean">==</span> <span class="delimiter">(</span><a href="#12263" title="=&gt; Int">NotSameRoot</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l210"></a><span id="l210">      <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#80092" title="Boolean">isDescending</a><span class="delimiter">)</span> <a href="#81764" title="Boolean">order</a> <span class="keyword">else</span> <span title="=&gt; Boolean">!</span><a href="#81764" title="Boolean">order</a></span>
<a href="l211"></a><span id="l211">    <span class="delimiter">}</span><span class="delimiter">)</span><span title="(xs: Array[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])])scala.collection.mutable.WrappedArray[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])]" class="delimiter">(</span><a href="#80089" title="ClassManifest[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])]">cm</a><span class="delimiter">)</span></span>
<a href="l212"></a><span id="l212">   </span>
<a href="l213"></a><span id="l213"></span>
<a href="l214"></a><span id="l214">  <span class="comment">/**</span>
<a href="l215"></a><span id="l215">   * Sorts according to position of each path item, descending or descending based on a depth first then rightwise order.</span>
<a href="l216"></a><span id="l216">   */</span></span>
<a href="l217"></a><span id="l217">  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](paths: Iterable[scales.utils.Path[Item,Section,CC]], isDescending: Boolean)(implicit cm: ClassManifest[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])])Iterable[scales.utils.Path[Item,Section,CC]]" id="12334">sort</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="81915">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="81916">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="81917">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="82080">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="Iterable[scales.utils.Path[Item,Section,CC]]" id="81906">paths</a>: <span title="Iterable[scales.utils.Path[Item,Section,CC]]">Iterable</span><span class="delimiter">[</span>Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>,</span>
<a href="l218"></a><span id="l218">    <a title="Boolean" id="81911">isDescending</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="ClassManifest[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])]" id="81908">cm</a> : <span title="ClassManifest[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])]">ClassManifest</span><span class="delimiter">[</span><span class="delimiter">(</span>scales.utils.Position<span class="delimiter">[</span>Item,Section,CC<span class="delimiter">]</span>, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Iterable[scales.utils.Path[Item,Section,CC]]">Iterable</span><span class="delimiter">[</span>Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#12327" title="(paths: Iterable[scales.utils.Path[Item,Section,CC]], isDescending: Boolean)(implicit cm: ClassManifest[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])])Iterable[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])]">sortPositions</a><a href="#81908" title="ClassManifest[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])]" class="delimiter">(</a><a href="#81906" title="Iterable[scales.utils.Path[Item,Section,CC]]">paths</a>, <a href="#81911" title="Boolean">isDescending</a><span class="delimiter">)</span>.<span title="(f: (scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC]) =&gt; scales.utils.Path[Item,Section,CC])(implicit bf: scala.collection.generic.CanBuildFrom[Iterable[(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])],scales.utils.Path[Item,Section,CC],Iterable[scales.utils.Path[Item,Section,CC]]])Iterable[scales.utils.Path[Item,Section,CC]]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Iterable.Coll,scales.utils.Path[Item,Section,CC],Iterable[scales.utils.Path[Item,Section,CC]]]" class="delimiter">(</span><a title="(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])" id="81969">x</a> =&gt; <a href="#81969" title="(scales.utils.Position[Item,Section,CC], scales.utils.Path[Item,Section,CC])">x</a>.<span title="=&gt; scales.utils.Path[Item,Section,CC]">_2</span><span class="delimiter">)</span></span>
<a href="l219"></a><span id="l219"></span>
<a href="l220"></a><span id="l220">  <span class="comment">/**</span>
<a href="l221"></a><span id="l221">   * sort with a tuple T, Path</span>
<a href="l222"></a><span id="l222">   */</span> </span>
<a href="l223"></a><span id="l223">  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]], T](paths: Iterable[(T, scales.utils.Path[Item,Section,CC])], isDescending: Boolean)(implicit cm: ClassManifest[(scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC]))])Iterable[(T, scales.utils.Path[Item,Section,CC])]" id="12341">sortT</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="81999">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="82000">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="82001">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="82077">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="82002">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Iterable[(T, scales.utils.Path[Item,Section,CC])]" id="81989">paths</a>: <span title="Iterable[(T, scales.utils.Path[Item,Section,CC])]">Iterable</span><span class="delimiter">[</span><span class="delimiter">(</span>T,Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span>,</span>
<a href="l224"></a><span id="l224">    <a title="Boolean" id="81994">isDescending</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="ClassManifest[(scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC]))]" id="81991">cm</a> : <span title="ClassManifest[(scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC]))]">ClassManifest</span><span class="delimiter">[</span><span class="delimiter">(</span>scales.utils.Position<span class="delimiter">[</span>Item,Section,CC<span class="delimiter">]</span>, <span class="delimiter">(</span>T, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Iterable[(T, scales.utils.Path[Item,Section,CC])]">Iterable</span><span class="delimiter">[</span><span class="delimiter">(</span>T,Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span> = <a href="#12318" title="(paths: Iterable[(T, scales.utils.Path[Item,Section,CC])], isDescending: Boolean)(implicit cm: ClassManifest[(scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC]))])Iterable[(scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC]))]">sortPositionsT</a><a href="#81991" title="ClassManifest[(scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC]))]" class="delimiter">(</a><a href="#81989" title="Iterable[(T, scales.utils.Path[Item,Section,CC])]">paths</a>, <a href="#81994" title="Boolean">isDescending</a><span class="delimiter">)</span>.<span title="(f: (scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC])) =&gt; (T, scales.utils.Path[Item,Section,CC]))(implicit bf: scala.collection.generic.CanBuildFrom[Iterable[(scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC]))],(T, scales.utils.Path[Item,Section,CC]),Iterable[(T, scales.utils.Path[Item,Section,CC])]])Iterable[(T, scales.utils.Path[Item,Section,CC])]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Iterable.Coll,(T, scales.utils.Path[Item,Section,CC]),Iterable[(T, scales.utils.Path[Item,Section,CC])]]" class="delimiter">(</span><a title="(scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC]))" id="82055">x</a> =&gt; <a href="#82055" title="(scales.utils.Position[Item,Section,CC], (T, scales.utils.Path[Item,Section,CC]))">x</a>.<span title="=&gt; (T, scales.utils.Path[Item,Section,CC])">_2</span><span class="delimiter">)</span></span>
<a href="l225"></a><span id="l225"><span class="delimiter">}</span></span>
<a href="l226"></a><span id="l226"></span>
<a href="l227"></a><span id="l227"><span class="keyword">trait</span> <a title="trait PathImplicits extends java.lang.Object with ScalaObject" id="10510">PathImplicits</a> <span title="ScalaObject" class="delimiter">{</span></span>
<a href="l228"></a><span id="l228">  <span class="comment">/**</span>
<a href="l229"></a><span id="l229">   * Provide &amp; combinator to pass the result of one fold onto the other,</span>
<a href="l230"></a><span id="l230">   * in the case of failure no further joined functions will be called.</span>
<a href="l231"></a><span id="l231">   *</span>
<a href="l232"></a><span id="l232">   * And provides | which allows NoPaths failures, allowing the use site to decide</span>
<a href="l233"></a><span id="l233">   * how to combine</span>
<a href="l234"></a><span id="l234">   */</span></span>
<a href="l235"></a><span id="l235">  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](f: scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC])java.lang.Object{def &amp;(next: scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]): scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]; def |(next: scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]): scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]}" id="66477">fToFoldRToCombine</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="66481">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="66482">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="66483">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="67295">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]" id="67286">f</a>: <span title="scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]">PathFoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#67289" title="java.lang.Object{def &amp;(next: scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]): scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]; def |(next: scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]): scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]}" class="keyword">new</a> <a title="anonymous class $anon extends java.lang.Object" id="67289" class="delimiter">{</a></span>
<a href="l236"></a><span id="l236">    <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(next: scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC], orOnFail: (scales.utils.Path[Item,Section,CC], scales.utils.FoldError) =&gt; scales.utils.package.FoldR[Item,Section,CC])scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]" id="67291">onSuccess</a><span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]" id="67298">next</a>: <span title="scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]">PathFoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, <a title="(scales.utils.Path[Item,Section,CC], scales.utils.FoldError) =&gt; scales.utils.package.FoldR[Item,Section,CC]" id="67300">orOnFail</a>: <span class="delimiter">(</span>Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, FoldError<span class="delimiter">)</span> =&gt; FoldR<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> = <span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC]" id="67526">a</a>, <a title="scales.utils.FoldError" id="67527">b</a><span class="delimiter">)</span> =&gt; <span title="(b: scales.utils.FoldError)Right[Nothing,scales.utils.FoldError]">Right</span><span class="delimiter">(</span><a href="#67527" title="scales.utils.FoldError">b</a><span class="delimiter">)</span><span class="delimiter">)</span>: <span title="scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]">PathFoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> =</span>
<a href="l237"></a><span id="l237">      <span class="delimiter">(</span>path: <a href="#84591" title="scales.utils.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> =&gt;</span>
<a href="l238"></a><span id="l238">        <span class="comment">// modify back in (allows changes), or pass on the error</span></span>
<a href="l239"></a><span id="l239">        <a href="#67286" title="(v1: scales.utils.Path[Item,Section,CC])scales.utils.package.FoldR[Item,Section,CC]">f</a><span class="delimiter">(</span><a href="#67365" title="scales.utils.Path[Item,Section,CC]">path</a><span class="delimiter">)</span>.<span title="(fa: scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC], fb: scales.utils.FoldError =&gt; scales.utils.package.FoldR[Item,Section,CC])scales.utils.package.FoldR[Item,Section,CC]">fold</span><span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC]" id="67373">fres</a> =&gt;</span>
<a href="l240"></a><span id="l240">          <a href="#67298" title="(v1: scales.utils.Path[Item,Section,CC])scales.utils.package.FoldR[Item,Section,CC]">next</a><span class="delimiter">(</span><a href="#67365" title="scales.utils.Path[Item,Section,CC]">path</a>.<a href="#39616" title="(newFocus: scales.utils.package.ItemOrTree[Item,Section,CC] =&gt; scales.utils.package.ItemOrTree[Item,Section,CC])scales.utils.Path[Item,Section,CC]">modify</a><span class="delimiter">(</span><a title="scales.utils.package.ItemOrTree[Item,Section,CC]" id="67488">_</a> =&gt; <a href="#67373" title="scales.utils.Path[Item,Section,CC]">fres</a>.<a href="#39608" title="()scales.utils.Tree[Item,Section,CC]">tree</a><span class="delimiter">)</span><span class="delimiter">)</span>,<span class="comment">//Right(fres.tree))),</span></span>
<a href="l241"></a><span id="l241">          <a href="#67300" title="(v1: scales.utils.Path[Item,Section,CC], v2: scales.utils.FoldError)scales.utils.package.FoldR[Item,Section,CC]">orOnFail</a><span class="delimiter">(</span><a href="#67365" title="scales.utils.Path[Item,Section,CC]">path</a>, <a href="#67510" title="scales.utils.FoldError">_</a><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l242"></a><span id="l242"></span>
<a href="l243"></a><span id="l243">    <span class="keyword">def</span> <a title="(next: scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC])scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]" id="67292">&amp;</a><span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]" id="67294">next</a>: <span title="scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]">PathFoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]">PathFoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> =</span>
<a href="l244"></a><span id="l244">      <a href="#67291" title="(next: scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC], orOnFail: (scales.utils.Path[Item,Section,CC], scales.utils.FoldError) =&gt; scales.utils.package.FoldR[Item,Section,CC])scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]">onSuccess</a><span class="delimiter">(</span><a href="#67294" title="scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]">next</a><span class="delimiter">)</span></span>
<a href="l245"></a><span id="l245"></span>
<a href="l246"></a><span id="l246">    <span class="keyword">def</span> <a title="(next: scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC])scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]" id="67293">|</a><span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]" id="67296">next</a>: <span title="scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]">PathFoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]">PathFoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> =</span>
<a href="l247"></a><span id="l247">      <a href="#67291" title="(next: scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC], orOnFail: (scales.utils.Path[Item,Section,CC], scales.utils.FoldError) =&gt; scales.utils.package.FoldR[Item,Section,CC])scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]">onSuccess</a><span class="delimiter">(</span><a href="#67296" title="scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]">next</a>, orOnFail = <span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC]" id="67517">path</a>, <a title="scales.utils.FoldError" id="67518">res</a><span class="delimiter">)</span> =&gt;</span>
<a href="l248"></a><span id="l248">        <span title="scales.utils.package.FoldR[Item,Section,CC]" class="keyword">if</span> <span class="delimiter">(</span><a href="#67518" title="scales.utils.FoldError">res</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#84492" title="object scales.utils.NoPaths">NoPaths</a><span class="delimiter">)</span></span>
<a href="l249"></a><span id="l249">          <a href="#67296" title="(v1: scales.utils.Path[Item,Section,CC])scales.utils.package.FoldR[Item,Section,CC]">next</a><span class="delimiter">(</span><a href="#67517" title="scales.utils.Path[Item,Section,CC]">path</a><span class="delimiter">)</span></span>
<a href="l250"></a><span id="l250">        <span class="keyword">else</span></span>
<a href="l251"></a><span id="l251">          <span title="(b: scales.utils.FoldError)Right[Nothing,scales.utils.FoldError]">Right</span><span class="delimiter">(</span><a href="#67518" title="scales.utils.FoldError">res</a><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l252"></a><span id="l252">  <span class="delimiter">}</span></span>
<a href="l253"></a><span id="l253"></span>
<a href="l254"></a><span id="l254"><span class="delimiter">}</span></span>
<a href="l255"></a><span id="l255"></span>
<a href="l256"></a><span id="l256">case <span class="keyword">class</span> <a title="class Top[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]] extends java.lang.Object with scales.utils.LeftLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]] with ScalaObject with Product with Serializable" id="84613">Top</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="79481">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="79482">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="79483">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="79492">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><a href="#84613" title="ScalaObject" class="delimiter">(</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="EitherLike.scala.html#10331" title="scales.utils.LeftLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]]">LeftLike</a><span class="delimiter">[</span>Top<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span> </span>
<a href="l257"></a><span id="l257"></span>
<a href="l258"></a><span id="l258"></span>
<a href="l259"></a><span id="l259"><span class="comment">/**</span>
<a href="l260"></a><span id="l260"> * Positions only have meaning for a given Path(s).</span>
<a href="l261"></a><span id="l261"> *</span>
<a href="l262"></a><span id="l262"> * Their internal representation may change, as such its private to Paths.</span>
<a href="l263"></a><span id="l263"> * r	 * @author Chris</span>
<a href="l264"></a><span id="l264"> *</span>
<a href="l265"></a><span id="l265"> */</span></span>
<a href="l266"></a><span id="l266"><span class="keyword">trait</span> <a title="trait Position[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]] extends java.lang.Object" id="10517">Position</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="10518">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="10519">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="10520">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="82107">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> <span title="java.lang.Object" class="delimiter">{</span></span>
<a href="l267"></a><span id="l267">  <span class="keyword">private</span><span class="delimiter">[</span>utils<span class="delimiter">]</span> <span class="keyword">val</span> <a title="=&gt; scales.utils.Path[Item,Section,CC]" id="39263">root</a>: <a href="#84591" title="scales.utils.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span></span>
<a href="l268"></a><span id="l268">  <span class="keyword">private</span><span class="delimiter">[</span>utils<span class="delimiter">]</span> <span class="keyword">val</span> <a title="=&gt; scala.collection.immutable.Stack[Int]" id="39264">position</a>: <span title="scala.collection.immutable.Stack[Int]">Stack</span><span class="delimiter">[</span>Int<span class="delimiter">]</span></span>
<a href="l269"></a><span id="l269"><span class="delimiter">}</span></span>
<a href="l270"></a><span id="l270"></span>
<a href="l271"></a><span id="l271"><span class="keyword">private</span><span class="delimiter">[</span>utils<span class="delimiter">]</span> case <span class="keyword">class</span> <a title="class PositionImpl[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]] extends java.lang.Object with scales.utils.Position[Item,Section,CC] with ScalaObject with Product with Serializable" id="84609">PositionImpl</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="82153">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="82154">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="82155">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="84603">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><a href="#84609" title="ScalaObject" class="delimiter">(</a><span class="keyword">val</span> <a title="scala.collection.immutable.Stack[Int]" id="84601">position</a>: <span title="scala.collection.immutable.Stack[Int]">Stack</span><span class="delimiter">[</span>Int<span class="delimiter">]</span>, <span class="keyword">val</span> <a title="scales.utils.Path[Item,Section,CC]" id="84602">root</a>: <a href="#84591" title="scales.utils.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#10517" title="scales.utils.Position[Item,Section,CC]">Position</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span></span>
<a href="l272"></a><span id="l272"></span>
<a href="l273"></a><span id="l273"><span class="comment">//import scala.collection.GenTraversable</span></span>
<a href="l274"></a><span id="l274"></span>
<a href="l275"></a><span id="l275"><span class="comment">/**</span>
<a href="l276"></a><span id="l276"> * Vectors are used due to big O considerations,</span>
<a href="l277"></a><span id="l277"> * List looks ok until appendChild or previousSibling are called.  There may be a better</span>
<a href="l278"></a><span id="l278"> * choice out there though....</span>
<a href="l279"></a><span id="l279"> *</span>
<a href="l280"></a><span id="l280"> * @author Chris</span>
<a href="l281"></a><span id="l281"> *</span>
<a href="l282"></a><span id="l282"> */</span> <span class="comment">// note - lazy is a perf killer for building, probably doesn't save much over interrogation either (given Iterator is used) </span></span>
<a href="l283"></a><span id="l283">case <span class="keyword">class</span> <a title="class Node[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]] extends java.lang.Object with ScalaObject with Product with Serializable" id="84597">Node</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="67418">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="67419">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="67420">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="67444">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><a href="#84597" title="ScalaObject" class="delimiter">(</a><a title="Int" id="67442">index</a>: <span title="Int">Int</span>, <a title="scales.utils.package.ItemOrTree[Item,Section,CC]" id="67443">focus</a>: <a href="EitherLike.scala.html#10328" title="scales.utils.package.ItemOrTree[Item,Section,CC]">ItemOrTree</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span></span>
<a href="l284"></a><span id="l284"></span>
<a href="l285"></a><span id="l285">case <span class="keyword">class</span> <a title="class Path[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]] extends java.lang.Object with Iterable[scales.utils.Path[Item,Section,CC]] with scales.utils.RightLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]] with ScalaObject with Product with Serializable" id="84591">Path</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="67384">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="67385">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="67386">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="67397">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><a href="#84591" title="ScalaObject" class="delimiter">(</a><a title="scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]]" id="67394">top</a>: <a href="EitherLike.scala.html#10328" title="scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]]">EitherLike</a><span class="delimiter">[</span>Top<span class="delimiter">[</span>Item,Section,CC<span class="delimiter">]</span>, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="scales.utils.Node[Item,Section,CC]" id="67395">node</a>: <a href="#84597" title="scales.utils.Node[Item,Section,CC]">Node</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span></span>
<a href="l286"></a><span id="l286">     <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]]" id="67396">cbf</a> : <span title="scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]]">CanBuildFrom</span><span class="delimiter">[</span>CC<span class="delimiter">[</span>_<span class="delimiter">]</span>, ItemOrTree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, CC<span class="delimiter">[</span>ItemOrTree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <span title="Iterable[scales.utils.Path[Item,Section,CC]]">Iterable</span><span class="delimiter">[</span>Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span> <span class="keyword">with</span> <a href="EitherLike.scala.html#10334" title="scales.utils.RightLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]]">RightLike</a><span class="delimiter">[</span>Top<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span> self =&gt;</span>
<a href="l287"></a><span id="l287"></span>
<a href="l288"></a><span id="l288">  <span class="comment">// for some reason its not liking the types, probably  good one</span></span>
<a href="l289"></a><span id="l289">  <span class="comment">//@inline def asCC( </span></span>
<a href="l290"></a><span id="l290"></span>
<a href="l291"></a><span id="l291">  <span class="keyword">def</span> <a title="=&gt; scales.utils.Tree[Item,Section,CC]" id="39599">parentTree</a> : <a href="Trees.scala.html#10655" title="scales.utils.Tree[Item,Section,CC]">Tree</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> = <a href="#67394" title="=&gt; scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]]">top</a>.<a href="EitherLike.scala.html#39641" title="=&gt; scales.utils.Path[Item,Section,CC]">getRight</a>.<a href="#67395" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67443" title="=&gt; scales.utils.package.ItemOrTree[Item,Section,CC]">focus</a>.<a href="EitherLike.scala.html#39641" title="=&gt; scales.utils.Tree[Item,Section,CC]">getRight</a></span>
<a href="l292"></a><span id="l292"></span>
<a href="l293"></a><span id="l293">  <span class="keyword">def</span> <a title="=&gt; Int" id="39600">parentCount</a> = <span title="Int" class="keyword">if</span> <span class="delimiter">(</span><a href="#67394" title="=&gt; scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]]">top</a>.<a href="EitherLike.scala.html#39633" title="=&gt; Boolean">isLeft</a><span class="delimiter">)</span> <span title="Int(0)" class="int">0</span> <span class="keyword">else</span> <a href="#39599" title="=&gt; scales.utils.Tree[Item,Section,CC]">parentTree</a>.<a href="Trees.scala.html#67496" title="=&gt; CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">children</a>.<span title="=&gt; Int">length</span></span>
<a href="l294"></a><span id="l294"></span>
<a href="l295"></a><span id="l295">  <span class="comment">/** Is there a previous sibling */</span></span>
<a href="l296"></a><span id="l296">  <span class="keyword">def</span> <a title="=&gt; Boolean" id="39601">hasPreviousSibling</a> = <span class="delimiter">(</span><a href="#67395" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67442" title="=&gt; Int">index</a> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#67395" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67442" title="=&gt; Int">index</a> <span title="(x: Int)Boolean">&lt;=</span> <a href="#39600" title="=&gt; Int">parentCount</a><span class="delimiter">)</span></span>
<a href="l297"></a><span id="l297"></span>
<a href="l298"></a><span id="l298">  <span class="comment">/** Does it have a further sibling */</span></span>
<a href="l299"></a><span id="l299">  <span class="keyword">def</span> <a title="=&gt; Boolean" id="39602">hasNextSibling</a> = <span class="delimiter">(</span><a href="#67395" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67442" title="=&gt; Int">index</a> <span title="(x: Int)Boolean">&gt;</span> -<span title="Int(-1)" class="int">1</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#67395" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67442" title="=&gt; Int">index</a> <span title="(x: Int)Boolean">&lt;</span> <span class="delimiter">(</span><a href="#39600" title="=&gt; Int">parentCount</a> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l300"></a><span id="l300"></span>
<a href="l301"></a><span id="l301">  <span class="comment">/**</span>
<a href="l302"></a><span id="l302">   * Is the focus an Item?</span>
<a href="l303"></a><span id="l303">   */</span></span>
<a href="l304"></a><span id="l304">  <span class="keyword">def</span> <a title="=&gt; Boolean" id="39603">isItem</a> = <a href="#67395" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67443" title="=&gt; scales.utils.package.ItemOrTree[Item,Section,CC]">focus</a>.<a href="EitherLike.scala.html#39633" title="=&gt; Boolean">isLeft</a></span>
<a href="l305"></a><span id="l305"></span>
<a href="l306"></a><span id="l306">  <span class="comment">/**</span>
<a href="l307"></a><span id="l307">   * Does the focus have a child?</span>
<a href="l308"></a><span id="l308">   */</span></span>
<a href="l309"></a><span id="l309">  <span class="keyword">def</span> <a title="=&gt; Boolean" id="39604">hasChildren</a> =</span>
<a href="l310"></a><span id="l310">    <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#39603" title="=&gt; Boolean">isItem</a><span class="delimiter">)</span> <span title="Boolean(false)" class="keyword">false</span></span>
<a href="l311"></a><span id="l311">    <span class="keyword">else</span> <a href="#39605" title="=&gt; CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">children</a>.<span title="=&gt; Int">length</span> <span title="(x: Int)Boolean">!=</span> <span title="Int(0)" class="int">0</span></span>
<a href="l312"></a><span id="l312"></span>
<a href="l313"></a><span id="l313">  <span class="comment">/**</span>
<a href="l314"></a><span id="l314">   * Children for a path, don't call unless it is not an item</span>
<a href="l315"></a><span id="l315">   */</span> </span>
<a href="l316"></a><span id="l316">  <span class="keyword">def</span> <a title="=&gt; CC[scales.utils.package.ItemOrTree[Item,Section,CC]]" id="39605">children</a> : <a href="#67386" title="CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">CC</a><span class="delimiter">[</span>ItemOrTree<span class="delimiter">[</span>Item,Section,CC<span class="delimiter">]</span><span class="delimiter">]</span>  = <a href="#67395" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67443" title="=&gt; scales.utils.package.ItemOrTree[Item,Section,CC]">focus</a>.<a href="EitherLike.scala.html#39640" title="=&gt; scales.utils.RightLikeProjection[scales.utils.Tree[Item,Section,CC]]">right</a>.<a href="EitherLike.scala.html#39620" title="=&gt; scales.utils.Tree[Item,Section,CC]">get</a>.<a href="Trees.scala.html#67496" title="=&gt; CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">children</a></span>
<a href="l317"></a><span id="l317"></span>
<a href="l318"></a><span id="l318">  <span class="comment">/**</span>
<a href="l319"></a><span id="l319">   * Call hasPreviousSibling first to assert there is a previous sibling</span>
<a href="l320"></a><span id="l320">   */</span></span>
<a href="l321"></a><span id="l321">  <span class="keyword">def</span> <a title="=&gt; scales.utils.Path[Item,Section,CC]" id="39606">previousSibling</a> = <a href="#84591" title="(top: scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]], node: scales.utils.Node[Item,Section,CC])(implicit cbf: scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]])scales.utils.Path[Item,Section,CC]">Path</a><a href="#67396" title="scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]]" class="delimiter">(</a><a href="#67394" title="=&gt; scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]]">top</a>, <a href="#84597" title="(index: Int, focus: scales.utils.package.ItemOrTree[Item,Section,CC])scales.utils.Node[Item,Section,CC]">Node</a><span class="delimiter">(</span><a href="#67395" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67442" title="=&gt; Int">index</a> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span>, <a href="#39599" title="=&gt; scales.utils.Tree[Item,Section,CC]">parentTree</a>.<a href="Trees.scala.html#67496" title="=&gt; CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">children</a>.<span title="(idx: Int)scales.utils.package.ItemOrTree[Item,Section,CC]">apply</span><span class="delimiter">(</span><a href="#67395" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67442" title="=&gt; Int">index</a> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l322"></a><span id="l322"></span>
<a href="l323"></a><span id="l323">  <span class="comment">/**</span>
<a href="l324"></a><span id="l324">   * Call hasNextSibling first to assert there is a next sibling</span>
<a href="l325"></a><span id="l325">   */</span></span>
<a href="l326"></a><span id="l326">  <span class="keyword">def</span> <a title="=&gt; scales.utils.Path[Item,Section,CC]" id="39607">nextSibling</a> = <a href="#84591" title="(top: scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]], node: scales.utils.Node[Item,Section,CC])(implicit cbf: scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]])scales.utils.Path[Item,Section,CC]">Path</a><a href="#67396" title="scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]]" class="delimiter">(</a><a href="#67394" title="=&gt; scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]]">top</a>, <a href="#84597" title="(index: Int, focus: scales.utils.package.ItemOrTree[Item,Section,CC])scales.utils.Node[Item,Section,CC]">Node</a><span class="delimiter">(</span><a href="#67395" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67442" title="=&gt; Int">index</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span>, <a href="#39599" title="=&gt; scales.utils.Tree[Item,Section,CC]">parentTree</a>.<a href="Trees.scala.html#67496" title="(idx: Int)scales.utils.package.ItemOrTree[Item,Section,CC]">children</a><span class="delimiter">(</span><a href="#67395" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67442" title="=&gt; Int">index</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l327"></a><span id="l327"></span>
<a href="l328"></a><span id="l328">  <span class="comment">/**</span>
<a href="l329"></a><span id="l329">   * get the tree (isItem == false)</span>
<a href="l330"></a><span id="l330">   * @return</span>
<a href="l331"></a><span id="l331">   */</span></span>
<a href="l332"></a><span id="l332">  <span class="keyword">def</span> <a title="()scales.utils.Tree[Item,Section,CC]" id="39608">tree</a><span class="delimiter">(</span><span class="delimiter">)</span> = <a href="#67395" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67443" title="=&gt; scales.utils.package.ItemOrTree[Item,Section,CC]">focus</a>.<a href="EitherLike.scala.html#39641" title="=&gt; scales.utils.Tree[Item,Section,CC]">getRight</a></span>
<a href="l333"></a><span id="l333"></span>
<a href="l334"></a><span id="l334">  <span class="comment">/**</span>
<a href="l335"></a><span id="l335">   * get the item (isItem == true)</span>
<a href="l336"></a><span id="l336">   * @return</span>
<a href="l337"></a><span id="l337">   */</span></span>
<a href="l338"></a><span id="l338">  <span class="keyword">def</span> <a title="()Item" id="39609">item</a><span class="delimiter">(</span><span class="delimiter">)</span> = <a href="#67395" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67443" title="=&gt; scales.utils.package.ItemOrTree[Item,Section,CC]">focus</a>.<a href="EitherLike.scala.html#39639" title="=&gt; Item">getLeft</a></span>
<a href="l339"></a><span id="l339"></span>
<a href="l340"></a><span id="l340">  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">class</span> <a title="class ItemIterator extends java.lang.Object with Iterator[scales.utils.Path[Item,Section,CC]] with ScalaObject" id="39610">ItemIterator</a><a href="#39610" title="ScalaObject" class="delimiter">(</a><span class="delimiter">)</span> <span class="keyword">extends</span> <span title="Iterator[scales.utils.Path[Item,Section,CC]]">Iterator</span><span class="delimiter">[</span>Path<span class="delimiter">[</span>Item,Section, CC<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span> </span>
<a href="l341"></a><span id="l341">    <span class="keyword">def</span> <a title="=&gt; Boolean" id="82467">hasNext</a> = <span title="Boolean(false)" class="keyword">false</span></span>
<a href="l342"></a><span id="l342">    <span class="keyword">def</span> <a title="()Nothing" id="82468">next</a><span class="delimiter">(</span><span class="delimiter">)</span> = <a href="package.scala.html#12052" title="(str: String)Nothing">error</a><span class="delimiter">(</span><span title="java.lang.String(&quot;Cannot iterate over an item&quot;)" class="string">&quot;Cannot iterate over an item&quot;</span><span class="delimiter">)</span></span>
<a href="l343"></a><span id="l343">  <span class="delimiter">}</span></span>
<a href="l344"></a><span id="l344"></span>
<a href="l345"></a><span id="l345">  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">class</span> <a title="class TreeIterator extends java.lang.Object with Iterator[scales.utils.Path[Item,Section,CC]] with ScalaObject" id="39611">TreeIterator</a><a href="#39611" title="ScalaObject" class="delimiter">(</a><span class="delimiter">)</span> <span class="keyword">extends</span> <span title="Iterator[scales.utils.Path[Item,Section,CC]]">Iterator</span><span class="delimiter">[</span>Path<span class="delimiter">[</span>Item,Section, CC<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span> </span>
<a href="l346"></a><span id="l346">    <span class="keyword">val</span> <a title="Iterator[scales.utils.package.ItemOrTree[Item,Section,CC]]" id="82476">c</a> = <a href="#39605" title="=&gt; CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">children</a>.<span title="=&gt; Iterator[scales.utils.package.ItemOrTree[Item,Section,CC]]">iterator</span></span>
<a href="l347"></a><span id="l347">    <span class="keyword">var</span> <a title="Int" id="82479">index</a> = -<span title="Int(-1)" class="int">1</span></span>
<a href="l348"></a><span id="l348">    </span>
<a href="l349"></a><span id="l349">    <span class="keyword">def</span> <a title="=&gt; Boolean" id="82481">hasNext</a> = <a href="#82476" title="=&gt; Iterator[scales.utils.package.ItemOrTree[Item,Section,CC]]">c</a>.<span title="=&gt; Boolean">hasNext</span></span>
<a href="l350"></a><span id="l350"></span>
<a href="l351"></a><span id="l351">    <span class="keyword">def</span> <a title="()scales.utils.Path[Item,Section,CC]" id="82482">next</a><span class="delimiter">(</span><span class="delimiter">)</span> : <a href="#84591" title="scales.utils.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> = <span class="delimiter">{</span></span>
<a href="l352"></a><span id="l352">      <a href="#82479" title="(x$1: Int)Unit">index</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span></span>
<a href="l353"></a><span id="l353">      <a href="#84591" title="(top: scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]], node: scales.utils.Node[Item,Section,CC])(implicit cbf: scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]])scales.utils.Path[Item,Section,CC]">Path</a><a href="#67396" title="scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]]" class="delimiter">(</a><a href="#84591" title="scales.utils.Path[Item,Section,CC]">self</a>, <a href="#84597" title="(index: Int, focus: scales.utils.package.ItemOrTree[Item,Section,CC])scales.utils.Node[Item,Section,CC]">Node</a><span class="delimiter">(</span><a href="#82479" title="=&gt; Int">index</a>, <a href="#82476" title="=&gt; Iterator[scales.utils.package.ItemOrTree[Item,Section,CC]]">c</a>.<span title="()scales.utils.package.ItemOrTree[Item,Section,CC]">next</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l354"></a><span id="l354">    <span class="delimiter">}</span></span>
<a href="l355"></a><span id="l355">  <span class="delimiter">}</span></span>
<a href="l356"></a><span id="l356"></span>
<a href="l357"></a><span id="l357">  <span class="comment">/**</span>
<a href="l358"></a><span id="l358">   * Provide iterator to the path of the children</span>
<a href="l359"></a><span id="l359">   */</span></span>
<a href="l360"></a><span id="l360">  <span class="keyword">def</span> <a title="()Iterator[scales.utils.Path[Item,Section,CC]]" id="39612">iterator</a><span class="delimiter">(</span><span class="delimiter">)</span> = </span>
<a href="l361"></a><span id="l361">    <span title="Iterator[scales.utils.Path[Item,Section,CC]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#39603" title="=&gt; Boolean">isItem</a><span class="delimiter">)</span></span>
<a href="l362"></a><span id="l362">      <span title="Path.this.ItemIterator" class="keyword">new</span> <a href="#39610" title="Path.this.ItemIterator">ItemIterator</a><span class="delimiter">(</span><span class="delimiter">)</span></span>
<a href="l363"></a><span id="l363">    <span class="keyword">else</span></span>
<a href="l364"></a><span id="l364">      <span title="Path.this.TreeIterator" class="keyword">new</span> <a href="#39611" title="Path.this.TreeIterator">TreeIterator</a><span class="delimiter">(</span><span class="delimiter">)</span></span>
<a href="l365"></a><span id="l365"></span>
<a href="l366"></a><span id="l366">  <span class="comment">/**</span>
<a href="l367"></a><span id="l367">   * Returns either the first child or none.  Note the child would still need to be unpacked</span>
<a href="l368"></a><span id="l368">   * @return</span>
<a href="l369"></a><span id="l369">   */</span></span>
<a href="l370"></a><span id="l370">  <span class="keyword">def</span> <a title="()Option[scales.utils.Path[Item,Section,CC]]" id="39613">firstChild</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Option[scales.utils.Path[Item,Section,CC]]">Option</span><span class="delimiter">[</span>Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span> =</span>
<a href="l371"></a><span id="l371">    <span title="Option[scales.utils.Path[Item,Section,CC]]" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#39604" title="=&gt; Boolean">hasChildren</a><span class="delimiter">)</span> <span title="object None">None</span> <span class="comment">// can't have a child if its just a data node</span></span>
<a href="l372"></a><span id="l372">    <span class="keyword">else</span> <span title="(x: scales.utils.Path[Item,Section,CC])Some[scales.utils.Path[Item,Section,CC]]">Some</span><span class="delimiter">(</span><a href="#84591" title="(top: scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]], node: scales.utils.Node[Item,Section,CC])(implicit cbf: scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]])scales.utils.Path[Item,Section,CC]">Path</a><a href="#67396" title="scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]]" class="delimiter">(</a><a href="#84591" title="scales.utils.Path[Item,Section,CC]" class="keyword">this</a>, <a href="#84597" title="(index: Int, focus: scales.utils.package.ItemOrTree[Item,Section,CC])scales.utils.Node[Item,Section,CC]">Node</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span>, <a href="#39605" title="=&gt; CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">children</a>.<span title="=&gt; scales.utils.package.ItemOrTree[Item,Section,CC]">head</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l373"></a><span id="l373"></span>
<a href="l374"></a><span id="l374">  <span class="comment">/**</span>
<a href="l375"></a><span id="l375">   * Returns either the last child or none.  Note the child would still need to be unpacked</span>
<a href="l376"></a><span id="l376">   * @return</span>
<a href="l377"></a><span id="l377">   */</span></span>
<a href="l378"></a><span id="l378">  <span class="keyword">def</span> <a title="()Option[scales.utils.Path[Item,Section,CC]]" id="39614">lastChild</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Option[scales.utils.Path[Item,Section,CC]]">Option</span><span class="delimiter">[</span>Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="comment">// don't ask children twice</span></span>
<a href="l379"></a><span id="l379">    <span title="Option[scales.utils.Path[Item,Section,CC]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#39603" title="=&gt; Boolean">isItem</a><span class="delimiter">)</span> <span title="object None">None</span> <span class="comment">// items don't have children</span></span>
<a href="l380"></a><span id="l380">    <span class="keyword">else</span> <span class="delimiter">{</span></span>
<a href="l381"></a><span id="l381">      <span class="keyword">val</span> <a title="CC[scales.utils.package.ItemOrTree[Item,Section,CC]]" id="82598">c</a> = <a href="#39605" title="=&gt; CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">children</a></span>
<a href="l382"></a><span id="l382">      <span title="Option[scales.utils.Path[Item,Section,CC]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#82598" title="CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">c</a>.<span title="=&gt; Int">length</span> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span title="object None">None</span> <span class="comment">// no children</span></span>
<a href="l383"></a><span id="l383">      <span class="keyword">else</span> <span class="delimiter">{</span></span>
<a href="l384"></a><span id="l384">	<span class="keyword">val</span> <a title="Int" id="82604">newPos</a> = <a href="#82598" title="CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">c</a>.<span title="=&gt; Int">length</span> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span></span>
<a href="l385"></a><span id="l385">	<span title="(x: scales.utils.Path[Item,Section,CC])Some[scales.utils.Path[Item,Section,CC]]">Some</span><span class="delimiter">(</span><a href="#84591" title="(top: scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]], node: scales.utils.Node[Item,Section,CC])(implicit cbf: scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]])scales.utils.Path[Item,Section,CC]">Path</a><a href="#67396" title="scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]]" class="delimiter">(</a><a href="#84591" title="scales.utils.Path[Item,Section,CC]" class="keyword">this</a>,</span>
<a href="l386"></a><span id="l386">	  <a href="#84597" title="(index: Int, focus: scales.utils.package.ItemOrTree[Item,Section,CC])scales.utils.Node[Item,Section,CC]">Node</a><span class="delimiter">(</span><a href="#82604" title="Int">newPos</a>, <a href="#82598" title="(idx: Int)scales.utils.package.ItemOrTree[Item,Section,CC]">c</a><span class="delimiter">(</span><a href="#82604" title="Int">newPos</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l387"></a><span id="l387">      <span class="delimiter">}</span></span>
<a href="l388"></a><span id="l388">    <span class="delimiter">}</span></span>
<a href="l389"></a><span id="l389">										   </span>
<a href="l390"></a><span id="l390">  <span class="comment">/**</span>
<a href="l391"></a><span id="l391">   * zipUp returns this if it is already the top item (doesn't have a parent to zip), and a</span>
<a href="l392"></a><span id="l392">   * newly zipped node when not if the focus has been modified</span>
<a href="l393"></a><span id="l393">   */</span></span>
<a href="l394"></a><span id="l394">  <span class="keyword">def</span> <a title="()scales.utils.Path[Item,Section,CC]" id="39615">zipUp</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#84591" title="scales.utils.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> =</span>
<a href="l395"></a><span id="l395">    <span title="scales.utils.Path[Item,Section,CC]" class="keyword">if</span> <span class="delimiter">(</span><a href="#67394" title="=&gt; scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]]">top</a>.<a href="EitherLike.scala.html#39633" title="=&gt; Boolean">isLeft</a><span class="delimiter">)</span> <a href="#84591" title="scales.utils.Path[Item,Section,CC]" class="keyword">this</a></span>
<a href="l396"></a><span id="l396">    <span class="keyword">else</span> <span class="delimiter">{</span></span>
<a href="l397"></a><span id="l397">      <span class="keyword">val</span> <a title="scales.utils.Path[Item,Section,CC]" id="82663">path</a> = <a href="#67394" title="=&gt; scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]]">top</a>.<a href="EitherLike.scala.html#39640" title="=&gt; scales.utils.RightLikeProjection[scales.utils.Path[Item,Section,CC]]">right</a>.<a href="EitherLike.scala.html#39620" title="=&gt; scales.utils.Path[Item,Section,CC]">get</a></span>
<a href="l398"></a><span id="l398">      <span class="keyword">val</span> <a title="scales.utils.Tree[Item,Section,CC]" id="82664">pt</a> = <a href="#39599" title="=&gt; scales.utils.Tree[Item,Section,CC]">parentTree</a></span>
<a href="l399"></a><span id="l399"></span>
<a href="l400"></a><span id="l400">      <span title="scales.utils.Path[Item,Section,CC]" class="keyword">if</span> <span class="delimiter">(</span><a href="#82664" title="scales.utils.Tree[Item,Section,CC]">pt</a>.<a href="Trees.scala.html#67496" title="(idx: Int)scales.utils.package.ItemOrTree[Item,Section,CC]">children</a><span class="delimiter">(</span><a href="#67395" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67442" title="=&gt; Int">index</a><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#67395" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67443" title="=&gt; scales.utils.package.ItemOrTree[Item,Section,CC]">focus</a><span class="delimiter">)</span> <a href="#82663" title="scales.utils.Path[Item,Section,CC]">path</a></span>
<a href="l401"></a><span id="l401">      <span class="keyword">else</span> <span class="delimiter">{</span></span>
<a href="l402"></a><span id="l402">        <span class="keyword">val</span> <a title="scales.utils.package.ItemOrTree[Item,Section,CC]" id="82668">parentFocus</a> = <span class="comment">// ZIP IT, must be a tree</span></span>
<a href="l403"></a><span id="l403">          <a href="package.scala.html#12062" title="(section: Section, children: CC[scales.utils.package.ItemOrTree[Item,Section,CC]])(implicit cbf: scales.utils.package.TreeCBF[Item,Section,CC])scales.utils.package.ItemOrTree[Item,Section,CC]">subtree</a><a href="#67396" title="scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]]" class="delimiter">(</a><a href="#82664" title="scales.utils.Tree[Item,Section,CC]">pt</a>.<a href="Trees.scala.html#67494" title="=&gt; Section">section</a>, <a href="#82664" title="scales.utils.Tree[Item,Section,CC]">pt</a>.<a href="Trees.scala.html#67496" title="=&gt; CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">children</a>.<span title="(index: Int, elem: scales.utils.package.ItemOrTree[Item,Section,CC])(implicit bf: scala.collection.generic.CanBuildFrom[CC[scales.utils.package.ItemOrTree[Item,Section,CC]],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]])CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">updated</span><a href="#67396" title="scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]]" class="delimiter">(</a><a href="#67395" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67442" title="=&gt; Int">index</a>, <a href="#67395" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67443" title="=&gt; scales.utils.package.ItemOrTree[Item,Section,CC]">focus</a><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l404"></a><span id="l404"></span>
<a href="l405"></a><span id="l405">        <a href="#84591" title="(top: scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]], node: scales.utils.Node[Item,Section,CC])(implicit cbf: scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]])scales.utils.Path[Item,Section,CC]">Path</a><a href="#67396" title="scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]]" class="delimiter">(</a><a href="#82663" title="scales.utils.Path[Item,Section,CC]">path</a>.<a href="#67394" title="=&gt; scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]]">top</a>, <a href="#84597" title="(index: Int, focus: scales.utils.package.ItemOrTree[Item,Section,CC])scales.utils.Node[Item,Section,CC]">Node</a><span class="delimiter">(</span><a href="#82663" title="scales.utils.Path[Item,Section,CC]">path</a>.<a href="#67395" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67442" title="=&gt; Int">index</a>,</span>
<a href="l406"></a><span id="l406">          <a href="#82668" title="scales.utils.package.ItemOrTree[Item,Section,CC]">parentFocus</a><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l407"></a><span id="l407">      <span class="delimiter">}</span></span>
<a href="l408"></a><span id="l408">    <span class="delimiter">}</span></span>
<a href="l409"></a><span id="l409"></span>
<a href="l410"></a><span id="l410">  <span class="comment">/**</span>
<a href="l411"></a><span id="l411">   * Replaces this paths focus returning the path for the returned node.</span>
<a href="l412"></a><span id="l412">   * @param</span>
<a href="l413"></a><span id="l413">   */</span></span>
<a href="l414"></a><span id="l414">  <span class="keyword">def</span> <a title="(newFocus: scales.utils.package.ItemOrTree[Item,Section,CC] =&gt; scales.utils.package.ItemOrTree[Item,Section,CC])scales.utils.Path[Item,Section,CC]" id="39616">modify</a><span class="delimiter">(</span><a title="scales.utils.package.ItemOrTree[Item,Section,CC] =&gt; scales.utils.package.ItemOrTree[Item,Section,CC]" id="67375">newFocus</a>: <span class="delimiter">(</span>ItemOrTree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; ItemOrTree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> =</span>
<a href="l415"></a><span id="l415">    <a href="#84591" title="(top: scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]], node: scales.utils.Node[Item,Section,CC])(implicit cbf: scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]])scales.utils.Path[Item,Section,CC]">Path</a><a href="#67396" title="scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]]" class="delimiter">(</a><a href="#67394" title="=&gt; scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]]">top</a>, <a href="#84597" title="(index: Int, focus: scales.utils.package.ItemOrTree[Item,Section,CC])scales.utils.Node[Item,Section,CC]">Node</a><span class="delimiter">(</span><a href="#67395" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67442" title="=&gt; Int">index</a>,</span>
<a href="l416"></a><span id="l416">      <a href="#67375" title="(v1: scales.utils.package.ItemOrTree[Item,Section,CC])scales.utils.package.ItemOrTree[Item,Section,CC]">newFocus</a><span class="delimiter">(</span><a href="#67395" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67443" title="=&gt; scales.utils.package.ItemOrTree[Item,Section,CC]">focus</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l417"></a><span id="l417"></span>
<a href="l418"></a><span id="l418">  <span class="comment">/**</span>
<a href="l419"></a><span id="l419">   * Removes this node, returning the parent path or None if its top</span>
<a href="l420"></a><span id="l420">   * @return</span>
<a href="l421"></a><span id="l421">   */</span></span>
<a href="l422"></a><span id="l422">  <span class="keyword">def</span> <a title="()Option[scales.utils.Path[Item,Section,CC]]" id="39617">removeAndUp</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Option[scales.utils.Path[Item,Section,CC]]">Option</span><span class="delimiter">[</span>Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span> =</span>
<a href="l423"></a><span id="l423">    <span title="Option[scales.utils.Path[Item,Section,CC]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#67394" title="=&gt; scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]]">top</a>.<a href="EitherLike.scala.html#39633" title="=&gt; Boolean">isLeft</a><span class="delimiter">)</span> <span title="object None">None</span></span>
<a href="l424"></a><span id="l424">    <span class="keyword">else</span> <span class="delimiter">{</span></span>
<a href="l425"></a><span id="l425">      <span class="keyword">val</span> <a title="scales.utils.Path[Item,Section,CC]" id="82789">path</a> = <a href="#67394" title="=&gt; scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]]">top</a>.<a href="EitherLike.scala.html#39640" title="=&gt; scales.utils.RightLikeProjection[scales.utils.Path[Item,Section,CC]]">right</a>.<a href="EitherLike.scala.html#39620" title="=&gt; scales.utils.Path[Item,Section,CC]">get</a></span>
<a href="l426"></a><span id="l426">      <span class="keyword">val</span> <a title="scales.utils.Tree[Item,Section,CC]" id="82790">tree</a> = <a href="#82789" title="scales.utils.Path[Item,Section,CC]">path</a>.<a href="#67395" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67443" title="=&gt; scales.utils.package.ItemOrTree[Item,Section,CC]">focus</a>.<a href="EitherLike.scala.html#39640" title="=&gt; scales.utils.RightLikeProjection[scales.utils.Tree[Item,Section,CC]]">right</a>.<a href="EitherLike.scala.html#39620" title="=&gt; scales.utils.Tree[Item,Section,CC]">get</a></span>
<a href="l427"></a><span id="l427"></span>
<a href="l428"></a><span id="l428">      <span class="keyword">val</span> <a title="scales.utils.package.ItemOrTree[Item,Section,CC]" id="82791">parentFocus</a> = <span class="delimiter">{</span></span>
<a href="l429"></a><span id="l429">	<span class="keyword">val</span> <a title="CC[scales.utils.package.ItemOrTree[Item,Section,CC]]" id="82792">c</a> = <a href="#39599" title="=&gt; scales.utils.Tree[Item,Section,CC]">parentTree</a>.<a href="Trees.scala.html#67496" title="=&gt; CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">children</a></span>
<a href="l430"></a><span id="l430"></span>
<a href="l431"></a><span id="l431">	<span title="scales.utils.package.ItemOrTree[Item,Section,CC]" class="keyword">if</span> <span class="delimiter">(</span><a href="#82792" title="CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">c</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span class="delimiter">{</span></span>
<a href="l432"></a><span id="l432">	  <span class="comment">// optimising for pull parse onqnames, if its only one in the parent, set the parent to empty, sucks if its not traversable</span></span>
<a href="l433"></a><span id="l433">	  <a href="package.scala.html#12062" title="(section: Section, children: CC[scales.utils.package.ItemOrTree[Item,Section,CC]])(implicit cbf: scales.utils.package.TreeCBF[Item,Section,CC])scales.utils.package.ItemOrTree[Item,Section,CC]">subtree</a><a href="#67396" title="scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]]" class="delimiter">(</a><a href="#82790" title="scales.utils.Tree[Item,Section,CC]">tree</a>.<a href="Trees.scala.html#67494" title="=&gt; Section">section</a>, <a href="#82792" title="CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">c</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Traversable[scales.utils.package.ItemOrTree[Item,Section,CC]]" class="delimiter">[</span>scala.collection.<span title="Traversable[scales.utils.package.ItemOrTree[Item,Section,CC]]">Traversable</span><span class="delimiter">[</span>ItemOrTree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span>.<span title="=&gt; scala.collection.generic.GenericCompanion[Traversable]">companion</span>.<span title="Traversable[Nothing]">empty</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="CC[scales.utils.package.ItemOrTree[Item,Section,CC]]" class="delimiter">[</span><a href="#67386" title="CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">CC</a><span class="delimiter">[</span>ItemOrTree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span></span>
<a href="l434"></a><span id="l434">	<span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span></span>
<a href="l435"></a><span id="l435">	  <span class="keyword">val</span> <a title="(CC[scales.utils.package.ItemOrTree[Item,Section,CC]], CC[scales.utils.package.ItemOrTree[Item,Section,CC]])" id="82937">parts</a> = <a href="#39599" title="=&gt; scales.utils.Tree[Item,Section,CC]">parentTree</a>.<a href="Trees.scala.html#67496" title="=&gt; CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">children</a>.<span title="(n: Int)(CC[scales.utils.package.ItemOrTree[Item,Section,CC]], CC[scales.utils.package.ItemOrTree[Item,Section,CC]])">splitAt</span><span class="delimiter">(</span><a href="#67395" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67442" title="=&gt; Int">index</a><span class="delimiter">)</span></span>
<a href="l436"></a><span id="l436">	  <a href="package.scala.html#12062" title="(section: Section, children: CC[scales.utils.package.ItemOrTree[Item,Section,CC]])(implicit cbf: scales.utils.package.TreeCBF[Item,Section,CC])scales.utils.package.ItemOrTree[Item,Section,CC]">subtree</a><a href="#67396" title="scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]]" class="delimiter">(</a><a href="#82790" title="scales.utils.Tree[Item,Section,CC]">tree</a>.<a href="Trees.scala.html#67494" title="=&gt; Section">section</a>, <a href="#82937" title="(CC[scales.utils.package.ItemOrTree[Item,Section,CC]], CC[scales.utils.package.ItemOrTree[Item,Section,CC]])">parts</a>.<span title="=&gt; CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">_1</span> <a href="#67396" title="(that: scala.collection.GenTraversableOnce[scales.utils.package.ItemOrTree[Item,Section,CC]])(implicit bf: scala.collection.generic.CanBuildFrom[CC[scales.utils.package.ItemOrTree[Item,Section,CC]],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]])CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">++</a> <a href="#82937" title="(CC[scales.utils.package.ItemOrTree[Item,Section,CC]], CC[scales.utils.package.ItemOrTree[Item,Section,CC]])">parts</a>.<span title="=&gt; CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">_2</span>.<span title="=&gt; CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">tail</span><span class="delimiter">)</span></span>
<a href="l437"></a><span id="l437">	<span class="delimiter">}</span></span>
<a href="l438"></a><span id="l438">	</span>
<a href="l439"></a><span id="l439">      <span class="delimiter">}</span></span>
<a href="l440"></a><span id="l440"></span>
<a href="l441"></a><span id="l441">      <span title="(x: scales.utils.Path[Item,Section,CC])Some[scales.utils.Path[Item,Section,CC]]">Some</span><span class="delimiter">(</span></span>
<a href="l442"></a><span id="l442">        <a href="#84591" title="(top: scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]], node: scales.utils.Node[Item,Section,CC])(implicit cbf: scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]])scales.utils.Path[Item,Section,CC]">Path</a><a href="#67396" title="scala.collection.generic.CanBuildFrom[CC[_],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]]" class="delimiter">(</a><a href="#82789" title="scales.utils.Path[Item,Section,CC]">path</a>.<a href="#67394" title="=&gt; scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]]">top</a>, <a href="#84597" title="(index: Int, focus: scales.utils.package.ItemOrTree[Item,Section,CC])scales.utils.Node[Item,Section,CC]">Node</a><span class="delimiter">(</span><a href="#82789" title="scales.utils.Path[Item,Section,CC]">path</a>.<a href="#67395" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67442" title="=&gt; Int">index</a>,</span>
<a href="l443"></a><span id="l443">          <a href="#82791" title="scales.utils.package.ItemOrTree[Item,Section,CC]">parentFocus</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l444"></a><span id="l444">    <span class="delimiter">}</span></span>
<a href="l445"></a><span id="l445"></span>
<a href="l446"></a><span id="l446">  <span class="comment">/**</span>
<a href="l447"></a><span id="l447">   * Gets the relative position of this Path</span>
<a href="l448"></a><span id="l448">   * DOES NOT perform a zip</span>
<a href="l449"></a><span id="l449">   */</span></span>
<a href="l450"></a><span id="l450">  <span class="keyword">def</span> <a title="()scales.utils.Position[Item,Section,CC]" id="39618">position</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#10517" title="scales.utils.Position[Item,Section,CC]">Position</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> = <span class="delimiter">{</span></span>
<a href="l451"></a><span id="l451">    @scala.annotation.tailrec</span>
<a href="l452"></a><span id="l452">    <span class="keyword">def</span> <a title="(path: scales.utils.Path[Item,Section,CC], stack: scala.collection.immutable.Stack[Int])(scala.collection.immutable.Stack[Int], scales.utils.Path[Item,Section,CC])" id="83045">makePosition</a><span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC]" id="83047">path</a>: <a href="#84591" title="scales.utils.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, <a title="scala.collection.immutable.Stack[Int]" id="83048">stack</a>: <span title="scala.collection.immutable.Stack[Int]">Stack</span><span class="delimiter">[</span>Int<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(scala.collection.immutable.Stack[Int], scales.utils.Path[Item,Section,CC])" class="delimiter">(</span>Stack<span class="delimiter">[</span>Int<span class="delimiter">]</span>, Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span></span>
<a href="l453"></a><span id="l453">      <span class="keyword">val</span> <a title="scala.collection.immutable.Stack[Int]" id="83049">newStack</a> = <a href="#83048" title="scala.collection.immutable.Stack[Int]">stack</a>.<span title="(elem: Int)scala.collection.immutable.Stack[Int]">push</span><span class="delimiter">(</span><a href="#83047" title="scales.utils.Path[Item,Section,CC]">path</a>.<a href="#67395" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67442" title="=&gt; Int">index</a><span class="delimiter">)</span></span>
<a href="l454"></a><span id="l454">      <span title="(scala.collection.immutable.Stack[Int], scales.utils.Path[Item,Section,CC])" class="keyword">if</span> <span class="delimiter">(</span><a href="#83047" title="scales.utils.Path[Item,Section,CC]">path</a>.<a href="#67394" title="=&gt; scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]]">top</a>.<a href="EitherLike.scala.html#39633" title="=&gt; Boolean">isLeft</a><span class="delimiter">)</span></span>
<a href="l455"></a><span id="l455">        <span title="(_1: scala.collection.immutable.Stack[Int], _2: scales.utils.Path[Item,Section,CC])(scala.collection.immutable.Stack[Int], scales.utils.Path[Item,Section,CC])" class="delimiter">(</span><a href="#83049" title="scala.collection.immutable.Stack[Int]">newStack</a>, <a href="#83047" title="scales.utils.Path[Item,Section,CC]">path</a><span class="delimiter">)</span></span>
<a href="l456"></a><span id="l456">      <span class="keyword">else</span></span>
<a href="l457"></a><span id="l457">        <a href="#83045" title="(path: scales.utils.Path[Item,Section,CC], stack: scala.collection.immutable.Stack[Int])(scala.collection.immutable.Stack[Int], scales.utils.Path[Item,Section,CC])">makePosition</a><span class="delimiter">(</span><a href="#83047" title="scales.utils.Path[Item,Section,CC]">path</a>.<a href="#67394" title="=&gt; scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]]">top</a>.<a href="EitherLike.scala.html#39640" title="=&gt; scales.utils.RightLikeProjection[scales.utils.Path[Item,Section,CC]]">right</a>.<a href="EitherLike.scala.html#39620" title="=&gt; scales.utils.Path[Item,Section,CC]">get</a>, <a href="#83049" title="scala.collection.immutable.Stack[Int]">newStack</a><span class="delimiter">)</span></span>
<a href="l458"></a><span id="l458">    <span class="delimiter">}</span></span>
<a href="l459"></a><span id="l459"></span>
<a href="l460"></a><span id="l460">    <span class="keyword">val</span> <a title="(scala.collection.immutable.Stack[Int], scales.utils.Path[Item,Section,CC])" id="83046">res</a> = <a href="#83045" title="(path: scales.utils.Path[Item,Section,CC], stack: scala.collection.immutable.Stack[Int])(scala.collection.immutable.Stack[Int], scales.utils.Path[Item,Section,CC])">makePosition</a><span class="delimiter">(</span><a href="#84591" title="scales.utils.Path[Item,Section,CC]" class="keyword">this</a>, <span title="[A](elems: A*)scala.collection.immutable.Stack[A]">Stack</span><span title="(elems: Int*)scala.collection.immutable.Stack[Int]" class="delimiter">[</span><span title="Int">Int</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l461"></a><span id="l461">    <span title="scales.utils.PositionImpl[Item,Section,CC]" class="keyword">new</span> <a href="#84609" title="scales.utils.PositionImpl[Item,Section,CC]">PositionImpl</a><span class="delimiter">[</span>Item,Section,CC<span class="delimiter">]</span><span class="delimiter">(</span><a href="#83046" title="(scala.collection.immutable.Stack[Int], scales.utils.Path[Item,Section,CC])">res</a>.<span title="=&gt; scala.collection.immutable.Stack[Int]">_1</span>, <a href="#83046" title="(scala.collection.immutable.Stack[Int], scales.utils.Path[Item,Section,CC])">res</a>.<span title="=&gt; scales.utils.Path[Item,Section,CC]">_2</span><span class="delimiter">)</span></span>
<a href="l462"></a><span id="l462">  <span class="delimiter">}</span></span>
<a href="l463"></a><span id="l463"></span>
<a href="l464"></a><span id="l464">  <span class="comment">/**</span>
<a href="l465"></a><span id="l465">   * Gives a nicer representation then the standard (Paths(Paths(), Paths).  But still too much info</span>
<a href="l466"></a><span id="l466">   *</span>
<a href="l467"></a><span id="l467">   * Path( Section | Top, FocusSection | FocusItem)</span>
<a href="l468"></a><span id="l468">   *</span>
<a href="l469"></a><span id="l469">   * @return</span>
<a href="l470"></a><span id="l470">   */</span></span>
<a href="l471"></a><span id="l471">  <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="39619">toString</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="String">String</span> = <span class="delimiter">{</span></span>
<a href="l472"></a><span id="l472">    <span class="keyword">val</span> <a title="java.lang.StringBuilder" id="83077">builder</a> = <span title="java.lang.StringBuilder" class="keyword">new</span> java.lang.<span title="java.lang.StringBuilder">StringBuilder</span><span class="delimiter">(</span><span class="delimiter">)</span></span>
<a href="l473"></a><span id="l473"></span>
<a href="l474"></a><span id="l474">    <a href="#83077" title="java.lang.StringBuilder">builder</a>.<span title="(x$1: java.lang.String)java.lang.StringBuilder">append</span><span class="delimiter">(</span><span title="java.lang.String(&quot;Path(&quot;)" class="string">&quot;Path(&quot;</span><span class="delimiter">)</span>;</span>
<a href="l475"></a><span id="l475">    <span title="java.lang.StringBuilder" class="keyword">if</span> <span class="delimiter">(</span><a href="#67394" title="=&gt; scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]]">top</a>.<a href="EitherLike.scala.html#39633" title="=&gt; Boolean">isLeft</a><span class="delimiter">)</span></span>
<a href="l476"></a><span id="l476">      <a href="#83077" title="java.lang.StringBuilder">builder</a>.<span title="(x$1: java.lang.String)java.lang.StringBuilder">append</span><span class="delimiter">(</span><span title="java.lang.String(&quot;Top&quot;)" class="string">&quot;Top&quot;</span><span class="delimiter">)</span>;</span>
<a href="l477"></a><span id="l477">    <span class="keyword">else</span></span>
<a href="l478"></a><span id="l478">      <a href="#83077" title="java.lang.StringBuilder">builder</a>.<span title="(x$1: Any)java.lang.StringBuilder">append</span><span class="delimiter">(</span><a href="#67394" title="=&gt; scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]]">top</a>.<a href="EitherLike.scala.html#39640" title="=&gt; scales.utils.RightLikeProjection[scales.utils.Path[Item,Section,CC]]">right</a>.<a href="EitherLike.scala.html#39620" title="=&gt; scales.utils.Path[Item,Section,CC]">get</a>.<a href="#39608" title="()scales.utils.Tree[Item,Section,CC]">tree</a>.<a href="Trees.scala.html#67494" title="=&gt; Section">section</a><span class="delimiter">)</span>;</span>
<a href="l479"></a><span id="l479">    <a href="#83077" title="java.lang.StringBuilder">builder</a>.<span title="(x$1: java.lang.String)java.lang.StringBuilder">append</span><span class="delimiter">(</span><span title="java.lang.String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span>;</span>
<a href="l480"></a><span id="l480">    <span title="java.lang.StringBuilder" class="keyword">if</span> <span class="delimiter">(</span><a href="#39603" title="=&gt; Boolean">isItem</a><span class="delimiter">)</span></span>
<a href="l481"></a><span id="l481">      <a href="#83077" title="java.lang.StringBuilder">builder</a>.<span title="(x$1: Any)java.lang.StringBuilder">append</span><span class="delimiter">(</span><a href="#39609" title="()Item">item</a><span class="delimiter">)</span>;</span>
<a href="l482"></a><span id="l482">    <span class="keyword">else</span></span>
<a href="l483"></a><span id="l483">      <a href="#83077" title="java.lang.StringBuilder">builder</a>.<span title="(x$1: Any)java.lang.StringBuilder">append</span><span class="delimiter">(</span><a href="#39608" title="()scales.utils.Tree[Item,Section,CC]">tree</a>.<a href="Trees.scala.html#67494" title="=&gt; Section">section</a><span class="delimiter">)</span>;</span>
<a href="l484"></a><span id="l484">    <a href="#83077" title="java.lang.StringBuilder">builder</a>.<span title="(x$1: java.lang.String)java.lang.StringBuilder">append</span><span class="delimiter">(</span><span title="java.lang.String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span>;</span>
<a href="l485"></a><span id="l485"></span>
<a href="l486"></a><span id="l486">    <a href="#83077" title="java.lang.StringBuilder">builder</a>.<span title="()java.lang.String">toString</span></span>
<a href="l487"></a><span id="l487">  <span class="delimiter">}</span></span>
<a href="l488"></a><span id="l488"><span class="delimiter">}</span></span>
<a href="l489"></a><span id="l489"></span>
<a href="l490"></a><span id="l490"><span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait FoldOperation[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]] extends java.lang.Object with ScalaObject" id="10539">FoldOperation</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="10540">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="10541">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="10542">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="83203">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> <span title="ScalaObject" class="delimiter">{</span></span>
<a href="l491"></a><span id="l491"></span>
<a href="l492"></a><span id="l492">  <span class="keyword">def</span> <a title="(positions: Seq[scales.utils.Position[Item,Section,CC]])Seq[scales.utils.Position[Item,Section,CC]]" id="80075">adjust</a><span class="delimiter">(</span><a title="Seq[scales.utils.Position[Item,Section,CC]]" id="80255">positions</a>: <span title="Seq[scales.utils.Position[Item,Section,CC]]">Seq</span><span class="delimiter">[</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Seq[scales.utils.Position[Item,Section,CC]]">Seq</span><span class="delimiter">[</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span></span>
<a href="l493"></a><span id="l493"></span>
<a href="l494"></a><span id="l494">  <span class="keyword">def</span> <a title="(path: scales.utils.Path[Item,Section,CC])scales.utils.package.FoldR[Item,Section,CC]" id="80076">perform</a><span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC]" id="80252">path</a>: <a href="#84591" title="scales.utils.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scales.utils.package.FoldR[Item,Section,CC]">FoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span></span>
<a href="l495"></a><span id="l495"></span>
<a href="l496"></a><span id="l496">  <span class="keyword">def</span> <a title="(path: scales.utils.Path[Item,Section,CC], direction: Int, newPath: Iterable[scales.utils.package.ItemOrTree[Item,Section,CC]])(implicit cbf: scales.utils.package.TreeCBF[Item,Section,CC])scales.utils.package.FoldR[Item,Section,CC]" id="80077">add</a><span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC]" id="83206">path</a>: <a href="#84591" title="scales.utils.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, <a title="Int" id="83207">direction</a>: <span title="Int">Int</span>, <a title="Iterable[scales.utils.package.ItemOrTree[Item,Section,CC]]" id="83208">newPath</a>: <span title="Iterable[scales.utils.package.ItemOrTree[Item,Section,CC]]">Iterable</span><span class="delimiter">[</span>ItemOrTree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scales.utils.package.TreeCBF[Item,Section,CC]" id="83209">cbf</a> : <span title="scales.utils.package.TreeCBF[Item,Section,CC]">TreeCBF</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> : <span title="scales.utils.package.FoldR[Item,Section,CC]">FoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> = <span class="delimiter">{</span></span>
<a href="l497"></a><span id="l497">    <span class="comment">// need to go up to replace</span></span>
<a href="l498"></a><span id="l498">    <span class="keyword">val</span> <a title="scales.utils.Path[Item,Section,CC]" id="83211">parent</a> = <a href="#83206" title="scales.utils.Path[Item,Section,CC]">path</a>.<a href="#39615" title="()scales.utils.Path[Item,Section,CC]">zipUp</a></span>
<a href="l499"></a><span id="l499">    <span title="scales.utils.package.FoldR[Item,Section,CC]" class="keyword">if</span> <span class="delimiter">(</span><a href="#83206" title="scales.utils.Path[Item,Section,CC]">path</a>.<a href="#67394" title="=&gt; scales.utils.EitherLike[scales.utils.Top[Item,Section,CC],scales.utils.Path[Item,Section,CC]]">top</a>.<a href="EitherLike.scala.html#39633" title="=&gt; Boolean">isLeft</a><span class="delimiter">)</span></span>
<a href="l500"></a><span id="l500">      <span title="(b: scales.utils.AddedBeforeOrAfterRoot.type)Right[Nothing,scales.utils.AddedBeforeOrAfterRoot.type]">Right</span><span class="delimiter">(</span><a href="#84528" title="object scales.utils.AddedBeforeOrAfterRoot">AddedBeforeOrAfterRoot</a><span class="delimiter">)</span></span>
<a href="l501"></a><span id="l501">    <span class="keyword">else</span></span>
<a href="l502"></a><span id="l502">      <span title="(a: scales.utils.Path[Item,Section,CC])Left[scales.utils.Path[Item,Section,CC],Nothing]">Left</span><span class="delimiter">(</span><a href="#83211" title="scales.utils.Path[Item,Section,CC]">parent</a>.</span>
<a href="l503"></a><span id="l503">        <a href="#39616" title="(newFocus: scales.utils.package.ItemOrTree[Item,Section,CC] =&gt; scales.utils.package.ItemOrTree[Item,Section,CC])scales.utils.Path[Item,Section,CC]">modify</a> <span class="delimiter">{</span> <a title="scales.utils.package.ItemOrTree[Item,Section,CC]" id="83228">x</a> =&gt;</span>
<a href="l504"></a><span id="l504">          <span class="keyword">val</span> <a title="scales.utils.Tree[Item,Section,CC]" id="83229">tree</a> = <a href="#83228" title="scales.utils.package.ItemOrTree[Item,Section,CC]">x</a>.<a href="EitherLike.scala.html#39640" title="=&gt; scales.utils.RightLikeProjection[scales.utils.Tree[Item,Section,CC]]">right</a>.<a href="EitherLike.scala.html#39620" title="=&gt; scales.utils.Tree[Item,Section,CC]">get</a>;</span>
<a href="l505"></a><span id="l505">          <span class="keyword">val</span> <a title="Int" id="83230">index</a> = <a href="#83206" title="scales.utils.Path[Item,Section,CC]">path</a>.<a href="#67395" title="=&gt; scales.utils.Node[Item,Section,CC]">node</a>.<a href="#67442" title="=&gt; Int">index</a> <span title="(x: Int)Int">+</span> <a href="#83207" title="Int">direction</a></span>
<a href="l506"></a><span id="l506">          <span class="keyword">val</span> <a href="#83232" title="(CC[scales.utils.package.ItemOrTree[Item,Section,CC]], CC[scales.utils.package.ItemOrTree[Item,Section,CC]])" class="delimiter">(</a><a href="#83231" title="CC[scales.utils.package.ItemOrTree[Item,Section,CC]]" id="83232">pre</a>,<a href="#83231" title="CC[scales.utils.package.ItemOrTree[Item,Section,CC]]" id="83233">pos</a><span class="delimiter">)</span> = <a href="#83229" title="scales.utils.Tree[Item,Section,CC]">tree</a>.<a href="Trees.scala.html#67496" title="=&gt; CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">children</a>.<span title="(n: Int)(CC[scales.utils.package.ItemOrTree[Item,Section,CC]], CC[scales.utils.package.ItemOrTree[Item,Section,CC]])">splitAt</span><span title="(CC[scales.utils.package.ItemOrTree[Item,Section,CC]], CC[scales.utils.package.ItemOrTree[Item,Section,CC]]) @unchecked" class="delimiter">(</span><a href="#83230" title="Int">index</a><span class="delimiter">)</span></span>
<a href="l507"></a><span id="l507">          <span class="keyword">val</span> <a title="CC[scales.utils.package.ItemOrTree[Item,Section,CC]]" id="83234">newChildren</a> = <span class="delimiter">(</span><a href="#83232" title="CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">pre</a> <a href="#83209" title="(that: scala.collection.GenTraversableOnce[scales.utils.package.ItemOrTree[Item,Section,CC]])(implicit bf: scala.collection.generic.CanBuildFrom[CC[scales.utils.package.ItemOrTree[Item,Section,CC]],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]])CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">++</a> <a href="#83208" title="Iterable[scales.utils.package.ItemOrTree[Item,Section,CC]]">newPath</a><span class="delimiter">)</span> <a href="#83209" title="(that: scala.collection.GenTraversableOnce[scales.utils.package.ItemOrTree[Item,Section,CC]])(implicit bf: scala.collection.generic.CanBuildFrom[CC[scales.utils.package.ItemOrTree[Item,Section,CC]],scales.utils.package.ItemOrTree[Item,Section,CC],CC[scales.utils.package.ItemOrTree[Item,Section,CC]]])CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">++</a> <a href="#83233" title="CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">pos</a></span>
<a href="l508"></a><span id="l508">          <a href="Trees.scala.html#80175" title="(section: Section, children: CC[scales.utils.package.ItemOrTree[Item,Section,CC]])scales.utils.Tree[Item,Section,CC]">Tree</a><span class="delimiter">(</span><a href="#83229" title="scales.utils.Tree[Item,Section,CC]">tree</a>.<a href="Trees.scala.html#67494" title="=&gt; Section">section</a>, <a href="#83234" title="CC[scales.utils.package.ItemOrTree[Item,Section,CC]]">newChildren</a><span class="delimiter">)</span><span class="comment">//Right()</span></span>
<a href="l509"></a><span id="l509">        <span class="delimiter">}</span><span class="delimiter">)</span></span>
<a href="l510"></a><span id="l510"></span>
<a href="l511"></a><span id="l511">  <span class="delimiter">}</span></span>
<a href="l512"></a><span id="l512"><span class="delimiter">}</span></span>
<a href="l513"></a><span id="l513"></span>
<a href="l514"></a><span id="l514">case <span class="keyword">class</span> <a title="class Remove[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]] extends java.lang.Object with scales.utils.FoldOperation[Item,Section,CC] with ScalaObject with Product with Serializable" id="84581">Remove</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="83498">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="83499">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="83500">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="84577">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><a href="#84581" title="ScalaObject" class="delimiter">(</a><span class="keyword">implicit</span> <a title="scales.utils.package.TreeCBF[Item,Section,CC]" id="84576">cbf</a> : <span title="scales.utils.package.TreeCBF[Item,Section,CC]">TreeCBF</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#10539" title="scales.utils.FoldOperation[Item,Section,CC]">FoldOperation</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> <span class="delimiter">{</span></span>
<a href="l515"></a><span id="l515">  <span class="keyword">def</span> <a title="(positions: Seq[scales.utils.Position[Item,Section,CC]])Seq[scales.utils.Position[Item,Section,CC]]" id="83347">adjust</a><span class="delimiter">(</span><a title="Seq[scales.utils.Position[Item,Section,CC]]" id="83360">positions</a>: <span title="Seq[scales.utils.Position[Item,Section,CC]]">Seq</span><span class="delimiter">[</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Seq[scales.utils.Position[Item,Section,CC]]">Seq</span><span class="delimiter">[</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#12236" title="(positions: Seq[scales.utils.Position[Item,Section,CC]])Seq[scales.utils.Position[Item,Section,CC]]">cleanBelow</a><span class="delimiter">(</span><a href="#83360" title="Seq[scales.utils.Position[Item,Section,CC]]">positions</a><span class="delimiter">)</span>.<span title="(f: scales.utils.Position[Item,Section,CC] =&gt; scales.utils.Position[Item,Section,CC])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[scales.utils.Position[Item,Section,CC]],scales.utils.Position[Item,Section,CC],Seq[scales.utils.Position[Item,Section,CC]]])Seq[scales.utils.Position[Item,Section,CC]]">map</span> <span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,scales.utils.Position[Item,Section,CC],Seq[scales.utils.Position[Item,Section,CC]]]" class="delimiter">{</span> <a href="#12229" title="(base: scales.utils.Position[Item,Section,CC], x: scales.utils.Position[Item,Section,CC], by: Int)scales.utils.Position[Item,Section,CC]">shiftWithBase</a><span class="delimiter">(</span><a href="#83360" title="Seq[scales.utils.Position[Item,Section,CC]]">positions</a>.<span title="=&gt; scales.utils.Position[Item,Section,CC]">head</span>, <a href="#83417" title="scales.utils.Position[Item,Section,CC]">_</a>, -<span title="Int(-1)" class="int">1</span><span class="delimiter">)</span> <span class="delimiter">}</span></span>
<a href="l516"></a><span id="l516"></span>
<a href="l517"></a><span id="l517">  <span class="keyword">def</span> <a title="(path: scales.utils.Path[Item,Section,CC])scales.utils.package.FoldR[Item,Section,CC]" id="83348">perform</a><span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC]" id="83454">path</a>: <a href="#84591" title="scales.utils.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scales.utils.package.FoldR[Item,Section,CC]">FoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> = <span class="delimiter">{</span></span>
<a href="l518"></a><span id="l518">    <span class="keyword">val</span> <a title="Option[scales.utils.Path[Item,Section,CC]]" id="83457">ores</a> = <a href="#83454" title="scales.utils.Path[Item,Section,CC]">path</a>.<a href="#39617" title="()Option[scales.utils.Path[Item,Section,CC]]">removeAndUp</a><span class="delimiter">(</span><span class="delimiter">)</span>;</span>
<a href="l519"></a><span id="l519">    <span title="scales.utils.package.FoldR[Item,Section,CC]" class="keyword">if</span> <span class="delimiter">(</span><a href="#83457" title="Option[scales.utils.Path[Item,Section,CC]]">ores</a>.<span title="=&gt; Boolean">isDefined</span><span class="delimiter">)</span> <span title="(a: scales.utils.Path[Item,Section,CC])Left[scales.utils.Path[Item,Section,CC],Nothing]">Left</span><span class="delimiter">(</span><a href="#83457" title="Option[scales.utils.Path[Item,Section,CC]]">ores</a>.<span title="=&gt; scales.utils.Path[Item,Section,CC]">get</span><span class="delimiter">)</span></span>
<a href="l520"></a><span id="l520">    <span class="keyword">else</span> <span title="(b: scales.utils.RemovedRoot.type)Right[Nothing,scales.utils.RemovedRoot.type]">Right</span><span class="delimiter">(</span><a href="#84516" title="object scales.utils.RemovedRoot">RemovedRoot</a><span class="delimiter">)</span></span>
<a href="l521"></a><span id="l521">  <span class="delimiter">}</span></span>
<a href="l522"></a><span id="l522"><span class="delimiter">}</span></span>
<a href="l523"></a><span id="l523"></span>
<a href="l524"></a><span id="l524">case <span class="keyword">class</span> <a title="class AddBefore[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]] extends java.lang.Object with scales.utils.FoldOperation[Item,Section,CC] with ScalaObject with Product with Serializable" id="84572">AddBefore</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="83688">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="83689">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="83690">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="84566">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><a href="#84572" title="ScalaObject" class="delimiter">(</a><a title="scales.utils.package.ItemOrTree[Item,Section,CC]" id="84564">newPath</a>: <a href="EitherLike.scala.html#10328" title="scales.utils.package.ItemOrTree[Item,Section,CC]">ItemOrTree</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scales.utils.package.TreeCBF[Item,Section,CC]" id="84565">cbf</a> : <span title="scales.utils.package.TreeCBF[Item,Section,CC]">TreeCBF</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#10539" title="scales.utils.FoldOperation[Item,Section,CC]">FoldOperation</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> <span class="delimiter">{</span></span>
<a href="l525"></a><span id="l525">  <span class="keyword">def</span> <a title="(positions: Seq[scales.utils.Position[Item,Section,CC]])Seq[scales.utils.Position[Item,Section,CC]]" id="83540">adjust</a><span class="delimiter">(</span><a title="Seq[scales.utils.Position[Item,Section,CC]]" id="83555">positions</a>: <span title="Seq[scales.utils.Position[Item,Section,CC]]">Seq</span><span class="delimiter">[</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Seq[scales.utils.Position[Item,Section,CC]]">Seq</span><span class="delimiter">[</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#83555" title="Seq[scales.utils.Position[Item,Section,CC]]">positions</a>.<span title="=&gt; Seq[scales.utils.Position[Item,Section,CC]]">tail</span>.<span title="(f: scales.utils.Position[Item,Section,CC] =&gt; scales.utils.Position[Item,Section,CC])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[scales.utils.Position[Item,Section,CC]],scales.utils.Position[Item,Section,CC],Seq[scales.utils.Position[Item,Section,CC]]])Seq[scales.utils.Position[Item,Section,CC]]">map</span> <span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,scales.utils.Position[Item,Section,CC],Seq[scales.utils.Position[Item,Section,CC]]]" class="delimiter">{</span> <a href="#12229" title="(base: scales.utils.Position[Item,Section,CC], x: scales.utils.Position[Item,Section,CC], by: Int)scales.utils.Position[Item,Section,CC]">shiftWithBase</a><span class="delimiter">(</span><a href="#83555" title="Seq[scales.utils.Position[Item,Section,CC]]">positions</a>.<span title="=&gt; scales.utils.Position[Item,Section,CC]">head</span>, <a href="#83594" title="scales.utils.Position[Item,Section,CC]">_</a>, <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span class="delimiter">}</span></span>
<a href="l526"></a><span id="l526"></span>
<a href="l527"></a><span id="l527">  <span class="keyword">def</span> <a title="(path: scales.utils.Path[Item,Section,CC])scales.utils.package.FoldR[Item,Section,CC]" id="83541">perform</a><span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC]" id="83631">path</a>: <a href="#84591" title="scales.utils.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scales.utils.package.FoldR[Item,Section,CC]">FoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> = <a href="#80077" title="(path: scales.utils.Path[Item,Section,CC], direction: Int, newPath: Iterable[scales.utils.package.ItemOrTree[Item,Section,CC]])(implicit cbf: scales.utils.package.TreeCBF[Item,Section,CC])scales.utils.package.FoldR[Item,Section,CC]">add</a><a href="#84565" title="scales.utils.package.TreeCBF[Item,Section,CC]" class="delimiter">(</a><a href="#83631" title="scales.utils.Path[Item,Section,CC]">path</a>, <span title="Int(0)" class="int">0</span>, <span title="(xs: scales.utils.package.ItemOrTree[Item,Section,CC]*)List[scales.utils.package.ItemOrTree[Item,Section,CC]]">List</span><span class="delimiter">(</span><a href="#84564" title="=&gt; scales.utils.package.ItemOrTree[Item,Section,CC]">newPath</a><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l528"></a><span id="l528"><span class="delimiter">}</span></span>
<a href="l529"></a><span id="l529"></span>
<a href="l530"></a><span id="l530">case <span class="keyword">class</span> <a title="class AddAfter[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]] extends java.lang.Object with scales.utils.FoldOperation[Item,Section,CC] with ScalaObject with Product with Serializable" id="84560">AddAfter</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="83886">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="83887">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="83888">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="84554">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><a href="#84560" title="ScalaObject" class="delimiter">(</a><a title="scales.utils.package.ItemOrTree[Item,Section,CC]" id="84552">newPath</a>: <a href="EitherLike.scala.html#10328" title="scales.utils.package.ItemOrTree[Item,Section,CC]">ItemOrTree</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scales.utils.package.TreeCBF[Item,Section,CC]" id="84553">cbf</a> : <span title="scales.utils.package.TreeCBF[Item,Section,CC]">TreeCBF</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#10539" title="scales.utils.FoldOperation[Item,Section,CC]">FoldOperation</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> <span class="delimiter">{</span></span>
<a href="l531"></a><span id="l531">  <span class="keyword">def</span> <a title="(positions: Seq[scales.utils.Position[Item,Section,CC]])Seq[scales.utils.Position[Item,Section,CC]]" id="83738">adjust</a><span class="delimiter">(</span><a title="Seq[scales.utils.Position[Item,Section,CC]]" id="83753">positions</a>: <span title="Seq[scales.utils.Position[Item,Section,CC]]">Seq</span><span class="delimiter">[</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Seq[scales.utils.Position[Item,Section,CC]]">Seq</span><span class="delimiter">[</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#83753" title="Seq[scales.utils.Position[Item,Section,CC]]">positions</a>.<span title="=&gt; Seq[scales.utils.Position[Item,Section,CC]]">tail</span>.<span title="(f: scales.utils.Position[Item,Section,CC] =&gt; scales.utils.Position[Item,Section,CC])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[scales.utils.Position[Item,Section,CC]],scales.utils.Position[Item,Section,CC],Seq[scales.utils.Position[Item,Section,CC]]])Seq[scales.utils.Position[Item,Section,CC]]">map</span> <span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,scales.utils.Position[Item,Section,CC],Seq[scales.utils.Position[Item,Section,CC]]]" class="delimiter">{</span> <a href="#12229" title="(base: scales.utils.Position[Item,Section,CC], x: scales.utils.Position[Item,Section,CC], by: Int)scales.utils.Position[Item,Section,CC]">shiftWithBase</a><span class="delimiter">(</span><a href="#83753" title="Seq[scales.utils.Position[Item,Section,CC]]">positions</a>.<span title="=&gt; scales.utils.Position[Item,Section,CC]">head</span>, <a href="#83792" title="scales.utils.Position[Item,Section,CC]">_</a>, <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span class="delimiter">}</span></span>
<a href="l532"></a><span id="l532"></span>
<a href="l533"></a><span id="l533">  <span class="keyword">def</span> <a title="(path: scales.utils.Path[Item,Section,CC])scales.utils.package.FoldR[Item,Section,CC]" id="83739">perform</a><span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC]" id="83829">path</a>: <a href="#84591" title="scales.utils.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scales.utils.package.FoldR[Item,Section,CC]">FoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> = <a href="#80077" title="(path: scales.utils.Path[Item,Section,CC], direction: Int, newPath: Iterable[scales.utils.package.ItemOrTree[Item,Section,CC]])(implicit cbf: scales.utils.package.TreeCBF[Item,Section,CC])scales.utils.package.FoldR[Item,Section,CC]">add</a><a href="#84553" title="scales.utils.package.TreeCBF[Item,Section,CC]" class="delimiter">(</a><a href="#83829" title="scales.utils.Path[Item,Section,CC]">path</a>, <span title="Int(1)" class="int">1</span>, <span title="(xs: scales.utils.package.ItemOrTree[Item,Section,CC]*)List[scales.utils.package.ItemOrTree[Item,Section,CC]]">List</span><span class="delimiter">(</span><a href="#84552" title="=&gt; scales.utils.package.ItemOrTree[Item,Section,CC]">newPath</a><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l534"></a><span id="l534"><span class="delimiter">}</span></span>
<a href="l535"></a><span id="l535"></span>
<a href="l536"></a><span id="l536"><span class="comment">/**</span>
<a href="l537"></a><span id="l537"> * Use to make it easier to filter out large sets (for those that aren't interesting simply asis them, see tests for use case)</span>
<a href="l538"></a><span id="l538"> */</span></span>
<a href="l539"></a><span id="l539">case <span class="keyword">class</span> <a title="class AsIs[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]] extends java.lang.Object with scales.utils.FoldOperation[Item,Section,CC] with ScalaObject with Product with Serializable" id="84548">AsIs</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="83961">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="83962">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="83963">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="84546">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><a href="#84548" title="ScalaObject" class="delimiter">(</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#10539" title="scales.utils.FoldOperation[Item,Section,CC]">FoldOperation</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> <span class="delimiter">{</span></span>
<a href="l540"></a><span id="l540">  <span class="comment">/**</span>
<a href="l541"></a><span id="l541">   * No OP, just move one one</span>
<a href="l542"></a><span id="l542">   */</span></span>
<a href="l543"></a><span id="l543">  <span class="keyword">def</span> <a title="(positions: Seq[scales.utils.Position[Item,Section,CC]])Seq[scales.utils.Position[Item,Section,CC]]" id="83931">adjust</a><span class="delimiter">(</span><a title="Seq[scales.utils.Position[Item,Section,CC]]" id="83935">positions</a>: <span title="Seq[scales.utils.Position[Item,Section,CC]]">Seq</span><span class="delimiter">[</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Seq[scales.utils.Position[Item,Section,CC]]">Seq</span><span class="delimiter">[</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#83935" title="Seq[scales.utils.Position[Item,Section,CC]]">positions</a>.<span title="=&gt; Seq[scales.utils.Position[Item,Section,CC]]">tail</span></span>
<a href="l544"></a><span id="l544"></span>
<a href="l545"></a><span id="l545">  <span class="keyword">def</span> <a title="(path: scales.utils.Path[Item,Section,CC])scales.utils.package.FoldR[Item,Section,CC]" id="83932">perform</a><span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC]" id="83938">path</a>: <a href="#84591" title="scales.utils.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scales.utils.package.FoldR[Item,Section,CC]">FoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> = <span title="(a: scales.utils.Path[Item,Section,CC])Left[scales.utils.Path[Item,Section,CC],Nothing]">Left</span><span class="delimiter">(</span><a href="#83938" title="scales.utils.Path[Item,Section,CC]">path</a><span class="delimiter">)</span></span>
<a href="l546"></a><span id="l546"><span class="delimiter">}</span></span>
<a href="l547"></a><span id="l547"></span>
<a href="l548"></a><span id="l548"><span class="keyword">object</span> <a title="object scales.utils.Replace" id="84070">Replace</a> <span title="ScalaObject" class="delimiter">{</span></span>
<a href="l549"></a><span id="l549">  <span class="comment">/**</span>
<a href="l550"></a><span id="l550">   * Simpler interface</span>
<a href="l551"></a><span id="l551">   */</span></span>
<a href="l552"></a><span id="l552">  <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](replaceWith: scales.utils.package.ItemOrTree[Item,Section,CC]*)(implicit cbf: scales.utils.package.TreeCBF[Item,Section,CC])scales.utils.Replace[Item,Section,CC]" id="83985">apply</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="83989">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="83990">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="83991">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="84028">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="scales.utils.package.ItemOrTree[Item,Section,CC]*" id="84024">replaceWith</a>: <span title="scales.utils.package.ItemOrTree[Item,Section,CC]*">ItemOrTree</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>*<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scales.utils.package.TreeCBF[Item,Section,CC]" id="84025">cbf</a> : <span title="scales.utils.package.TreeCBF[Item,Section,CC]">TreeCBF</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#84025" title="scales.utils.Replace[Item,Section,CC]" class="keyword">new</a> <a href="#84234" title="scales.utils.Replace[Item,Section,CC]">Replace</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">(</span><a href="#84024" title="scales.utils.package.ItemOrTree[Item,Section,CC]*">replaceWith</a><span class="delimiter">)</span></span>
<a href="l553"></a><span id="l553"></span>
<a href="l554"></a><span id="l554"><span class="delimiter">}</span></span>
<a href="l555"></a><span id="l555"></span>
<a href="l556"></a><span id="l556"><span class="comment">/**</span>
<a href="l557"></a><span id="l557"> * Allows replacing one path with many, may be easier to use the * version however</span>
<a href="l558"></a><span id="l558"> */</span></span>
<a href="l559"></a><span id="l559">case <span class="keyword">class</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](x$0: scales.utils.Replace[Item,Section,CC])Option[Iterable[scales.utils.package.ItemOrTree[Item,Section,CC]]]" id="84234">Replace</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="84194">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="84195">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="84196">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="84216">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><a href="#84234" title="ScalaObject" class="delimiter">(</a><a title="Iterable[scales.utils.package.ItemOrTree[Item,Section,CC]]" id="84190">replaceWith</a>: <span title="Iterable[scales.utils.package.ItemOrTree[Item,Section,CC]]">Iterable</span><span class="delimiter">[</span>ItemOrTree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scales.utils.package.TreeCBF[Item,Section,CC]" id="84197">cbf</a> : <span title="scales.utils.package.TreeCBF[Item,Section,CC]">TreeCBF</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#10539" title="scales.utils.FoldOperation[Item,Section,CC]">FoldOperation</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> <span class="delimiter">{</span></span>
<a href="l560"></a><span id="l560"></span>
<a href="l561"></a><span id="l561">  <span class="comment">/**</span>
<a href="l562"></a><span id="l562">   * clean below for any that are invalidated by the replace then replaceWiths size minus the 1 that we have removed/replaced</span>
<a href="l563"></a><span id="l563">   */</span></span>
<a href="l564"></a><span id="l564">  <span class="keyword">def</span> <a title="(positions: Seq[scales.utils.Position[Item,Section,CC]])Seq[scales.utils.Position[Item,Section,CC]]" id="84005">adjust</a><span class="delimiter">(</span><a title="Seq[scales.utils.Position[Item,Section,CC]]" id="84075">positions</a>: <span title="Seq[scales.utils.Position[Item,Section,CC]]">Seq</span><span class="delimiter">[</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Seq[scales.utils.Position[Item,Section,CC]]">Seq</span><span class="delimiter">[</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#12236" title="(positions: Seq[scales.utils.Position[Item,Section,CC]])Seq[scales.utils.Position[Item,Section,CC]]">cleanBelow</a><span class="delimiter">(</span><a href="#84075" title="Seq[scales.utils.Position[Item,Section,CC]]">positions</a><span class="delimiter">)</span>.<span title="(f: scales.utils.Position[Item,Section,CC] =&gt; scales.utils.Position[Item,Section,CC])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[scales.utils.Position[Item,Section,CC]],scales.utils.Position[Item,Section,CC],Seq[scales.utils.Position[Item,Section,CC]]])Seq[scales.utils.Position[Item,Section,CC]]">map</span> <span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,scales.utils.Position[Item,Section,CC],Seq[scales.utils.Position[Item,Section,CC]]]" class="delimiter">{</span> <a href="#12229" title="(base: scales.utils.Position[Item,Section,CC], x: scales.utils.Position[Item,Section,CC], by: Int)scales.utils.Position[Item,Section,CC]">shiftWithBase</a><span class="delimiter">(</span><a href="#84075" title="Seq[scales.utils.Position[Item,Section,CC]]">positions</a>.<span title="=&gt; scales.utils.Position[Item,Section,CC]">head</span>, <a href="#84132" title="scales.utils.Position[Item,Section,CC]">_</a>, <a href="#84190" title="=&gt; Iterable[scales.utils.package.ItemOrTree[Item,Section,CC]]">replaceWith</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span class="delimiter">}</span></span>
<a href="l565"></a><span id="l565"></span>
<a href="l566"></a><span id="l566">  <span class="keyword">def</span> <a title="(path: scales.utils.Path[Item,Section,CC])scales.utils.package.FoldR[Item,Section,CC]" id="84006">perform</a><span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC]" id="84173">path</a>: <a href="#84591" title="scales.utils.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scales.utils.package.FoldR[Item,Section,CC]">FoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> = <span class="delimiter">{</span></span>
<a href="l567"></a><span id="l567">    <span class="comment">// modify with tail</span></span>
<a href="l568"></a><span id="l568">    <span class="keyword">val</span> <a title="scales.utils.Path[Item,Section,CC]" id="84176">tpath</a> = <a href="#84173" title="scales.utils.Path[Item,Section,CC]">path</a>.<a href="#39616" title="(newFocus: scales.utils.package.ItemOrTree[Item,Section,CC] =&gt; scales.utils.package.ItemOrTree[Item,Section,CC])scales.utils.Path[Item,Section,CC]">modify</a><span class="delimiter">(</span><a title="scales.utils.package.ItemOrTree[Item,Section,CC]" id="84179">_</a> =&gt; <a href="#84190" title="=&gt; Iterable[scales.utils.package.ItemOrTree[Item,Section,CC]]">replaceWith</a>.<span title="=&gt; scales.utils.package.ItemOrTree[Item,Section,CC]">head</span><span class="delimiter">)</span></span>
<a href="l569"></a><span id="l569">    <a href="#80077" title="(path: scales.utils.Path[Item,Section,CC], direction: Int, newPath: Iterable[scales.utils.package.ItemOrTree[Item,Section,CC]])(implicit cbf: scales.utils.package.TreeCBF[Item,Section,CC])scales.utils.package.FoldR[Item,Section,CC]">add</a><a href="#84197" title="scales.utils.package.TreeCBF[Item,Section,CC]" class="delimiter">(</a><a href="#84176" title="scales.utils.Path[Item,Section,CC]">tpath</a>, <span title="Int(1)" class="int">1</span>, <a href="#84190" title="=&gt; Iterable[scales.utils.package.ItemOrTree[Item,Section,CC]]">replaceWith</a>.<span title="=&gt; Iterable[scales.utils.package.ItemOrTree[Item,Section,CC]]">tail</span><span class="delimiter">)</span></span>
<a href="l570"></a><span id="l570">  <span class="delimiter">}</span></span>
<a href="l571"></a><span id="l571"><span class="delimiter">}</span></span>
<a href="l572"></a><span id="l572"></span>
<a href="l573"></a><span id="l573"><span class="comment">/**</span>
<a href="l574"></a><span id="l574"> * Allows foldPositions to be nested, only replace makes sense here (afaict)</span>
<a href="l575"></a><span id="l575"> */</span></span>
<a href="l576"></a><span id="l576">case <span class="keyword">class</span> <a title="class ReplaceWith[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]] extends java.lang.Object with scales.utils.FoldOperation[Item,Section,CC] with ScalaObject with Product with Serializable" id="84542">ReplaceWith</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="84436">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="84437">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="84438">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="84536">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><a href="#84542" title="ScalaObject" class="delimiter">(</a><a title="scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]" id="84534">f</a>: <span title="scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]">PathFoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scales.utils.package.TreeCBF[Item,Section,CC]" id="84535">cbf</a> : <span title="scales.utils.package.TreeCBF[Item,Section,CC]">TreeCBF</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#10539" title="scales.utils.FoldOperation[Item,Section,CC]">FoldOperation</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> <span class="delimiter">{</span></span>
<a href="l577"></a><span id="l577"></span>
<a href="l578"></a><span id="l578">  <span class="keyword">def</span> <a title="(positions: Seq[scales.utils.Position[Item,Section,CC]])Seq[scales.utils.Position[Item,Section,CC]]" id="84242">adjust</a><span class="delimiter">(</span><a title="Seq[scales.utils.Position[Item,Section,CC]]" id="84257">positions</a>: <span title="Seq[scales.utils.Position[Item,Section,CC]]">Seq</span><span class="delimiter">[</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Seq[scales.utils.Position[Item,Section,CC]]">Seq</span><span class="delimiter">[</span>Position<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#12236" title="(positions: Seq[scales.utils.Position[Item,Section,CC]])Seq[scales.utils.Position[Item,Section,CC]]">cleanBelow</a><span class="delimiter">(</span><a href="#84257" title="Seq[scales.utils.Position[Item,Section,CC]]">positions</a><span class="delimiter">)</span>.<span title="(f: scales.utils.Position[Item,Section,CC] =&gt; scales.utils.Position[Item,Section,CC])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[scales.utils.Position[Item,Section,CC]],scales.utils.Position[Item,Section,CC],Seq[scales.utils.Position[Item,Section,CC]]])Seq[scales.utils.Position[Item,Section,CC]]">map</span> <span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,scales.utils.Position[Item,Section,CC],Seq[scales.utils.Position[Item,Section,CC]]]" class="delimiter">{</span> <a href="#12229" title="(base: scales.utils.Position[Item,Section,CC], x: scales.utils.Position[Item,Section,CC], by: Int)scales.utils.Position[Item,Section,CC]">shiftWithBase</a><span class="delimiter">(</span><a href="#84257" title="Seq[scales.utils.Position[Item,Section,CC]]">positions</a>.<span title="=&gt; scales.utils.Position[Item,Section,CC]">head</span>, <a href="#84314" title="scales.utils.Position[Item,Section,CC]">_</a>, <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span class="delimiter">}</span></span>
<a href="l579"></a><span id="l579"></span>
<a href="l580"></a><span id="l580">  <span class="keyword">def</span> <a title="(path: scales.utils.Path[Item,Section,CC])scales.utils.package.FoldR[Item,Section,CC]" id="84243">perform</a><span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC]" id="84351">path</a>: <a href="#84591" title="scales.utils.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scales.utils.package.FoldR[Item,Section,CC]">FoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> =</span>
<a href="l581"></a><span id="l581">    <span class="comment">// modify back in (allows changes), or pass on the error</span></span>
<a href="l582"></a><span id="l582">    <a href="#84534" title="(v1: scales.utils.Path[Item,Section,CC])scales.utils.package.FoldR[Item,Section,CC]">f</a><span class="delimiter">(</span><a href="#84351" title="scales.utils.Path[Item,Section,CC]">path</a><span class="delimiter">)</span>.<span title="(fa: scales.utils.Path[Item,Section,CC] =&gt; Product with Serializable with Either[scales.utils.Path[Item,Section,CC],scales.utils.FoldError], fb: scales.utils.FoldError =&gt; Product with Serializable with Either[scales.utils.Path[Item,Section,CC],scales.utils.FoldError])Product with Serializable with Either[scales.utils.Path[Item,Section,CC],scales.utils.FoldError]">fold</span><span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC]" id="84361">fres</a> =&gt; <span title="(a: scales.utils.Path[Item,Section,CC])Left[scales.utils.Path[Item,Section,CC],Nothing]">Left</span><span class="delimiter">(</span><a href="#84351" title="scales.utils.Path[Item,Section,CC]">path</a>.<a href="#39616" title="(newFocus: scales.utils.package.ItemOrTree[Item,Section,CC] =&gt; scales.utils.package.ItemOrTree[Item,Section,CC])scales.utils.Path[Item,Section,CC]">modify</a><span class="delimiter">(</span><a title="scales.utils.package.ItemOrTree[Item,Section,CC]" id="84373">_</a> =&gt; <a href="#84361" title="scales.utils.Path[Item,Section,CC]">fres</a>.<a href="#39608" title="()scales.utils.Tree[Item,Section,CC]">tree</a><span class="delimiter">)</span><span class="delimiter">)</span>,<span class="comment">//Right(fres.tree))),</span></span>
<a href="l583"></a><span id="l583">      <span title="(b: scales.utils.FoldError)Right[Nothing,scales.utils.FoldError]">Right</span><span class="delimiter">(</span><a href="#84376" title="scales.utils.FoldError">_</a><span class="delimiter">)</span><span class="delimiter">)</span></span>
<a href="l584"></a><span id="l584"></span>
<a href="l585"></a><span id="l585"><span class="delimiter">}</span></span>
<a href="l586"></a><span id="l586"></span>
<a href="l587"></a><span id="l587"><span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait FoldError extends java.lang.Object" id="10579">FoldError</a></span>
<a href="l588"></a><span id="l588"></span>
<a href="l589"></a><span id="l589">case <span class="keyword">object</span> <a href="#84487" title="object scales.utils.NoPaths" id="84492">NoPaths</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#10579" title="scales.utils.FoldError">FoldError</a></span>
<a href="l590"></a><span id="l590">case <span class="keyword">object</span> <a href="#84499" title="object scales.utils.NoSingleRoot" id="84504">NoSingleRoot</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#10579" title="scales.utils.FoldError">FoldError</a></span>
<a href="l591"></a><span id="l591">case <span class="keyword">object</span> <a href="#84511" title="object scales.utils.RemovedRoot" id="84516">RemovedRoot</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#10579" title="scales.utils.FoldError">FoldError</a></span>
<a href="l592"></a><span id="l592">case <span class="keyword">object</span> <a href="#84523" title="object scales.utils.AddedBeforeOrAfterRoot" id="84528">AddedBeforeOrAfterRoot</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#10579" title="scales.utils.FoldError">FoldError</a></span>
<a href="l593"></a><span id="l593"></span>
<a href="l594"></a><span id="l594">        </span>
</pre>
    </body>
</html>