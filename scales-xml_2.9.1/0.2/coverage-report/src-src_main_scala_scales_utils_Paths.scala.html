<table class="classes"><tbody><tr>
      <td class="barContainerLeft"><a href="#">&#x200B;scales/&#x200B;utils/<span class="header">&#x200B;Paths.scala</span></a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">86 %</div>
        <div class="greenBar" style="width:172px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_Paths.scala.html#Class_scales_utils_AddAfter"><img src="class.png"></img>AddAfter</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_Paths.scala.html#Class_scales_utils_AddBefore"><img src="class.png"></img>AddBefore</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_Paths.scala.html#Object_scales_utils_AddedBeforeOrAfterRoot"><img src="object.png"></img>AddedBeforeOrAfterRoot</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_Paths.scala.html#Class_scales_utils_AsIs"><img src="class.png"></img>AsIs</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_Paths.scala.html#Trait_scales_utils_FoldError"><img src="trait.png"></img>FoldError</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_Paths.scala.html#Trait_scales_utils_FoldOperation"><img src="trait.png"></img>FoldOperation</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">90 %</div>
        <div class="greenBar" style="width:180px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_Paths.scala.html#Object_scales_utils_NoPaths"><img src="object.png"></img>NoPaths</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_Paths.scala.html#Object_scales_utils_NoSingleRoot"><img src="object.png"></img>NoSingleRoot</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_Paths.scala.html#Class_scales_utils_Node"><img src="class.png"></img>Node</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_Paths.scala.html#Class_scales_utils_Path"><img src="class.png"></img>Path</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">80 %</div>
        <div class="greenBar" style="width:160px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_Paths.scala.html#Class_scales_utils_Path_ItemIterator"><img src="class.png"></img>Path.ItemIterator</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">66 %</div>
        <div class="greenBar" style="width:132px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_Paths.scala.html#Class_scales_utils_Path_TreeIterator"><img src="class.png"></img>Path.TreeIterator</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_Paths.scala.html#Class_scales_utils_PathImplicits"><img src="class.png"></img>PathImplicits</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_Paths.scala.html#Trait_scales_utils_PathImplicits"><img src="trait.png"></img>PathImplicits</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_Paths.scala.html#Class_scales_utils_Paths"><img src="class.png"></img>Paths</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_Paths.scala.html#Trait_scales_utils_Paths"><img src="trait.png"></img>Paths</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">86 %</div>
        <div class="greenBar" style="width:172px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_Paths.scala.html#Trait_scales_utils_Position"><img src="trait.png"></img>Position</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_Paths.scala.html#Class_scales_utils_PositionImpl"><img src="class.png"></img>PositionImpl</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_Paths.scala.html#Class_scales_utils_Remove"><img src="class.png"></img>Remove</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">85 %</div>
        <div class="greenBar" style="width:170px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_Paths.scala.html#Object_scales_utils_RemovedRoot"><img src="object.png"></img>RemovedRoot</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_Paths.scala.html#Class_scales_utils_Replace"><img src="class.png"></img>Replace</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_Paths.scala.html#Object_scales_utils_Replace"><img src="object.png"></img>Replace</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_Paths.scala.html#Class_scales_utils_ReplaceWith"><img src="class.png"></img>ReplaceWith</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">85 %</div>
        <div class="greenBar" style="width:170px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_utils_Paths.scala.html#Class_scales_utils_Top"><img src="class.png"></img>Top</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr></tbody></table><table class="source"><tbody><tr>
            <td class="black">1</td>
            <td>package scales.utils
</td>
          </tr><tr>
            <td class="black">2</td>
            <td>
</td>
          </tr><tr>
            <td class="black">3</td>
            <td>import scales.utils._
</td>
          </tr><tr>
            <td class="black">4</td>
            <td>
</td>
          </tr><tr>
            <td class="black">5</td>
            <td>import scala.collection.immutable.Stack
</td>
          </tr><tr>
            <td class="black">6</td>
            <td>import scala.collection.IndexedSeqLike
</td>
          </tr><tr>
            <td class="black">7</td>
            <td>import scala.collection.generic.CanBuildFrom
</td>
          </tr><tr>
            <td class="black">8</td>
            <td>
</td>
          </tr><tr>
            <td class="black">9</td>
            <td><a id="Trait_scales_utils_Paths"></a>trait Paths {
</td>
          </tr><tr>
            <td class="black">10</td>
            <td>  def noPath[Item &lt;: LeftLike[Item, Tree[Item, Section, CC]], Section, CC[X] &lt;: IndexedSeqLike[X, CC[X]]]
</td>
          </tr><tr>
            <td class="green">11</td>
            <td><a id="Class_scales_utils_Paths"></a>    (implicit cbf : TreeCBF[Item, Section, CC])  = new Path[Item, Section, CC](Top(), Node(-1, null.asInstanceOf[ItemOrTree[Item, Section, CC]])) {
</td>
          </tr><tr>
            <td class="black">12</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">13</td>
            <td>
</td>
          </tr><tr>
            <td class="black">14</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">15</td>
            <td><a id="Class_scales_utils_Replace"></a><a id="Class_scales_utils_AddBefore"></a><a id="Class_scales_utils_PositionImpl"></a><a id="Class_scales_utils_ReplaceWith"></a><a id="Class_scales_utils_Top"></a><a id="Class_scales_utils_Remove"></a><a id="Class_scales_utils_AsIs"></a><a id="Class_scales_utils_Node"></a><a id="Class_scales_utils_AddAfter"></a><a id="Class_scales_utils_Path"></a>   * Returns the root path for its input, uses zipUp to ensure changes are kept
</td>
          </tr><tr>
            <td class="black">16</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">17</td>
            <td>  def rootPath[Item &lt;: LeftLike[Item, Tree[Item, Section, CC]], Section, CC[X] &lt;: IndexedSeqLike[X, CC[X]]](path: Path[Item, Section, CC]): Path[Item, Section, CC] = {
</td>
          </tr><tr>
            <td class="green">18</td>
            <td>    var newPath = path
</td>
          </tr><tr>
            <td class="green">19</td>
            <td>    while (!newPath.top.isLeft)
</td>
          </tr><tr>
            <td class="green">20</td>
            <td>      newPath = newPath.zipUp
</td>
          </tr><tr>
            <td class="green">21</td>
            <td>    newPath
</td>
          </tr><tr>
            <td class="black">22</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">23</td>
            <td>
</td>
          </tr><tr>
            <td class="black">24</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">25</td>
            <td>   * Navigates the path until the new position is reached, throws if either its a new root or the position is not reachable
</td>
          </tr><tr>
            <td class="black">26</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">27</td>
            <td>  def moveTo[Item &lt;: LeftLike[Item, Tree[Item, Section, CC]], Section, CC[X] &lt;: IndexedSeqLike[X, CC[X]]](path: Path[Item, Section, CC], newPos: Position[Item, Section, CC])
</td>
          </tr><tr>
            <td class="black">28</td>
            <td>    (implicit cbf : TreeCBF[Item, Section, CC]) : Path[Item, Section, CC] = {
</td>
          </tr><tr>
            <td class="black">29</td>
            <td>
</td>
          </tr><tr>
            <td class="green">30</td>
            <td>    val root = rootPath(path)
</td>
          </tr><tr>
            <td class="black">31</td>
            <td>    // cheaty way, crap but quick enough
</td>
          </tr><tr>
            <td class="black">32</td>
            <td>    // TODO come back to this and properly move,
</td>
          </tr><tr>
            <td class="green">33</td>
            <td>    newPos.position.pop.foldLeft(root) { (path, pos) =&gt;
</td>
          </tr><tr>
            <td class="green">34</td>
            <td>      Path(path, Node(pos, path.children(pos)))
</td>
          </tr><tr>
            <td class="black">35</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">36</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">37</td>
            <td>
</td>
          </tr><tr>
            <td class="black">38</td>
            <td>  type FoldR[Item &lt;: LeftLike[Item, Tree[Item, Section, CC]], Section, CC[X] &lt;: IndexedSeqLike[X, CC[X]]] = Either[Path[Item, Section, CC], FoldError]
</td>
          </tr><tr>
            <td class="black">39</td>
            <td>
</td>
          </tr><tr>
            <td class="black">40</td>
            <td>  def shiftWithBase[Item &lt;: LeftLike[Item, Tree[Item, Section, CC]], Section, CC[X] &lt;: IndexedSeqLike[X, CC[X]]](base: Position[Item, Section, CC], x: Position[Item, Section, CC], by: Int): Position[Item, Section, CC] = {
</td>
          </tr><tr>
            <td class="green">41</td>
            <td>    val up = base.position.reverse.pop.reverse // stack needs to be flipped to get parent
</td>
          </tr><tr>
            <td class="green">42</td>
            <td>    if (sameBase(up, x.position)) {
</td>
          </tr><tr>
            <td class="green">43</td>
            <td>      val (above, below) = x.position.splitAt(up.size)
</td>
          </tr><tr>
            <td class="green">44</td>
            <td>      val oldv = below.top
</td>
          </tr><tr>
            <td class="green">45</td>
            <td>      val old = below.pop
</td>
          </tr><tr>
            <td class="green">46</td>
            <td>      val newpos = above ++ (old.push(oldv + by))
</td>
          </tr><tr>
            <td class="green">47</td>
            <td>      new PositionImpl[Item, Section, CC](
</td>
          </tr><tr>
            <td class="black">48</td>
            <td>        newpos,
</td>
          </tr><tr>
            <td class="black">49</td>
            <td>        x.root)
</td>
          </tr><tr>
            <td class="red">50</td>
            <td>    } else <span class="non">x
</span></td>
          </tr><tr>
            <td class="black">51</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">52</td>
            <td>
</td>
          </tr><tr>
            <td class="green">53</td>
            <td>  def cleanBelow[Item &lt;: LeftLike[Item, Tree[Item, Section, CC]], Section, CC[X] &lt;: IndexedSeqLike[X, CC[X]]](positions: Seq[Position[Item, Section, CC]]): Seq[Position[Item, Section, CC]] = positions.dropWhile { x =&gt;
</td>
          </tr><tr>
            <td class="green">54</td>
            <td>    sameBase(positions.head.position, x.position)
</td>
          </tr><tr>
            <td class="black">55</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">56</td>
            <td>
</td>
          </tr><tr>
            <td class="black">57</td>
            <td>  type PathFoldR[Item &lt;: LeftLike[Item, Tree[Item, Section, CC]], Section, CC[X] &lt;: IndexedSeqLike[X, CC[X]]] = (Path[Item, Section, CC]) =&gt; FoldR[Item, Section, CC]
</td>
          </tr><tr>
            <td class="black">58</td>
            <td>
</td>
          </tr><tr>
            <td class="black">59</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">60</td>
            <td>   * Folds over positions within a single path, for example all given children.  As such positions must be calculated.
</td>
          </tr><tr>
            <td class="black">61</td>
            <td>   *
</td>
          </tr><tr>
            <td class="black">62</td>
            <td>   * Takes the first root, returning Right(NoSingleRoot) if any of the subsequent roots don't match.
</td>
          </tr><tr>
            <td class="black">63</td>
            <td>   *
</td>
          </tr><tr>
            <td class="black">64</td>
            <td>   * folder retrieves the current path
</td>
          </tr><tr>
            <td class="black">65</td>
            <td>   *
</td>
          </tr><tr>
            <td class="black">66</td>
            <td>   * Each iteration folds the resulting tree back into the path. As this function must maintain the Path it does not expose the new path root until the result.
</td>
          </tr><tr>
            <td class="black">67</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">68</td>
            <td>  def foldPositions[Item &lt;: LeftLike[Item, Tree[Item, Section, CC]], Section, CC[X] &lt;: IndexedSeqLike[X, CC[X]], ACC](locations: Iterable[Path[Item, Section, CC]], accumulator: ACC)(folder: (ACC, Path[Item, Section, CC]) =&gt; (ACC, FoldOperation[Item, Section, CC])) (implicit cbf : TreeCBF[Item, Section, CC], cm : ClassManifest[(scales.utils.Position[Item,Section,CC], Path[Item, Section, CC])])  : Either[(ACC, Path[Item, Section, CC]), FoldError] = {
</td>
          </tr><tr>
            <td class="green">69</td>
            <td>    if (locations.isEmpty) return Right(NoPaths)
</td>
          </tr><tr>
            <td class="black">70</td>
            <td>
</td>
          </tr><tr>
            <td class="green">71</td>
            <td>    val sorted = sortPositions(locations)
</td>
          </tr><tr>
            <td class="black">72</td>
            <td>
</td>
          </tr><tr>
            <td class="green">73</td>
            <td>    val head = sorted.head
</td>
          </tr><tr>
            <td class="green">74</td>
            <td>    var accum = accumulator
</td>
          </tr><tr>
            <td class="black">75</td>
            <td>
</td>
          </tr><tr>
            <td class="green">76</td>
            <td>    val rootPosition = head._1
</td>
          </tr><tr>
            <td class="green">77</td>
            <td>    val differentRoot = sorted.exists(p =&gt; p._1.root ne rootPosition.root)
</td>
          </tr><tr>
            <td class="green">78</td>
            <td>    if (differentRoot)
</td>
          </tr><tr>
            <td class="red">79</td>
            <td>      <span class="non">Right(NoSingleRoot)
</span></td>
          </tr><tr>
            <td class="black">80</td>
            <td>    else {
</td>
          </tr><tr>
            <td class="black">81</td>
            <td>
</td>
          </tr><tr>
            <td class="black">82</td>
            <td>      // fold over positions, with the path from head, let each foldop decide what the next position sequence looks like
</td>
          </tr><tr>
            <td class="green">83</td>
            <td>      var positions = sorted.map(_._1).toSeq
</td>
          </tr><tr>
            <td class="green">84</td>
            <td>      var path = head._2
</td>
          </tr><tr>
            <td class="green">85</td>
            <td>      while (!positions.isEmpty) {
</td>
          </tr><tr>
            <td class="black">86</td>
            <td>
</td>
          </tr><tr>
            <td class="green">87</td>
            <td>        val (accf, res) = folder(accum, path)
</td>
          </tr><tr>
            <td class="green">88</td>
            <td>        accum = accf
</td>
          </tr><tr>
            <td class="green">89</td>
            <td>        val matched = res.perform(path) //matchIt( res, path )
</td>
          </tr><tr>
            <td class="black">90</td>
            <td>
</td>
          </tr><tr>
            <td class="green">91</td>
            <td>        if (matched.isLeft) {
</td>
          </tr><tr>
            <td class="green">92</td>
            <td>          path = matched.left.get
</td>
          </tr><tr>
            <td class="green">93</td>
            <td>          positions = res.adjust(positions)
</td>
          </tr><tr>
            <td class="green">94</td>
            <td>          if (!positions.isEmpty) {
</td>
          </tr><tr>
            <td class="green">95</td>
            <td>            path = moveTo(path, positions.head) // else nothing we keep path to call root
</td>
          </tr><tr>
            <td class="black">96</td>
            <td>          }
</td>
          </tr><tr>
            <td class="red">97</td>
            <td>        } else <span class="non">return Right(matched.right.get)
</span></td>
          </tr><tr>
            <td class="black">98</td>
            <td>      }
</td>
          </tr><tr>
            <td class="green">99</td>
            <td>      Left((accum, rootPath(path)))
</td>
          </tr><tr>
            <td class="black">100</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">101</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">102</td>
            <td>
</td>
          </tr><tr>
            <td class="black">103</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">104</td>
            <td>   * Folds over positions within a single path, for example all given children.  As such positions must be calculated.
</td>
          </tr><tr>
            <td class="black">105</td>
            <td>   *
</td>
          </tr><tr>
            <td class="black">106</td>
            <td>   * Takes the first root, returning Right(NoSingleRoot) if any of the subsequent roots don't match.
</td>
          </tr><tr>
            <td class="black">107</td>
            <td>   *
</td>
          </tr><tr>
            <td class="black">108</td>
            <td>   * folder retrieves the current path
</td>
          </tr><tr>
            <td class="black">109</td>
            <td>   *
</td>
          </tr><tr>
            <td class="black">110</td>
            <td>   * Each iteration folds the resulting tree back into the path. As this function must maintain the Path it does not expose the new path root until the result.
</td>
          </tr><tr>
            <td class="black">111</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">112</td>
            <td>  def foldPositions[Item &lt;: LeftLike[Item, Tree[Item, Section, CC]], Section, CC[X] &lt;: IndexedSeqLike[X, CC[X]]](locations: Iterable[Path[Item, Section, CC]])(folder: (Path[Item, Section, CC]) =&gt; FoldOperation[Item, Section, CC])(implicit cbf : TreeCBF[Item, Section, CC], cm : ClassManifest[(scales.utils.Position[Item,Section,CC], Path[Item, Section, CC])]) : FoldR[Item, Section, CC] =
</td>
          </tr><tr>
            <td class="green">113</td>
            <td>    foldPositions[Item, Section, CC, Unit](locations, ())((u, p) =&gt; ((), folder(p))).
</td>
          </tr><tr>
            <td class="green">114</td>
            <td>      fold(x =&gt; Left(x._2), Right(_))
</td>
          </tr><tr>
            <td class="black">115</td>
            <td>
</td>
          </tr><tr>
            <td class="green">116</td>
            <td>  val NotSameRoot = 1000
</td>
          </tr><tr>
            <td class="black">117</td>
            <td>
</td>
          </tr><tr>
            <td class="black">118</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">119</td>
            <td>   * When paths are not in the same root, they are compared based on the identity hash of the given roots.  Of course this relies on that function
</td>
          </tr><tr>
            <td class="black">120</td>
            <td>   * having a decent vm implementation.
</td>
          </tr><tr>
            <td class="black">121</td>
            <td>   *
</td>
          </tr><tr>
            <td class="black">122</td>
            <td>   * @param path1
</td>
          </tr><tr>
            <td class="black">123</td>
            <td>   * @param path2
</td>
          </tr><tr>
            <td class="black">124</td>
            <td>   * @return 1 if path1 is before path2, -1 if path2 is before path1, 0 if they are the same and NotSameRoot+-1 if they are not in the same root
</td>
          </tr><tr>
            <td class="black">125</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">126</td>
            <td>  def comparePathPositions[Item &lt;: LeftLike[Item, Tree[Item, Section, CC]], Section, CC[X] &lt;: IndexedSeqLike[X, CC[X]]](path1: Position[Item, Section, CC], path2: Position[Item, Section, CC]): Int = {
</td>
          </tr><tr>
            <td class="black">127</td>
            <td>
</td>
          </tr><tr>
            <td class="yellow">128</td>
            <td>    if (path1 eq path2) <span class="non">0
</span></td>
          </tr><tr>
            <td class="black">129</td>
            <td>    else {
</td>
          </tr><tr>
            <td class="green">130</td>
            <td>      if (path1.root ne path2.root) {
</td>
          </tr><tr>
            <td class="red">131</td>
            <td>        val p1R = <span class="non">System.identityHashCode(path1.root)
</span></td>
          </tr><tr>
            <td class="red">132</td>
            <td>        val p2R = <span class="non">System.identityHashCode(path2.root)
</span></td>
          </tr><tr>
            <td class="red">133</td>
            <td>        <span class="non">NotSameRoot + (if (p1R &lt; p2R) 1 else -1)
</span></td>
          </tr><tr>
            <td class="black">134</td>
            <td>      } else
</td>
          </tr><tr>
            <td class="green">135</td>
            <td>        compareStack(path1.position, path2.position)
</td>
          </tr><tr>
            <td class="black">136</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">137</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">138</td>
            <td>
</td>
          </tr><tr>
            <td class="black">139</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">140</td>
            <td>   * When paths are not in the same root, they are compared based on the identity hash of the given roots.  Of course this relies on that function
</td>
          </tr><tr>
            <td class="black">141</td>
            <td>   * having a decent vm implementation. See http://www.w3.org/TR/2007/REC-xpath20-20070123/#dt-document-order, tree order must remain constant.  Its
</td>
          </tr><tr>
            <td class="black">142</td>
            <td>   * also a pretty sensible approach for non xml trees.
</td>
          </tr><tr>
            <td class="black">143</td>
            <td>   *
</td>
          </tr><tr>
            <td class="black">144</td>
            <td>   * @param path1
</td>
          </tr><tr>
            <td class="black">145</td>
            <td>   * @param path2
</td>
          </tr><tr>
            <td class="black">146</td>
            <td>   * @return 1 if path1 is before path2, -1 if path2 is before path1, 0 if they are the same and NotSameRoot+-1 if they are not in the same root
</td>
          </tr><tr>
            <td class="black">147</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">148</td>
            <td>  def comparePaths[Item &lt;: LeftLike[Item, Tree[Item, Section, CC]], Section, CC[X] &lt;: IndexedSeqLike[X, CC[X]]](path1: Path[Item, Section, CC], path2: Path[Item, Section, CC]): (Int, Position[Item, Section, CC], Position[Item, Section, CC]) =
</td>
          </tr><tr>
            <td class="red">149</td>
            <td>    <span class="non">comparePaths((path1.position, path1), (path2.position, path2))
</span></td>
          </tr><tr>
            <td class="black">150</td>
            <td>
</td>
          </tr><tr>
            <td class="black">151</td>
            <td>  def comparePaths[Item &lt;: LeftLike[Item, Tree[Item, Section, CC]], Section, CC[X] &lt;: IndexedSeqLike[X, CC[X]]](path1: (Position[Item, Section, CC], Path[Item, Section, CC]), path2: (Position[Item, Section, CC], Path[Item, Section, CC])): (Int, Position[Item, Section, CC], Position[Item, Section, CC]) = {
</td>
          </tr><tr>
            <td class="green">152</td>
            <td>    if (path1._2 eq path2._2) {
</td>
          </tr><tr>
            <td class="green">153</td>
            <td>      val pos = path1._1
</td>
          </tr><tr>
            <td class="green">154</td>
            <td>      (0, pos, pos)
</td>
          </tr><tr>
            <td class="black">155</td>
            <td>    } else {
</td>
          </tr><tr>
            <td class="green">156</td>
            <td>      val (pos1, pos2) = (path1._1, path2._1)
</td>
          </tr><tr>
            <td class="green">157</td>
            <td>      (comparePathPositions(pos1, pos2), pos1, pos2)
</td>
          </tr><tr>
            <td class="black">158</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">159</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">160</td>
            <td>
</td>
          </tr><tr>
            <td class="black">161</td>
            <td>  def comparePathsT[Item &lt;: LeftLike[Item, Tree[Item, Section, CC]], Section, CC[X] &lt;: IndexedSeqLike[X, CC[X]], T](path1: (Position[Item, Section, CC], (T, Path[Item, Section, CC])), path2: (Position[Item, Section, CC], (T, Path[Item, Section, CC]))): (Int, Position[Item, Section, CC], Position[Item, Section, CC]) = {
</td>
          </tr><tr>
            <td class="green">162</td>
            <td>    if (path1._2._2 eq path2._2._2) {
</td>
          </tr><tr>
            <td class="green">163</td>
            <td>      val pos = path1._1
</td>
          </tr><tr>
            <td class="green">164</td>
            <td>      (0, pos, pos)
</td>
          </tr><tr>
            <td class="black">165</td>
            <td>    } else {
</td>
          </tr><tr>
            <td class="green">166</td>
            <td>      val (pos1, pos2) = (path1._1, path2._1)
</td>
          </tr><tr>
            <td class="green">167</td>
            <td>      (comparePathPositions(pos1, pos2), pos1, pos2)
</td>
          </tr><tr>
            <td class="black">168</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">169</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">170</td>
            <td>
</td>
          </tr><tr>
            <td class="black">171</td>
            <td>  def top[Item &lt;: LeftLike[Item, Tree[Item, Section, CC]], Section, CC[X] &lt;: IndexedSeqLike[X, CC[X]]](tree: Tree[Item, Section, CC])
</td>
          </tr><tr>
            <td class="black">172</td>
            <td>    (implicit cbf : TreeCBF[Item, Section, CC]) : Path[Item, Section, CC] =
</td>
          </tr><tr>
            <td class="green">173</td>
            <td>    Path(Top(), Node(0, tree))//Right(tree)))
</td>
          </tr><tr>
            <td class="black">174</td>
            <td>
</td>
          </tr><tr>
            <td class="black">175</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">176</td>
            <td>   * positions with tuples (T, Path)
</td>
          </tr><tr>
            <td class="black">177</td>
            <td>   */ 
</td>
          </tr><tr>
            <td class="black">178</td>
            <td>  def positionsT[Item &lt;: LeftLike[Item, Tree[Item, Section, CC]], Section, CC[X] &lt;: IndexedSeqLike[X, CC[X]], T](paths: Iterable[(T, Path[Item, Section, CC])]): Iterable[(Position[Item, Section, CC], (T,Path[Item, Section, CC]))] =
</td>
          </tr><tr>
            <td class="green">179</td>
            <td>    paths.map(x =&gt; (x._2.position, x))
</td>
          </tr><tr>
            <td class="black">180</td>
            <td>
</td>
          </tr><tr>
            <td class="black">181</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">182</td>
            <td>   * Obtain the positions for the paths
</td>
          </tr><tr>
            <td class="black">183</td>
            <td>   */ 
</td>
          </tr><tr>
            <td class="black">184</td>
            <td>  def positions[Item &lt;: LeftLike[Item, Tree[Item, Section, CC]], Section, CC[X] &lt;: IndexedSeqLike[X, CC[X]]](paths: Iterable[Path[Item, Section, CC]]): Iterable[(Position[Item, Section, CC], Path[Item, Section, CC])] =
</td>
          </tr><tr>
            <td class="green">185</td>
            <td>    paths.map(x =&gt; (x.position, x))
</td>
          </tr><tr>
            <td class="black">186</td>
            <td>
</td>
          </tr><tr>
            <td class="black">187</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">188</td>
            <td>   * sortPositions with a  tuple T, Path
</td>
          </tr><tr>
            <td class="black">189</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">190</td>
            <td>  def sortPositionsT[Item &lt;: LeftLike[Item, Tree[Item, Section, CC]], Section, CC[X] &lt;: IndexedSeqLike[X, CC[X]], T](paths: Iterable[(T,Path[Item, Section, CC])],
</td>
          </tr><tr>
            <td class="black">191</td>
            <td>    isDescending: Boolean = true)(implicit cm : ClassManifest[(scales.utils.Position[Item,Section,CC], (T, Path[Item, Section, CC]))]): Iterable[(Position[Item, Section, CC], (T, Path[Item, Section, CC]))] =
</td>
          </tr><tr>
            <td class="black">192</td>
            <td>    // Have to force them anyway
</td>
          </tr><tr>
            <td class="green">193</td>
            <td>    scala.util.Sorting.stableSort(positionsT(paths).toSeq, (p1: (Position[Item, Section, CC], (T,Path[Item, Section, CC])), p2: (Position[Item, Section, CC], (T,Path[Item, Section, CC]))) =&gt; {
</td>
          </tr><tr>
            <td class="green">194</td>
            <td>      val (res, pos1, pos2) = comparePathsT(p1, p2) //compareFunction(p1, p2)
</td>
          </tr><tr>
            <td class="green">195</td>
            <td>      val order = (res == 1 || res == (NotSameRoot + 1))
</td>
          </tr><tr>
            <td class="yellow">196</td>
            <td>      if (isDescending) order else <span class="non">!order
</span></td>
          </tr><tr>
            <td class="black">197</td>
            <td>    })(cm)
</td>
          </tr><tr>
            <td class="black">198</td>
            <td>
</td>
          </tr><tr>
            <td class="black">199</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">200</td>
            <td>   * Sorts according to position of each path item, descending or descending based on a depth first then rightwise order.
</td>
          </tr><tr>
            <td class="black">201</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">202</td>
            <td>  def sortPositions[Item &lt;: LeftLike[Item, Tree[Item, Section, CC]], Section, CC[X] &lt;: IndexedSeqLike[X, CC[X]]](paths: Iterable[Path[Item, Section, CC]],
</td>
          </tr><tr>
            <td class="black">203</td>
            <td>    //      compareFunction : (Path[Item, Section], Path[Item, Section]) =&gt; Integer = comparePaths _, 
</td>
          </tr><tr>
            <td class="black">204</td>
            <td>    isDescending: Boolean = true)(implicit cm : ClassManifest[(scales.utils.Position[Item,Section,CC], Path[Item, Section, CC])]): Iterable[(Position[Item, Section, CC], Path[Item, Section, CC])] =
</td>
          </tr><tr>
            <td class="black">205</td>
            <td>
</td>
          </tr><tr>
            <td class="black">206</td>
            <td>    // Have to force them anyway
</td>
          </tr><tr>
            <td class="green">207</td>
            <td>    scala.util.Sorting.stableSort(positions(paths).toSeq, (p1: (Position[Item, Section, CC], Path[Item, Section, CC]), p2: (Position[Item, Section, CC], Path[Item, Section, CC])) =&gt; {
</td>
          </tr><tr>
            <td class="green">208</td>
            <td>      val (res, pos1, pos2) = comparePaths(p1, p2) //compareFunction(p1, p2)
</td>
          </tr><tr>
            <td class="green">209</td>
            <td>      val order = (res == 1 || res == (NotSameRoot + 1))
</td>
          </tr><tr>
            <td class="yellow">210</td>
            <td>      if (isDescending) order else <span class="non">!order
</span></td>
          </tr><tr>
            <td class="black">211</td>
            <td>    })(cm)
</td>
          </tr><tr>
            <td class="black">212</td>
            <td>   
</td>
          </tr><tr>
            <td class="black">213</td>
            <td>
</td>
          </tr><tr>
            <td class="black">214</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">215</td>
            <td>   * Sorts according to position of each path item, descending or descending based on a depth first then rightwise order.
</td>
          </tr><tr>
            <td class="black">216</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">217</td>
            <td>  def sort[Item &lt;: LeftLike[Item, Tree[Item, Section, CC]], Section, CC[X] &lt;: IndexedSeqLike[X, CC[X]]](paths: Iterable[Path[Item, Section, CC]],
</td>
          </tr><tr>
            <td class="green">218</td>
            <td>    isDescending: Boolean = true)(implicit cm : ClassManifest[(scales.utils.Position[Item,Section,CC], Path[Item, Section, CC])]): Iterable[Path[Item, Section, CC]] = sortPositions(paths, isDescending).map(x =&gt; x._2)
</td>
          </tr><tr>
            <td class="black">219</td>
            <td>
</td>
          </tr><tr>
            <td class="black">220</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">221</td>
            <td>   * sort with a tuple T, Path
</td>
          </tr><tr>
            <td class="black">222</td>
            <td>   */ 
</td>
          </tr><tr>
            <td class="black">223</td>
            <td>  def sortT[Item &lt;: LeftLike[Item, Tree[Item, Section, CC]], Section, CC[X] &lt;: IndexedSeqLike[X, CC[X]], T](paths: Iterable[(T,Path[Item, Section, CC])],
</td>
          </tr><tr>
            <td class="green">224</td>
            <td>    isDescending: Boolean = true)(implicit cm : ClassManifest[(scales.utils.Position[Item,Section,CC], (T, Path[Item, Section, CC]))]): Iterable[(T,Path[Item, Section, CC])] = sortPositionsT(paths, isDescending).map(x =&gt; x._2)
</td>
          </tr><tr>
            <td class="black">225</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">226</td>
            <td>
</td>
          </tr><tr>
            <td class="black">227</td>
            <td><a id="Trait_scales_utils_PathImplicits"></a>trait PathImplicits {
</td>
          </tr><tr>
            <td class="black">228</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">229</td>
            <td>   * Provide &amp; combinator to pass the result of one fold onto the other,
</td>
          </tr><tr>
            <td class="black">230</td>
            <td>   * in the case of failure no further joined functions will be called.
</td>
          </tr><tr>
            <td class="black">231</td>
            <td>   *
</td>
          </tr><tr>
            <td class="black">232</td>
            <td>   * And provides | which allows NoPaths failures, allowing the use site to decide
</td>
          </tr><tr>
            <td class="black">233</td>
            <td>   * how to combine
</td>
          </tr><tr>
            <td class="black">234</td>
            <td>   */
</td>
          </tr><tr>
            <td class="green">235</td>
            <td><a id="Class_scales_utils_PathImplicits"></a>  implicit def fToFoldRToCombine[Item &lt;: LeftLike[Item, Tree[Item, Section, CC]], Section, CC[X] &lt;: IndexedSeqLike[X, CC[X]]](f: PathFoldR[Item, Section, CC]) = new {
</td>
          </tr><tr>
            <td class="black">236</td>
            <td>    private[this] def onSuccess(next: PathFoldR[Item, Section, CC], orOnFail: (Path[Item, Section, CC], FoldError) =&gt; FoldR[Item, Section, CC] = (a, b) =&gt; Right(b)): PathFoldR[Item, Section, CC] =
</td>
          </tr><tr>
            <td class="black">237</td>
            <td>      (path: Path[Item, Section, CC]) =&gt;
</td>
          </tr><tr>
            <td class="black">238</td>
            <td>        // modify back in (allows changes), or pass on the error
</td>
          </tr><tr>
            <td class="black">239</td>
            <td>        f(path).fold(fres =&gt;
</td>
          </tr><tr>
            <td class="black">240</td>
            <td>          next(path.modify(_ =&gt; fres.tree)),//Right(fres.tree))),
</td>
          </tr><tr>
            <td class="black">241</td>
            <td>          orOnFail(path, _))
</td>
          </tr><tr>
            <td class="black">242</td>
            <td>
</td>
          </tr><tr>
            <td class="black">243</td>
            <td>    def &amp;(next: PathFoldR[Item, Section, CC]): PathFoldR[Item, Section, CC] =
</td>
          </tr><tr>
            <td class="black">244</td>
            <td>      onSuccess(next)
</td>
          </tr><tr>
            <td class="black">245</td>
            <td>
</td>
          </tr><tr>
            <td class="black">246</td>
            <td>    def |(next: PathFoldR[Item, Section, CC]): PathFoldR[Item, Section, CC] =
</td>
          </tr><tr>
            <td class="black">247</td>
            <td>      onSuccess(next, orOnFail = (path, res) =&gt;
</td>
          </tr><tr>
            <td class="black">248</td>
            <td>        if (res eq NoPaths)
</td>
          </tr><tr>
            <td class="black">249</td>
            <td>          next(path)
</td>
          </tr><tr>
            <td class="black">250</td>
            <td>        else
</td>
          </tr><tr>
            <td class="black">251</td>
            <td>          Right(res))
</td>
          </tr><tr>
            <td class="black">252</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">253</td>
            <td>
</td>
          </tr><tr>
            <td class="black">254</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">255</td>
            <td>
</td>
          </tr><tr>
            <td class="green">256</td>
            <td>case class Top[Item &lt;: LeftLike[Item, Tree[Item, Section, CC]], Section, CC[X] &lt;: IndexedSeqLike[X, CC[X]]]() extends LeftLike[Top[Item, Section, CC], Path[Item, Section, CC]] 
</td>
          </tr><tr>
            <td class="black">257</td>
            <td>
</td>
          </tr><tr>
            <td class="black">258</td>
            <td>
</td>
          </tr><tr>
            <td class="black">259</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">260</td>
            <td> * Positions only have meaning for a given Path(s).
</td>
          </tr><tr>
            <td class="black">261</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">262</td>
            <td> * Their internal representation may change, as such its private to Paths.
</td>
          </tr><tr>
            <td class="black">263</td>
            <td> * r   * @author Chris
</td>
          </tr><tr>
            <td class="black">264</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">265</td>
            <td> */
</td>
          </tr><tr>
            <td class="black">266</td>
            <td><a id="Trait_scales_utils_Position"></a>trait Position[Item &lt;: LeftLike[Item, Tree[Item, Section, CC]], Section, CC[X] &lt;: IndexedSeqLike[X, CC[X]]] {
</td>
          </tr><tr>
            <td class="black">267</td>
            <td>  private[utils] val root: Path[Item, Section, CC]
</td>
          </tr><tr>
            <td class="black">268</td>
            <td>  private[utils] val position: Stack[Int]
</td>
          </tr><tr>
            <td class="black">269</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">270</td>
            <td>
</td>
          </tr><tr>
            <td class="green">271</td>
            <td>private[utils] case class PositionImpl[Item &lt;: LeftLike[Item, Tree[Item, Section, CC]], Section, CC[X] &lt;: IndexedSeqLike[X, CC[X]]](val position: Stack[Int], val root: Path[Item, Section, CC]) extends Position[Item, Section, CC]
</td>
          </tr><tr>
            <td class="black">272</td>
            <td>
</td>
          </tr><tr>
            <td class="black">273</td>
            <td>//import scala.collection.GenTraversable
</td>
          </tr><tr>
            <td class="black">274</td>
            <td>
</td>
          </tr><tr>
            <td class="black">275</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">276</td>
            <td> * Vectors are used due to big O considerations,
</td>
          </tr><tr>
            <td class="black">277</td>
            <td> * List looks ok until appendChild or previousSibling are called.  There may be a better
</td>
          </tr><tr>
            <td class="black">278</td>
            <td> * choice out there though....
</td>
          </tr><tr>
            <td class="black">279</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">280</td>
            <td> * @author Chris
</td>
          </tr><tr>
            <td class="black">281</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">282</td>
            <td> */ // note - lazy is a perf killer for building, probably doesn't save much over interrogation either (given Iterator is used) 
</td>
          </tr><tr>
            <td class="green">283</td>
            <td>case class Node[Item &lt;: LeftLike[Item, Tree[Item, Section, CC]], Section, CC[X] &lt;: IndexedSeqLike[X, CC[X]]](index: Int, focus: ItemOrTree[Item, Section, CC])
</td>
          </tr><tr>
            <td class="black">284</td>
            <td>
</td>
          </tr><tr>
            <td class="green">285</td>
            <td>case class Path[Item &lt;: LeftLike[Item, Tree[Item, Section, CC]], Section, CC[X] &lt;: IndexedSeqLike[X, CC[X]]](top: EitherLike[Top[Item,Section,CC], Path[Item, Section, CC]], node: Node[Item, Section, CC])
</td>
          </tr><tr>
            <td class="black">286</td>
            <td>     (implicit cbf : CanBuildFrom[CC[_], ItemOrTree[Item, Section, CC], CC[ItemOrTree[Item, Section, CC]]]) extends Iterable[Path[Item, Section, CC]] with RightLike[Top[Item, Section, CC], Path[Item, Section, CC]] { self =&gt;
</td>
          </tr><tr>
            <td class="black">287</td>
            <td>
</td>
          </tr><tr>
            <td class="black">288</td>
            <td>  // for some reason its not liking the types, probably  good one
</td>
          </tr><tr>
            <td class="black">289</td>
            <td>  //@inline def asCC( 
</td>
          </tr><tr>
            <td class="black">290</td>
            <td>
</td>
          </tr><tr>
            <td class="green">291</td>
            <td>  def parentTree : Tree[Item, Section, CC] = top.getRight.node.focus.getRight
</td>
          </tr><tr>
            <td class="black">292</td>
            <td>
</td>
          </tr><tr>
            <td class="green">293</td>
            <td>  def parentCount = if (top.isLeft) 0 else parentTree.children.length
</td>
          </tr><tr>
            <td class="black">294</td>
            <td>
</td>
          </tr><tr>
            <td class="black">295</td>
            <td>  /** Is there a previous sibling */
</td>
          </tr><tr>
            <td class="red">296</td>
            <td>  def hasPreviousSibling = (<span class="non">node.index &gt; 0 &amp;&amp; node.index &lt;= parentCount)
</span></td>
          </tr><tr>
            <td class="black">297</td>
            <td>
</td>
          </tr><tr>
            <td class="black">298</td>
            <td>  /** Does it have a further sibling */
</td>
          </tr><tr>
            <td class="green">299</td>
            <td>  def hasNextSibling = (node.index &gt; -1 &amp;&amp; node.index &lt; (parentCount - 1))
</td>
          </tr><tr>
            <td class="black">300</td>
            <td>
</td>
          </tr><tr>
            <td class="black">301</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">302</td>
            <td>   * Is the focus an Item?
</td>
          </tr><tr>
            <td class="black">303</td>
            <td>   */
</td>
          </tr><tr>
            <td class="green">304</td>
            <td>  def isItem = node.focus.isLeft
</td>
          </tr><tr>
            <td class="black">305</td>
            <td>
</td>
          </tr><tr>
            <td class="black">306</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">307</td>
            <td>   * Does the focus have a child?
</td>
          </tr><tr>
            <td class="black">308</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">309</td>
            <td>  def hasChildren =
</td>
          </tr><tr>
            <td class="yellow">310</td>
            <td>    if (isItem) <span class="non">false
</span></td>
          </tr><tr>
            <td class="green">311</td>
            <td>    else children.length != 0
</td>
          </tr><tr>
            <td class="black">312</td>
            <td>
</td>
          </tr><tr>
            <td class="black">313</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">314</td>
            <td>   * Children for a path, don't call unless it is not an item
</td>
          </tr><tr>
            <td class="black">315</td>
            <td>   */ 
</td>
          </tr><tr>
            <td class="green">316</td>
            <td>  def children : CC[ItemOrTree[Item,Section,CC]]  = node.focus.right.get.children
</td>
          </tr><tr>
            <td class="black">317</td>
            <td>
</td>
          </tr><tr>
            <td class="black">318</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">319</td>
            <td>   * Call hasPreviousSibling first to assert there is a previous sibling
</td>
          </tr><tr>
            <td class="black">320</td>
            <td>   */
</td>
          </tr><tr>
            <td class="green">321</td>
            <td>  def previousSibling = Path(top, Node(node.index - 1, parentTree.children.apply(node.index - 1)))
</td>
          </tr><tr>
            <td class="black">322</td>
            <td>
</td>
          </tr><tr>
            <td class="black">323</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">324</td>
            <td>   * Call hasNextSibling first to assert there is a next sibling
</td>
          </tr><tr>
            <td class="black">325</td>
            <td>   */
</td>
          </tr><tr>
            <td class="green">326</td>
            <td>  def nextSibling = Path(top, Node(node.index + 1, parentTree.children(node.index + 1)))
</td>
          </tr><tr>
            <td class="black">327</td>
            <td>
</td>
          </tr><tr>
            <td class="black">328</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">329</td>
            <td>   * get the tree (isItem == false)
</td>
          </tr><tr>
            <td class="black">330</td>
            <td>   * @return
</td>
          </tr><tr>
            <td class="black">331</td>
            <td>   */
</td>
          </tr><tr>
            <td class="green">332</td>
            <td>  def tree() = node.focus.getRight
</td>
          </tr><tr>
            <td class="black">333</td>
            <td>
</td>
          </tr><tr>
            <td class="black">334</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">335</td>
            <td>   * get the item (isItem == true)
</td>
          </tr><tr>
            <td class="black">336</td>
            <td>   * @return
</td>
          </tr><tr>
            <td class="black">337</td>
            <td>   */
</td>
          </tr><tr>
            <td class="green">338</td>
            <td>  def item() = node.focus.getLeft
</td>
          </tr><tr>
            <td class="black">339</td>
            <td>
</td>
          </tr><tr>
            <td class="green">340</td>
            <td><a id="Class_scales_utils_Path_ItemIterator"></a>  private[this] class ItemIterator() extends Iterator[Path[Item,Section, CC]] { 
</td>
          </tr><tr>
            <td class="green">341</td>
            <td>    def hasNext = false
</td>
          </tr><tr>
            <td class="red">342</td>
            <td>    def next() = <span class="non">error(&quot;Cannot iterate over an item&quot;)
</span></td>
          </tr><tr>
            <td class="black">343</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">344</td>
            <td>
</td>
          </tr><tr>
            <td class="green">345</td>
            <td><a id="Class_scales_utils_Path_TreeIterator"></a>  private[this] class TreeIterator() extends Iterator[Path[Item,Section, CC]] { 
</td>
          </tr><tr>
            <td class="green">346</td>
            <td>    val c = children.iterator
</td>
          </tr><tr>
            <td class="green">347</td>
            <td>    var index = -1
</td>
          </tr><tr>
            <td class="black">348</td>
            <td>    
</td>
          </tr><tr>
            <td class="green">349</td>
            <td>    def hasNext = c.hasNext
</td>
          </tr><tr>
            <td class="black">350</td>
            <td>
</td>
          </tr><tr>
            <td class="black">351</td>
            <td>    def next() : Path[Item, Section, CC] = {
</td>
          </tr><tr>
            <td class="green">352</td>
            <td>      index += 1
</td>
          </tr><tr>
            <td class="green">353</td>
            <td>      Path(self, Node(index, c.next()))
</td>
          </tr><tr>
            <td class="black">354</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">355</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">356</td>
            <td>
</td>
          </tr><tr>
            <td class="black">357</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">358</td>
            <td>   * Provide iterator to the path of the children
</td>
          </tr><tr>
            <td class="black">359</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">360</td>
            <td>  def iterator() = 
</td>
          </tr><tr>
            <td class="green">361</td>
            <td>    if (isItem)
</td>
          </tr><tr>
            <td class="green">362</td>
            <td>      new ItemIterator()
</td>
          </tr><tr>
            <td class="black">363</td>
            <td>    else
</td>
          </tr><tr>
            <td class="green">364</td>
            <td>      new TreeIterator()
</td>
          </tr><tr>
            <td class="black">365</td>
            <td>
</td>
          </tr><tr>
            <td class="black">366</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">367</td>
            <td>   * Returns either the first child or none.  Note the child would still need to be unpacked
</td>
          </tr><tr>
            <td class="black">368</td>
            <td>   * @return
</td>
          </tr><tr>
            <td class="black">369</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">370</td>
            <td>  def firstChild(): Option[Path[Item, Section, CC]] =
</td>
          </tr><tr>
            <td class="yellow">371</td>
            <td>    if (!hasChildren) <span class="non">None // can't have a child if its just a data node
</span></td>
          </tr><tr>
            <td class="green">372</td>
            <td>    else Some(Path(this, Node(0, children.head)))
</td>
          </tr><tr>
            <td class="black">373</td>
            <td>
</td>
          </tr><tr>
            <td class="black">374</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">375</td>
            <td>   * Returns either the last child or none.  Note the child would still need to be unpacked
</td>
          </tr><tr>
            <td class="black">376</td>
            <td>   * @return
</td>
          </tr><tr>
            <td class="black">377</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">378</td>
            <td>  def lastChild(): Option[Path[Item, Section, CC]] = // don't ask children twice
</td>
          </tr><tr>
            <td class="red">379</td>
            <td>    if (<span class="non">isItem) None // items don't have children
</span></td>
          </tr><tr>
            <td class="black">380</td>
            <td>    else {
</td>
          </tr><tr>
            <td class="red">381</td>
            <td>      val c = <span class="non">children
</span></td>
          </tr><tr>
            <td class="red">382</td>
            <td>      if (<span class="non">c.length == 0) None // no children
</span></td>
          </tr><tr>
            <td class="black">383</td>
            <td>      else {
</td>
          </tr><tr>
            <td class="red">384</td>
            <td>  val newPos = <span class="non">c.length - 1
</span></td>
          </tr><tr>
            <td class="red">385</td>
            <td>  <span class="non">Some(Path(this,
</span></td>
          </tr><tr>
            <td class="black">386</td>
            <td>    Node(newPos, c(newPos))))
</td>
          </tr><tr>
            <td class="black">387</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">388</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">389</td>
            <td>                       
</td>
          </tr><tr>
            <td class="black">390</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">391</td>
            <td>   * zipUp returns this if it is already the top item (doesn't have a parent to zip), and a
</td>
          </tr><tr>
            <td class="black">392</td>
            <td>   * newly zipped node when not if the focus has been modified
</td>
          </tr><tr>
            <td class="black">393</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">394</td>
            <td>  def zipUp(): Path[Item, Section, CC] =
</td>
          </tr><tr>
            <td class="yellow">395</td>
            <td>    if (top.isLeft) <span class="non">this
</span></td>
          </tr><tr>
            <td class="black">396</td>
            <td>    else {
</td>
          </tr><tr>
            <td class="green">397</td>
            <td>      val path = top.right.get
</td>
          </tr><tr>
            <td class="green">398</td>
            <td>      val pt = parentTree
</td>
          </tr><tr>
            <td class="black">399</td>
            <td>
</td>
          </tr><tr>
            <td class="green">400</td>
            <td>      if (pt.children(node.index) eq node.focus) path
</td>
          </tr><tr>
            <td class="black">401</td>
            <td>      else {
</td>
          </tr><tr>
            <td class="black">402</td>
            <td>        val parentFocus = // ZIP IT, must be a tree
</td>
          </tr><tr>
            <td class="green">403</td>
            <td>          subtree(pt.section, pt.children.updated(node.index, node.focus))
</td>
          </tr><tr>
            <td class="black">404</td>
            <td>
</td>
          </tr><tr>
            <td class="green">405</td>
            <td>        Path(path.top, Node(path.node.index,
</td>
          </tr><tr>
            <td class="black">406</td>
            <td>          parentFocus))
</td>
          </tr><tr>
            <td class="black">407</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">408</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">409</td>
            <td>
</td>
          </tr><tr>
            <td class="black">410</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">411</td>
            <td>   * Replaces this paths focus returning the path for the returned node.
</td>
          </tr><tr>
            <td class="black">412</td>
            <td>   * @param
</td>
          </tr><tr>
            <td class="black">413</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">414</td>
            <td>  def modify(newFocus: (ItemOrTree[Item, Section, CC]) =&gt; ItemOrTree[Item, Section, CC]) =
</td>
          </tr><tr>
            <td class="green">415</td>
            <td>    Path(top, Node(node.index,
</td>
          </tr><tr>
            <td class="black">416</td>
            <td>      newFocus(node.focus)))
</td>
          </tr><tr>
            <td class="black">417</td>
            <td>
</td>
          </tr><tr>
            <td class="black">418</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">419</td>
            <td>   * Removes this node, returning the parent path or None if its top
</td>
          </tr><tr>
            <td class="black">420</td>
            <td>   * @return
</td>
          </tr><tr>
            <td class="black">421</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">422</td>
            <td>  def removeAndUp(): Option[Path[Item, Section, CC]] =
</td>
          </tr><tr>
            <td class="green">423</td>
            <td>    if (top.isLeft) None
</td>
          </tr><tr>
            <td class="black">424</td>
            <td>    else {
</td>
          </tr><tr>
            <td class="green">425</td>
            <td>      val path = top.right.get
</td>
          </tr><tr>
            <td class="green">426</td>
            <td>      val tree = path.node.focus.right.get
</td>
          </tr><tr>
            <td class="black">427</td>
            <td>
</td>
          </tr><tr>
            <td class="black">428</td>
            <td>      val parentFocus = {
</td>
          </tr><tr>
            <td class="green">429</td>
            <td>  val c = parentTree.children
</td>
          </tr><tr>
            <td class="black">430</td>
            <td>
</td>
          </tr><tr>
            <td class="green">431</td>
            <td>  if (c.size == 1) {
</td>
          </tr><tr>
            <td class="black">432</td>
            <td>    // optimising for pull parse onqnames, if its only one in the parent, set the parent to empty, sucks if its not traversable
</td>
          </tr><tr>
            <td class="green">433</td>
            <td>    subtree(tree.section, c.asInstanceOf[scala.collection.Traversable[ItemOrTree[Item, Section, CC]]].companion.empty.asInstanceOf[CC[ItemOrTree[Item, Section, CC]]])
</td>
          </tr><tr>
            <td class="black">434</td>
            <td>  } else {
</td>
          </tr><tr>
            <td class="green">435</td>
            <td>    val parts = parentTree.children.splitAt(node.index)
</td>
          </tr><tr>
            <td class="green">436</td>
            <td>    subtree(tree.section, parts._1 ++ parts._2.tail)
</td>
          </tr><tr>
            <td class="black">437</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">438</td>
            <td>  
</td>
          </tr><tr>
            <td class="black">439</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">440</td>
            <td>
</td>
          </tr><tr>
            <td class="green">441</td>
            <td>      Some(
</td>
          </tr><tr>
            <td class="black">442</td>
            <td>        Path(path.top, Node(path.node.index,
</td>
          </tr><tr>
            <td class="black">443</td>
            <td>          parentFocus)))
</td>
          </tr><tr>
            <td class="black">444</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">445</td>
            <td>
</td>
          </tr><tr>
            <td class="black">446</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">447</td>
            <td>   * Gets the relative position of this Path
</td>
          </tr><tr>
            <td class="black">448</td>
            <td>   * DOES NOT perform a zip
</td>
          </tr><tr>
            <td class="black">449</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">450</td>
            <td>  def position(): Position[Item, Section, CC] = {
</td>
          </tr><tr>
            <td class="black">451</td>
            <td>    @scala.annotation.tailrec
</td>
          </tr><tr>
            <td class="black">452</td>
            <td>    def makePosition(path: Path[Item, Section, CC], stack: Stack[Int]): (Stack[Int], Path[Item, Section, CC]) = {
</td>
          </tr><tr>
            <td class="green">453</td>
            <td>      val newStack = stack.push(path.node.index)
</td>
          </tr><tr>
            <td class="green">454</td>
            <td>      if (path.top.isLeft)
</td>
          </tr><tr>
            <td class="green">455</td>
            <td>        (newStack, path)
</td>
          </tr><tr>
            <td class="black">456</td>
            <td>      else
</td>
          </tr><tr>
            <td class="green">457</td>
            <td>        makePosition(path.top.right.get, newStack)
</td>
          </tr><tr>
            <td class="black">458</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">459</td>
            <td>
</td>
          </tr><tr>
            <td class="green">460</td>
            <td>    val res = makePosition(this, Stack[Int]())
</td>
          </tr><tr>
            <td class="green">461</td>
            <td>    new PositionImpl[Item,Section,CC](res._1, res._2)
</td>
          </tr><tr>
            <td class="black">462</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">463</td>
            <td>
</td>
          </tr><tr>
            <td class="black">464</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">465</td>
            <td>   * Gives a nicer representation then the standard (Paths(Paths(), Paths).  But still too much info
</td>
          </tr><tr>
            <td class="black">466</td>
            <td>   *
</td>
          </tr><tr>
            <td class="black">467</td>
            <td>   * Path( Section | Top, FocusSection | FocusItem)
</td>
          </tr><tr>
            <td class="black">468</td>
            <td>   *
</td>
          </tr><tr>
            <td class="black">469</td>
            <td>   * @return
</td>
          </tr><tr>
            <td class="black">470</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">471</td>
            <td>  override def toString(): String = {
</td>
          </tr><tr>
            <td class="green">472</td>
            <td>    val builder = new java.lang.StringBuilder()
</td>
          </tr><tr>
            <td class="black">473</td>
            <td>
</td>
          </tr><tr>
            <td class="green">474</td>
            <td>    builder.append(&quot;Path(&quot;);
</td>
          </tr><tr>
            <td class="green">475</td>
            <td>    if (top.isLeft)
</td>
          </tr><tr>
            <td class="green">476</td>
            <td>      builder.append(&quot;Top&quot;);
</td>
          </tr><tr>
            <td class="black">477</td>
            <td>    else
</td>
          </tr><tr>
            <td class="red">478</td>
            <td>      <span class="non">builder.append(top.right.get.tree.section);
</span></td>
          </tr><tr>
            <td class="green">479</td>
            <td>    builder.append(&quot;,&quot;);
</td>
          </tr><tr>
            <td class="green">480</td>
            <td>    if (isItem)
</td>
          </tr><tr>
            <td class="red">481</td>
            <td>      <span class="non">builder.append(item);
</span></td>
          </tr><tr>
            <td class="black">482</td>
            <td>    else
</td>
          </tr><tr>
            <td class="green">483</td>
            <td>      builder.append(tree.section);
</td>
          </tr><tr>
            <td class="green">484</td>
            <td>    builder.append(&quot;)&quot;);
</td>
          </tr><tr>
            <td class="black">485</td>
            <td>
</td>
          </tr><tr>
            <td class="green">486</td>
            <td>    builder.toString
</td>
          </tr><tr>
            <td class="black">487</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">488</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">489</td>
            <td>
</td>
          </tr><tr>
            <td class="black">490</td>
            <td><a id="Trait_scales_utils_FoldOperation"></a>sealed trait FoldOperation[Item &lt;: LeftLike[Item, Tree[Item, Section, CC]], Section, CC[X] &lt;: IndexedSeqLike[X, CC[X]]] {
</td>
          </tr><tr>
            <td class="black">491</td>
            <td>
</td>
          </tr><tr>
            <td class="black">492</td>
            <td>  def adjust(positions: Seq[Position[Item, Section, CC]]): Seq[Position[Item, Section, CC]]
</td>
          </tr><tr>
            <td class="black">493</td>
            <td>
</td>
          </tr><tr>
            <td class="black">494</td>
            <td>  def perform(path: Path[Item, Section, CC]): FoldR[Item, Section, CC]
</td>
          </tr><tr>
            <td class="black">495</td>
            <td>
</td>
          </tr><tr>
            <td class="black">496</td>
            <td>  def add(path: Path[Item, Section, CC], direction: Int, newPath: Iterable[ItemOrTree[Item, Section, CC]])(implicit cbf : TreeCBF[Item, Section, CC]) : FoldR[Item, Section, CC] = {
</td>
          </tr><tr>
            <td class="black">497</td>
            <td>    // need to go up to replace
</td>
          </tr><tr>
            <td class="green">498</td>
            <td>    val parent = path.zipUp
</td>
          </tr><tr>
            <td class="green">499</td>
            <td>    if (path.top.isLeft)
</td>
          </tr><tr>
            <td class="red">500</td>
            <td>      <span class="non">Right(AddedBeforeOrAfterRoot)
</span></td>
          </tr><tr>
            <td class="black">501</td>
            <td>    else
</td>
          </tr><tr>
            <td class="green">502</td>
            <td>      Left(parent.
</td>
          </tr><tr>
            <td class="black">503</td>
            <td>        modify { x =&gt;
</td>
          </tr><tr>
            <td class="green">504</td>
            <td>          val tree = x.right.get;
</td>
          </tr><tr>
            <td class="green">505</td>
            <td>          val index = path.node.index + direction
</td>
          </tr><tr>
            <td class="green">506</td>
            <td>          val (pre,pos) = tree.children.splitAt(index)
</td>
          </tr><tr>
            <td class="green">507</td>
            <td>          val newChildren = (pre ++ newPath) ++ pos
</td>
          </tr><tr>
            <td class="green">508</td>
            <td>          Tree(tree.section, newChildren)//Right()
</td>
          </tr><tr>
            <td class="black">509</td>
            <td>        })
</td>
          </tr><tr>
            <td class="black">510</td>
            <td>
</td>
          </tr><tr>
            <td class="black">511</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">512</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">513</td>
            <td>
</td>
          </tr><tr>
            <td class="green">514</td>
            <td>case class Remove[Item &lt;: LeftLike[Item, Tree[Item, Section, CC]], Section, CC[X] &lt;: IndexedSeqLike[X, CC[X]]](implicit cbf : TreeCBF[Item, Section, CC]) extends FoldOperation[Item, Section, CC] {
</td>
          </tr><tr>
            <td class="green">515</td>
            <td>  def adjust(positions: Seq[Position[Item, Section, CC]]): Seq[Position[Item, Section, CC]] = cleanBelow(positions).map { shiftWithBase(positions.head, _, -1) }
</td>
          </tr><tr>
            <td class="black">516</td>
            <td>
</td>
          </tr><tr>
            <td class="black">517</td>
            <td>  def perform(path: Path[Item, Section, CC]): FoldR[Item, Section, CC] = {
</td>
          </tr><tr>
            <td class="green">518</td>
            <td>    val ores = path.removeAndUp();
</td>
          </tr><tr>
            <td class="green">519</td>
            <td>    if (ores.isDefined) Left(ores.get)
</td>
          </tr><tr>
            <td class="red">520</td>
            <td>    else <span class="non">Right(RemovedRoot)
</span></td>
          </tr><tr>
            <td class="black">521</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">522</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">523</td>
            <td>
</td>
          </tr><tr>
            <td class="green">524</td>
            <td>case class AddBefore[Item &lt;: LeftLike[Item, Tree[Item, Section, CC]], Section, CC[X] &lt;: IndexedSeqLike[X, CC[X]]](newPath: ItemOrTree[Item, Section, CC])(implicit cbf : TreeCBF[Item, Section, CC]) extends FoldOperation[Item, Section, CC] {
</td>
          </tr><tr>
            <td class="green">525</td>
            <td>  def adjust(positions: Seq[Position[Item, Section, CC]]): Seq[Position[Item, Section, CC]] = positions.tail.map { shiftWithBase(positions.head, _, 1) }
</td>
          </tr><tr>
            <td class="black">526</td>
            <td>
</td>
          </tr><tr>
            <td class="green">527</td>
            <td>  def perform(path: Path[Item, Section, CC]): FoldR[Item, Section, CC] = add(path, 0, List(newPath))
</td>
          </tr><tr>
            <td class="black">528</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">529</td>
            <td>
</td>
          </tr><tr>
            <td class="green">530</td>
            <td>case class AddAfter[Item &lt;: LeftLike[Item, Tree[Item, Section, CC]], Section, CC[X] &lt;: IndexedSeqLike[X, CC[X]]](newPath: ItemOrTree[Item, Section, CC])(implicit cbf : TreeCBF[Item, Section, CC]) extends FoldOperation[Item, Section, CC] {
</td>
          </tr><tr>
            <td class="green">531</td>
            <td>  def adjust(positions: Seq[Position[Item, Section, CC]]): Seq[Position[Item, Section, CC]] = positions.tail.map { shiftWithBase(positions.head, _, 1) }
</td>
          </tr><tr>
            <td class="black">532</td>
            <td>
</td>
          </tr><tr>
            <td class="green">533</td>
            <td>  def perform(path: Path[Item, Section, CC]): FoldR[Item, Section, CC] = add(path, 1, List(newPath))
</td>
          </tr><tr>
            <td class="black">534</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">535</td>
            <td>
</td>
          </tr><tr>
            <td class="black">536</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">537</td>
            <td> * Use to make it easier to filter out large sets (for those that aren't interesting simply asis them, see tests for use case)
</td>
          </tr><tr>
            <td class="black">538</td>
            <td> */
</td>
          </tr><tr>
            <td class="green">539</td>
            <td>case class AsIs[Item &lt;: LeftLike[Item, Tree[Item, Section, CC]], Section, CC[X] &lt;: IndexedSeqLike[X, CC[X]]]() extends FoldOperation[Item, Section, CC] {
</td>
          </tr><tr>
            <td class="black">540</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">541</td>
            <td>   * No OP, just move one one
</td>
          </tr><tr>
            <td class="black">542</td>
            <td>   */
</td>
          </tr><tr>
            <td class="green">543</td>
            <td>  def adjust(positions: Seq[Position[Item, Section, CC]]): Seq[Position[Item, Section, CC]] = positions.tail
</td>
          </tr><tr>
            <td class="black">544</td>
            <td>
</td>
          </tr><tr>
            <td class="green">545</td>
            <td>  def perform(path: Path[Item, Section, CC]): FoldR[Item, Section, CC] = Left(path)
</td>
          </tr><tr>
            <td class="black">546</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">547</td>
            <td>
</td>
          </tr><tr>
            <td class="black">548</td>
            <td><a id="Object_scales_utils_Replace"></a>object Replace {
</td>
          </tr><tr>
            <td class="black">549</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">550</td>
            <td>   * Simpler interface
</td>
          </tr><tr>
            <td class="black">551</td>
            <td>   */
</td>
          </tr><tr>
            <td class="green">552</td>
            <td>  def apply[Item &lt;: LeftLike[Item, Tree[Item, Section, CC]], Section, CC[X] &lt;: IndexedSeqLike[X, CC[X]]](replaceWith: ItemOrTree[Item, Section, CC]*)(implicit cbf : TreeCBF[Item, Section, CC]) = new Replace[Item, Section, CC](replaceWith)
</td>
          </tr><tr>
            <td class="black">553</td>
            <td>
</td>
          </tr><tr>
            <td class="black">554</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">555</td>
            <td>
</td>
          </tr><tr>
            <td class="black">556</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">557</td>
            <td> * Allows replacing one path with many, may be easier to use the * version however
</td>
          </tr><tr>
            <td class="black">558</td>
            <td> */
</td>
          </tr><tr>
            <td class="green">559</td>
            <td>case class Replace[Item &lt;: LeftLike[Item, Tree[Item, Section, CC]], Section, CC[X] &lt;: IndexedSeqLike[X, CC[X]]](replaceWith: Iterable[ItemOrTree[Item, Section, CC]])(implicit cbf : TreeCBF[Item, Section, CC]) extends FoldOperation[Item, Section, CC] {
</td>
          </tr><tr>
            <td class="black">560</td>
            <td>
</td>
          </tr><tr>
            <td class="black">561</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">562</td>
            <td>   * clean below for any that are invalidated by the replace then replaceWiths size minus the 1 that we have removed/replaced
</td>
          </tr><tr>
            <td class="black">563</td>
            <td>   */
</td>
          </tr><tr>
            <td class="green">564</td>
            <td>  def adjust(positions: Seq[Position[Item, Section, CC]]): Seq[Position[Item, Section, CC]] = cleanBelow(positions).map { shiftWithBase(positions.head, _, replaceWith.size - 1) }
</td>
          </tr><tr>
            <td class="black">565</td>
            <td>
</td>
          </tr><tr>
            <td class="black">566</td>
            <td>  def perform(path: Path[Item, Section, CC]): FoldR[Item, Section, CC] = {
</td>
          </tr><tr>
            <td class="black">567</td>
            <td>    // modify with tail
</td>
          </tr><tr>
            <td class="green">568</td>
            <td>    val tpath = path.modify(_ =&gt; replaceWith.head)
</td>
          </tr><tr>
            <td class="green">569</td>
            <td>    add(tpath, 1, replaceWith.tail)
</td>
          </tr><tr>
            <td class="black">570</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">571</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">572</td>
            <td>
</td>
          </tr><tr>
            <td class="black">573</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">574</td>
            <td> * Allows foldPositions to be nested, only replace makes sense here (afaict)
</td>
          </tr><tr>
            <td class="black">575</td>
            <td> */
</td>
          </tr><tr>
            <td class="green">576</td>
            <td>case class ReplaceWith[Item &lt;: LeftLike[Item, Tree[Item, Section, CC]], Section, CC[X] &lt;: IndexedSeqLike[X, CC[X]]](f: PathFoldR[Item, Section, CC])(implicit cbf : TreeCBF[Item, Section, CC]) extends FoldOperation[Item, Section, CC] {
</td>
          </tr><tr>
            <td class="black">577</td>
            <td>
</td>
          </tr><tr>
            <td class="green">578</td>
            <td>  def adjust(positions: Seq[Position[Item, Section, CC]]): Seq[Position[Item, Section, CC]] = cleanBelow(positions).map { shiftWithBase(positions.head, _, 0) }
</td>
          </tr><tr>
            <td class="black">579</td>
            <td>
</td>
          </tr><tr>
            <td class="black">580</td>
            <td>  def perform(path: Path[Item, Section, CC]): FoldR[Item, Section, CC] =
</td>
          </tr><tr>
            <td class="black">581</td>
            <td>    // modify back in (allows changes), or pass on the error
</td>
          </tr><tr>
            <td class="green">582</td>
            <td>    f(path).fold(fres =&gt; Left(path.modify(_ =&gt; fres.tree)),//Right(fres.tree))),
</td>
          </tr><tr>
            <td class="red">583</td>
            <td>      <span class="non">Right(_))
</span></td>
          </tr><tr>
            <td class="black">584</td>
            <td>
</td>
          </tr><tr>
            <td class="black">585</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">586</td>
            <td>
</td>
          </tr><tr>
            <td class="black">587</td>
            <td><a id="Trait_scales_utils_FoldError"></a>sealed trait FoldError
</td>
          </tr><tr>
            <td class="black">588</td>
            <td>
</td>
          </tr><tr>
            <td class="black">589</td>
            <td><a id="Object_scales_utils_NoPaths"></a>case object NoPaths extends FoldError
</td>
          </tr><tr>
            <td class="black">590</td>
            <td><a id="Object_scales_utils_NoSingleRoot"></a>case object NoSingleRoot extends FoldError
</td>
          </tr><tr>
            <td class="black">591</td>
            <td><a id="Object_scales_utils_RemovedRoot"></a>case object RemovedRoot extends FoldError
</td>
          </tr><tr>
            <td class="black">592</td>
            <td><a id="Object_scales_utils_AddedBeforeOrAfterRoot"></a>case object AddedBeforeOrAfterRoot extends FoldError
</td>
          </tr></tbody></table>