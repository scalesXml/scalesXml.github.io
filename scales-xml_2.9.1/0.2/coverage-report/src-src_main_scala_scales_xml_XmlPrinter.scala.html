<table class="classes"><tbody><tr>
      <td class="barContainerLeft"><a href="#">&#x200B;scales/&#x200B;xml/<span class="header">&#x200B;XmlPrinter.scala</span></a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">71 %</div>
        <div class="greenBar" style="width:142px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPrinter.scala.html#Class_scales_xml_CDataCannotBeEncoded"><img src="class.png"></img>CDataCannotBeEncoded</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPrinter.scala.html#Class_scales_xml_CannotBeEncoded"><img src="class.png"></img>CannotBeEncoded</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPrinter.scala.html#Class_scales_xml_CannotSerialize"><img src="class.png"></img>CannotSerialize</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPrinter.scala.html#Class_scales_xml_CommentCannotBeEncoded"><img src="class.png"></img>CommentCannotBeEncoded</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPrinter.scala.html#Class_scales_xml_IncompatibleQNameVersions"><img src="class.png"></img>IncompatibleQNameVersions</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPrinter.scala.html#Class_scales_xml_InvalidCharacterInMarkup"><img src="class.png"></img>InvalidCharacterInMarkup</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPrinter.scala.html#Trait_scales_xml_LSSerializer"><img src="trait.png"></img>LSSerializer</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">86 %</div>
        <div class="greenBar" style="width:172px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPrinter.scala.html#Trait_scales_xml_LSSerializerConcurrentCacheFactory"><img src="trait.png"></img>LSSerializerConcurrentCacheFactory</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPrinter.scala.html#Class_scales_xml_LSSerializerConcurrentCacheFactoryXHTML"><img src="class.png"></img>LSSerializerConcurrentCacheFactoryXHTML</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPrinter.scala.html#Trait_scales_xml_LSSerializerConcurrentCacheFactoryXHTML"><img src="trait.png"></img>LSSerializerConcurrentCacheFactoryXHTML</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPrinter.scala.html#Object_scales_xml_LSSerializerFactory"><img src="object.png"></img>LSSerializerFactory</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPrinter.scala.html#Class_scales_xml_LSSerializerFactoryBase"><img src="class.png"></img>LSSerializerFactoryBase</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPrinter.scala.html#Trait_scales_xml_LSSerializerFactoryBase"><img src="trait.png"></img>LSSerializerFactoryBase</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPrinter.scala.html#Object_scales_xml_LSSerializerFactoryXHTML"><img src="object.png"></img>LSSerializerFactoryXHTML</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPrinter.scala.html#Object_scales_xml_LSSerializerNoCacheFactory"><img src="object.png"></img>LSSerializerNoCacheFactory</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPrinter.scala.html#Trait_scales_xml_LSSerializerNoCacheFactoryT"><img src="trait.png"></img>LSSerializerNoCacheFactoryT</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPrinter.scala.html#Class_scales_xml_PICannotBeEncoded"><img src="class.png"></img>PICannotBeEncoded</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPrinter.scala.html#Class_scales_xml_SerializationException"><img src="class.png"></img>SerializationException</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPrinter.scala.html#Trait_scales_xml_Serializer"><img src="trait.png"></img>Serializer</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPrinter.scala.html#Class_scales_xml_SerializerData"><img src="class.png"></img>SerializerData</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPrinter.scala.html#Trait_scales_xml_SerializerFactory"><img src="trait.png"></img>SerializerFactory</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPrinter.scala.html#Object_scales_xml_SerializerHelpers"><img src="object.png"></img>SerializerHelpers</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">88 %</div>
        <div class="greenBar" style="width:176px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPrinter.scala.html#Trait_scales_xml_SimpleSerializer"><img src="trait.png"></img>SimpleSerializer</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPrinter.scala.html#Class_scales_xml_SimpleSerializerFactory"><img src="class.png"></img>SimpleSerializerFactory</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPrinter.scala.html#Object_scales_xml_SimpleSerializerFactory"><img src="object.png"></img>SimpleSerializerFactory</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPrinter.scala.html#Trait_scales_xml_XHTMLLSSerializer"><img src="trait.png"></img>XHTMLLSSerializer</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPrinter.scala.html#Class_scales_xml_XmlOutput"><img src="class.png"></img>XmlOutput</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPrinter.scala.html#Trait_scales_xml_XmlPrinter"><img src="trait.png"></img>XmlPrinter</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">81 %</div>
        <div class="greenBar" style="width:162px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPrinter.scala.html#Trait_scales_xml_XmlPrinter_SerializeableXml"><img src="trait.png"></img>XmlPrinter.SerializeableXml</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPrinter.scala.html#Class_scales_xml_XmlPrinterImplicits"><img src="class.png"></img>XmlPrinterImplicits</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPrinter.scala.html#Trait_scales_xml_XmlPrinterImplicits"><img src="trait.png"></img>XmlPrinterImplicits</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">88 %</div>
        <div class="greenBar" style="width:176px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlPrinter.scala.html#Class_scales_xml_XmlPrinterImplicits_DeclarationConverter"><img src="class.png"></img>XmlPrinterImplicits.DeclarationConverter</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr></tbody></table><table class="source"><tbody><tr>
            <td class="black">1</td>
            <td>package scales.xml
</td>
          </tr><tr>
            <td class="black">2</td>
            <td>
</td>
          </tr><tr>
            <td class="black">3</td>
            <td>import scales.utils._
</td>
          </tr><tr>
            <td class="black">4</td>
            <td>
</td>
          </tr><tr>
            <td class="black">5</td>
            <td>import scala.collection.immutable.{ Stack, Map }
</td>
          </tr><tr>
            <td class="black">6</td>
            <td>
</td>
          </tr><tr>
            <td class="black">7</td>
            <td>import java.io.Writer
</td>
          </tr><tr>
            <td class="black">8</td>
            <td>
</td>
          </tr><tr>
            <td class="black">9</td>
            <td>import java.nio.charset.Charset
</td>
          </tr><tr>
            <td class="black">10</td>
            <td>
</td>
          </tr><tr>
            <td class="black">11</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">12</td>
            <td> * Interface used for serializing the XML events, same for both stream and tree.
</td>
          </tr><tr>
            <td class="black">13</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">14</td>
            <td> * The default implementation validates the output via LSSerializer against a given encoding.
</td>
          </tr><tr>
            <td class="black">15</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">16</td>
            <td><a id="Class_scales_xml_InvalidCharacterInMarkup"></a><a id="Class_scales_xml_XmlOutput"></a><a id="Class_scales_xml_XmlPrinterImplicits_DeclarationConverter"></a><a id="Class_scales_xml_CDataCannotBeEncoded"></a><a id="Class_scales_xml_IncompatibleQNameVersions"></a><a id="Class_scales_xml_CommentCannotBeEncoded"></a><a id="Trait_scales_xml_XmlPrinterImplicits"></a><a id="Class_scales_xml_SerializerData"></a><a id="Class_scales_xml_PICannotBeEncoded"></a><a id="Class_scales_xml_CannotSerialize"></a> * An alternative FastSerializer simply outputs strings and is in no way correct but at least faster then going to StreamWriter for incorrectness.
</td>
          </tr><tr>
            <td class="black">17</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">18</td>
            <td> * Serializers should use qName.ncName for serialization purposes of both attributes and elements, the QName is provided to allow for validation of ouput.
</td>
          </tr><tr>
            <td class="black">19</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">20</td>
            <td> * If a function returns Some it should signal the termination of the serializing.  Implementations are expected to respect this approach, its for the benefit of all developers.
</td>
          </tr><tr>
            <td class="black">21</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">22</td>
            <td> * List[QName] is provided to help if path relevant information is needed for serialization.  For example if a use case requires that a particular path is filtered out.  Purely for performance reasons the list is in reverse order with the current QName at the top and root at the bottom.
</td>
          </tr><tr>
            <td class="black">23</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">24</td>
            <td> */
</td>
          </tr><tr>
            <td class="black">25</td>
            <td><a id="Trait_scales_xml_Serializer"></a>trait Serializer {
</td>
          </tr><tr>
            <td class="black">26</td>
            <td>
</td>
          </tr><tr>
            <td class="black">27</td>
            <td>  def item(item: XmlItem, path: List[QName]): Option[Throwable]
</td>
          </tr><tr>
            <td class="black">28</td>
            <td>
</td>
          </tr><tr>
            <td class="black">29</td>
            <td>  def emptyElement(qName: QName, attributes: Traversable[Attribute], namespaces: Map[String, String], declareDefaultNS: Option[String], path: List[QName]): Option[Throwable]
</td>
          </tr><tr>
            <td class="black">30</td>
            <td>  def startElement(qName: QName, attributes: Traversable[Attribute], namespaces: Map[String, String], declareDefaultNS: Option[String], path: List[QName]): Option[Throwable]
</td>
          </tr><tr>
            <td class="black">31</td>
            <td>  def endElement(qName: QName, path: List[QName]): Option[Throwable]
</td>
          </tr><tr>
            <td class="black">32</td>
            <td>
</td>
          </tr><tr>
            <td class="black">33</td>
            <td>  def xmlDeclaration(encoding: Charset, version: XmlVersion): Option[Throwable]
</td>
          </tr><tr>
            <td class="black">34</td>
            <td>
</td>
          </tr><tr>
            <td class="black">35</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">36</td>
            <td>
</td>
          </tr><tr>
            <td class="green">37</td>
            <td>case class SerializerData(out: Writer, version: XmlVersion = ScalesXml.defaultVersion, encoding: Charset = defaultCharset)
</td>
          </tr><tr>
            <td class="black">38</td>
            <td>
</td>
          </tr><tr>
            <td class="black">39</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">40</td>
            <td> * Serializer factories are responsible for the life cycle of serializers and
</td>
          </tr><tr>
            <td class="black">41</td>
            <td> * their resources.
</td>
          </tr><tr>
            <td class="black">42</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">43</td>
            <td> */
</td>
          </tr><tr>
            <td class="black">44</td>
            <td><a id="Trait_scales_xml_SerializerFactory"></a>trait SerializerFactory {
</td>
          </tr><tr>
            <td class="black">45</td>
            <td>  def apply[R](thunk: Serializer =&gt; R)(data: SerializerData): R
</td>
          </tr><tr>
            <td class="black">46</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">47</td>
            <td>
</td>
          </tr><tr>
            <td class="black">48</td>
            <td><a id="Object_scales_xml_SerializerHelpers"></a>object SerializerHelpers {
</td>
          </tr><tr>
            <td class="black">49</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">50</td>
            <td>   * Outputs the xml document declaration
</td>
          </tr><tr>
            <td class="black">51</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">52</td>
            <td>  def xmlDecl(out: Writer, encoding: java.nio.charset.Charset, version: XmlVersion): Option[Throwable] = {
</td>
          </tr><tr>
            <td class="green">53</td>
            <td>    out.append(&quot;&lt;?xml version=\&quot;&quot; + version.version + &quot;\&quot; encoding=\&quot;&quot; + encoding.displayName + &quot;\&quot;?&gt;&quot;)
</td>
          </tr><tr>
            <td class="green">54</td>
            <td>    None
</td>
          </tr><tr>
            <td class="black">55</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">56</td>
            <td>
</td>
          </tr><tr>
            <td class="black">57</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">58</td>
            <td>   * Default serializer for items, usefull for when the contents aren't correct but you want to see them anyway
</td>
          </tr><tr>
            <td class="black">59</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">60</td>
            <td>  def item(out: Writer, item: XmlItem, path: List[QName]): Option[Throwable] = {
</td>
          </tr><tr>
            <td class="green">61</td>
            <td>    val res = item match {
</td>
          </tr><tr>
            <td class="red">62</td>
            <td>      case Text(value) =&gt; <span class="non">value
</span></td>
          </tr><tr>
            <td class="green">63</td>
            <td>      case CData(value) =&gt; &quot;&lt;![CDATA[&quot; + value + &quot;]]&gt;&quot;
</td>
          </tr><tr>
            <td class="green">64</td>
            <td>      case Comment(value) =&gt; &quot;&lt;!--&quot; + value + &quot;--&gt;&quot;
</td>
          </tr><tr>
            <td class="green">65</td>
            <td>      case PI(target, value) =&gt; &quot;&lt;?&quot; + target + &quot; &quot; + value + &quot;?&gt;&quot;
</td>
          </tr><tr>
            <td class="black">66</td>
            <td>    }
</td>
          </tr><tr>
            <td class="green">67</td>
            <td>    out.append(res)
</td>
          </tr><tr>
            <td class="green">68</td>
            <td>    None
</td>
          </tr><tr>
            <td class="black">69</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">70</td>
            <td>
</td>
          </tr><tr>
            <td class="black">71</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">72</td>
            <td>
</td>
          </tr><tr>
            <td class="black">73</td>
            <td><a id="Object_scales_xml_SimpleSerializerFactory"></a>object SimpleSerializerFactory extends SerializerFactory {
</td>
          </tr><tr>
            <td class="black">74</td>
            <td>  def apply[R](thunk: Serializer =&gt; R)(sdata: SerializerData): R =
</td>
          </tr><tr>
            <td class="red">75</td>
            <td><a id="Class_scales_xml_SimpleSerializerFactory"></a>    <span class="non">thunk(new SimpleSerializer { val data = sdata })
</span></td>
          </tr><tr>
            <td class="black">76</td>
            <td>
</td>
          </tr><tr>
            <td class="black">77</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">78</td>
            <td>
</td>
          </tr><tr>
            <td class="black">79</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">80</td>
            <td> * Performs no validation, sorting of attributes, extra spaces on the end of empty element declarations and uses the short form for empty elements.
</td>
          </tr><tr>
            <td class="black">81</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">82</td>
            <td> * Basically its good for non-pretty printing debugging only
</td>
          </tr><tr>
            <td class="black">83</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">84</td>
            <td> */
</td>
          </tr><tr>
            <td class="black">85</td>
            <td><a id="Trait_scales_xml_SimpleSerializer"></a>trait SimpleSerializer extends Serializer {
</td>
          </tr><tr>
            <td class="black">86</td>
            <td>
</td>
          </tr><tr>
            <td class="black">87</td>
            <td>  val data: SerializerData
</td>
          </tr><tr>
            <td class="black">88</td>
            <td>  import data._
</td>
          </tr><tr>
            <td class="black">89</td>
            <td>
</td>
          </tr><tr>
            <td class="black">90</td>
            <td>  def item(item: XmlItem, path: List[QName]): Option[Throwable] =
</td>
          </tr><tr>
            <td class="red">91</td>
            <td>    <span class="non">SerializerHelpers.item(out, item, path)
</span></td>
          </tr><tr>
            <td class="black">92</td>
            <td>
</td>
          </tr><tr>
            <td class="black">93</td>
            <td>  def doElem(qName: QName, attribs: Traversable[Attribute], ns: Map[String, String], declareDefaultNS: Option[String]) {
</td>
          </tr><tr>
            <td class="black">94</td>
            <td>
</td>
          </tr><tr>
            <td class="red">95</td>
            <td>    <span class="non">out.append(&quot;&lt;&quot; + qName.qName)
</span></td>
          </tr><tr>
            <td class="black">96</td>
            <td>
</td>
          </tr><tr>
            <td class="red">97</td>
            <td>    <span class="non">declareDefaultNS.foreach { dns =&gt;
</span></td>
          </tr><tr>
            <td class="red">98</td>
            <td>      <span class="non">out.append(&quot; xmlns=\&quot;&quot; + dns + &quot;\&quot;&quot;)
</span></td>
          </tr><tr>
            <td class="black">99</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">100</td>
            <td>
</td>
          </tr><tr>
            <td class="red">101</td>
            <td>    <span class="non">ns.foreach { x =&gt;
</span></td>
          </tr><tr>
            <td class="red">102</td>
            <td>      <span class="non">out.append(&quot; xmlns:&quot; + x._1 + &quot;=\&quot;&quot; + x._2 + &quot;\&quot;&quot;)
</span></td>
          </tr><tr>
            <td class="black">103</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">104</td>
            <td>
</td>
          </tr><tr>
            <td class="black">105</td>
            <td>    import ScalesXml._
</td>
          </tr><tr>
            <td class="black">106</td>
            <td>
</td>
          </tr><tr>
            <td class="red">107</td>
            <td>    <span class="non">attribs.foreach { x =&gt;
</span></td>
          </tr><tr>
            <td class="red">108</td>
            <td>      <span class="non">out.append(&quot; &quot; + x.name.qName + &quot;=\&quot;&quot; + x.value + &quot;\&quot;&quot;)
</span></td>
          </tr><tr>
            <td class="black">109</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">110</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">111</td>
            <td>
</td>
          </tr><tr>
            <td class="black">112</td>
            <td>  def emptyElement(qName: QName, attributes: Traversable[Attribute], namespaces: Map[String, String], declareDefaultNS: Option[String], path: List[QName]): Option[Throwable] = {
</td>
          </tr><tr>
            <td class="red">113</td>
            <td>    <span class="non">doElem(qName, attributes, namespaces, declareDefaultNS)
</span></td>
          </tr><tr>
            <td class="red">114</td>
            <td>    <span class="non">out.append(&quot;/&gt;&quot;)
</span></td>
          </tr><tr>
            <td class="red">115</td>
            <td>    <span class="non">None
</span></td>
          </tr><tr>
            <td class="black">116</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">117</td>
            <td>
</td>
          </tr><tr>
            <td class="black">118</td>
            <td>  def startElement(qName: QName, attributes: Traversable[Attribute], namespaces: Map[String, String], declareDefaultNS: Option[String], path: List[QName]): Option[Throwable] = {
</td>
          </tr><tr>
            <td class="red">119</td>
            <td>    <span class="non">doElem(qName, attributes, namespaces, declareDefaultNS)
</span></td>
          </tr><tr>
            <td class="red">120</td>
            <td>    <span class="non">out.append(&quot;&gt;&quot;)
</span></td>
          </tr><tr>
            <td class="red">121</td>
            <td>    <span class="non">None
</span></td>
          </tr><tr>
            <td class="black">122</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">123</td>
            <td>
</td>
          </tr><tr>
            <td class="black">124</td>
            <td>  def endElement(qName: QName, path: List[QName]): Option[Throwable] = {
</td>
          </tr><tr>
            <td class="red">125</td>
            <td>    <span class="non">out.append(&quot;&lt;/&quot; + qName.qName + &quot;&gt;&quot;)
</span></td>
          </tr><tr>
            <td class="red">126</td>
            <td>    <span class="non">None
</span></td>
          </tr><tr>
            <td class="black">127</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">128</td>
            <td>
</td>
          </tr><tr>
            <td class="red">129</td>
            <td>  def xmlDeclaration(encoding: Charset, version: XmlVersion): Option[Throwable] = <span class="non">SerializerHelpers.xmlDecl(out, encoding, version)
</span></td>
          </tr><tr>
            <td class="black">130</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">131</td>
            <td>
</td>
          </tr><tr>
            <td class="black">132</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">133</td>
            <td> * Base exception marker for serialization
</td>
          </tr><tr>
            <td class="black">134</td>
            <td> */
</td>
          </tr><tr>
            <td class="green">135</td>
            <td><a id="Class_scales_xml_SerializationException"></a>class SerializationException(val what: String) extends RuntimeException(what) {
</td>
          </tr><tr>
            <td class="black">136</td>
            <td>  //  override def fillInStackTrace() = this
</td>
          </tr><tr>
            <td class="black">137</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">138</td>
            <td>
</td>
          </tr><tr>
            <td class="green">139</td>
            <td><a id="Class_scales_xml_CannotBeEncoded"></a>class CannotBeEncoded(override val what: String) extends SerializationException(what)
</td>
          </tr><tr>
            <td class="black">140</td>
            <td>
</td>
          </tr><tr>
            <td class="black">141</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">142</td>
            <td> * The serialization encoding cannot support the characters in a given markup (attribute name or element name. ächtung in UTF-8 works but not in US-ASCII.
</td>
          </tr><tr>
            <td class="black">143</td>
            <td> */
</td>
          </tr><tr>
            <td class="green">144</td>
            <td>case class InvalidCharacterInMarkup(override val what: String) extends SerializationException(what)
</td>
          </tr><tr>
            <td class="black">145</td>
            <td>
</td>
          </tr><tr>
            <td class="black">146</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">147</td>
            <td> * The CData content must be split due to encoding issues, which isn't supported (due to bad CData handling on Sun JRE and differences with Xalan.
</td>
          </tr><tr>
            <td class="black">148</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">149</td>
            <td> * NOTE The Xalan behaviour follows the DOMConfiguration behaviour but will split on encoding issues, which breaks the point of using CData, so if you need that, don't use it, let your sax / pull parser handle proper serilization and escaping for you in a normal text field.
</td>
          </tr><tr>
            <td class="black">150</td>
            <td> */
</td>
          </tr><tr>
            <td class="green">151</td>
            <td>case class CDataCannotBeEncoded(override val what: String) extends CannotBeEncoded(what)
</td>
          </tr><tr>
            <td class="black">152</td>
            <td>
</td>
          </tr><tr>
            <td class="black">153</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">154</td>
            <td> * Comments don't support &amp; recognition, which means you can't escape the encoding, either they encode or they do not
</td>
          </tr><tr>
            <td class="black">155</td>
            <td> */
</td>
          </tr><tr>
            <td class="green">156</td>
            <td>case class CommentCannotBeEncoded(override val what: String) extends CannotBeEncoded(what)
</td>
          </tr><tr>
            <td class="black">157</td>
            <td>
</td>
          </tr><tr>
            <td class="black">158</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">159</td>
            <td> * PIs also suffer a bad specification
</td>
          </tr><tr>
            <td class="black">160</td>
            <td> */
</td>
          </tr><tr>
            <td class="red">161</td>
            <td>case class PICannotBeEncoded<span class="non">(override val what: String) extends CannotBeEncoded(what)
</span></td>
          </tr><tr>
            <td class="black">162</td>
            <td>
</td>
          </tr><tr>
            <td class="black">163</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">164</td>
            <td> * For a given content it could not be serialized in the document.
</td>
          </tr><tr>
            <td class="black">165</td>
            <td> */
</td>
          </tr><tr>
            <td class="red">166</td>
            <td>case class CannotSerialize<span class="non">(override val what: String) extends SerializationException(what)
</span></td>
          </tr><tr>
            <td class="black">167</td>
            <td>
</td>
          </tr><tr>
            <td class="black">168</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">169</td>
            <td> * Result of trying to serialize a 1.1 ncname into a 1.0 document
</td>
          </tr><tr>
            <td class="black">170</td>
            <td> */
</td>
          </tr><tr>
            <td class="green">171</td>
            <td>case class IncompatibleQNameVersions(override val what: String) extends SerializationException(what)
</td>
          </tr><tr>
            <td class="black">172</td>
            <td>
</td>
          </tr><tr>
            <td class="black">173</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">174</td>
            <td> * Base implementation for a correct serializer using LSSerializer to provide escape character references.
</td>
          </tr><tr>
            <td class="black">175</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">176</td>
            <td> * Developers can override this directly implementing encF, or choose to override createSerializer to further change serialization behaviour
</td>
          </tr><tr>
            <td class="black">177</td>
            <td> */ 
</td>
          </tr><tr>
            <td class="black">178</td>
            <td><a id="Trait_scales_xml_LSSerializerFactoryBase"></a>trait LSSerializerFactoryBase extends SerializerFactory {
</td>
          </tr><tr>
            <td class="black">179</td>
            <td>  import javax.xml.parsers._
</td>
          </tr><tr>
            <td class="black">180</td>
            <td>  import org.w3c.dom._
</td>
          </tr><tr>
            <td class="black">181</td>
            <td>  import ls._
</td>
          </tr><tr>
            <td class="black">182</td>
            <td>
</td>
          </tr><tr>
            <td class="black">183</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">184</td>
            <td>   * Override to create the serialazer
</td>
          </tr><tr>
            <td class="black">185</td>
            <td>   */ 
</td>
          </tr><tr>
            <td class="green">186</td>
            <td><a id="Class_scales_xml_LSSerializerFactoryBase"></a>  def createSerializer( sdata: SerializerData, ndoc : org.w3c.dom.Document) : scales.xml.LSSerializer = new scales.xml.LSSerializer {
</td>
          </tr><tr>
            <td class="green">187</td>
            <td>          val data = sdata
</td>
          </tr><tr>
            <td class="green">188</td>
            <td>          val encMap = encF(sdata.encoding)
</td>
          </tr><tr>
            <td class="black">189</td>
            <td>          lazy val doc = ndoc
</td>
          </tr><tr>
            <td class="black">190</td>
            <td>          lazy val impl = doc.getImplementation().asInstanceOf[DOMImplementationLS]
</td>
          </tr><tr>
            <td class="black">191</td>
            <td>          lazy val lsout = impl.createLSOutput()
</td>
          </tr><tr>
            <td class="black">192</td>
            <td>          lazy val lsaout = impl.createLSOutput()
</td>
          </tr><tr>
            <td class="black">193</td>
            <td>          lazy val lss = impl.createLSSerializer()
</td>
          </tr><tr>
            <td class="black">194</td>
            <td>        }
</td>
          </tr><tr>
            <td class="black">195</td>
            <td>
</td>
          </tr><tr>
            <td class="black">196</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">197</td>
            <td>   * Can the content be encoded in a given charset
</td>
          </tr><tr>
            <td class="black">198</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">199</td>
            <td>  val encF: Charset =&gt; String =&gt; Option[Throwable]
</td>
          </tr><tr>
            <td class="black">200</td>
            <td>
</td>
          </tr><tr>
            <td class="black">201</td>
            <td>  def apply[R](thunk: Serializer =&gt; R)(sdata: SerializerData): R = {
</td>
          </tr><tr>
            <td class="green">202</td>
            <td>    DefaultDOMFactoryPool.parsers.loan { db =&gt;
</td>
          </tr><tr>
            <td class="green">203</td>
            <td>      val ndoc = db.newDocument()
</td>
          </tr><tr>
            <td class="green">204</td>
            <td>      ndoc.setXmlVersion(sdata.version.version)
</td>
          </tr><tr>
            <td class="black">205</td>
            <td>
</td>
          </tr><tr>
            <td class="green">206</td>
            <td>      thunk({
</td>
          </tr><tr>
            <td class="green">207</td>
            <td>        val s = createSerializer(sdata, ndoc)
</td>
          </tr><tr>
            <td class="green">208</td>
            <td>        s.lsout.setEncoding(sdata.encoding.displayName)
</td>
          </tr><tr>
            <td class="green">209</td>
            <td>        s.lsout.setCharacterStream(sdata.out)
</td>
          </tr><tr>
            <td class="green">210</td>
            <td>        s.lsaout.setEncoding(sdata.encoding.displayName)
</td>
          </tr><tr>
            <td class="black">211</td>
            <td>
</td>
          </tr><tr>
            <td class="green">212</td>
            <td>        val dc = s.lss.getDomConfig // got to be the lss, as the xalan impl is unrelated 
</td>
          </tr><tr>
            <td class="black">213</td>
            <td>        //println(&quot;Configured with LSSerializer &quot; + s.lss.getClass.getName)
</td>
          </tr><tr>
            <td class="black">214</td>
            <td>        //val xs = new org.apache.xml.serializer.dom3.LSSerializerImpl
</td>
          </tr><tr>
            <td class="black">215</td>
            <td>        // if the user wants to add a cdata then we shouldn't split it, but &quot;throw&quot;
</td>
          </tr><tr>
            <td class="black">216</td>
            <td>        // NOTE that no implementation does this for ä and only for ]]&gt;
</td>
          </tr><tr>
            <td class="green">217</td>
            <td>        dc.setParameter(&quot;split-cdata-sections&quot;, false)
</td>
          </tr><tr>
            <td class="green">218</td>
            <td>        dc.setParameter(&quot;well-formed&quot;, true)
</td>
          </tr><tr>
            <td class="green">219</td>
            <td>        dc.setParameter(&quot;xml-declaration&quot;, false)
</td>
          </tr><tr>
            <td class="black">220</td>
            <td>
</td>
          </tr><tr>
            <td class="green">221</td>
            <td>        s
</td>
          </tr><tr>
            <td class="black">222</td>
            <td>      })
</td>
          </tr><tr>
            <td class="black">223</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">224</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">225</td>
            <td>
</td>
          </tr><tr>
            <td class="black">226</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">227</td>
            <td>
</td>
          </tr><tr>
            <td class="black">228</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">229</td>
            <td> * XHTML serialization extra touches
</td>
          </tr><tr>
            <td class="black">230</td>
            <td> */ 
</td>
          </tr><tr>
            <td class="black">231</td>
            <td><a id="Object_scales_xml_LSSerializerFactoryXHTML"></a>object LSSerializerFactoryXHTML extends LSSerializerConcurrentCacheFactoryXHTML {
</td>
          </tr><tr>
            <td class="black">232</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">233</td>
            <td>
</td>
          </tr><tr>
            <td class="black">234</td>
            <td><a id="Trait_scales_xml_LSSerializerConcurrentCacheFactoryXHTML"></a>trait LSSerializerConcurrentCacheFactoryXHTML extends LSSerializerConcurrentCacheFactory {
</td>
          </tr><tr>
            <td class="black">235</td>
            <td>  import org.w3c.dom._
</td>
          </tr><tr>
            <td class="black">236</td>
            <td>  import ls._
</td>
          </tr><tr>
            <td class="black">237</td>
            <td>
</td>
          </tr><tr>
            <td class="black">238</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">239</td>
            <td>   * Override to create the serialazer
</td>
          </tr><tr>
            <td class="black">240</td>
            <td>   */ 
</td>
          </tr><tr>
            <td class="red">241</td>
            <td><a id="Class_scales_xml_LSSerializerConcurrentCacheFactoryXHTML"></a>  override def createSerializer( sdata: SerializerData, ndoc : org.w3c.dom.Document) : scales.xml.LSSerializer = <span class="non">new scales.xml.XHTMLLSSerializer {
</span></td>
          </tr><tr>
            <td class="red">242</td>
            <td>          val data = <span class="non">sdata
</span></td>
          </tr><tr>
            <td class="red">243</td>
            <td>          val encMap = <span class="non">encF(sdata.encoding)
</span></td>
          </tr><tr>
            <td class="black">244</td>
            <td>          lazy val doc = ndoc
</td>
          </tr><tr>
            <td class="black">245</td>
            <td>          lazy val impl = doc.getImplementation().asInstanceOf[DOMImplementationLS]
</td>
          </tr><tr>
            <td class="black">246</td>
            <td>          lazy val lsout = impl.createLSOutput()
</td>
          </tr><tr>
            <td class="black">247</td>
            <td>          lazy val lsaout = impl.createLSOutput()
</td>
          </tr><tr>
            <td class="black">248</td>
            <td>          lazy val lss = impl.createLSSerializer()
</td>
          </tr><tr>
            <td class="black">249</td>
            <td>        }
</td>
          </tr><tr>
            <td class="black">250</td>
            <td>
</td>
          </tr><tr>
            <td class="black">251</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">252</td>
            <td>
</td>
          </tr><tr>
            <td class="black">253</td>
            <td>
</td>
          </tr><tr>
            <td class="black">254</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">255</td>
            <td> * Default implmementation of serialization
</td>
          </tr><tr>
            <td class="black">256</td>
            <td> */ 
</td>
          </tr><tr>
            <td class="black">257</td>
            <td><a id="Object_scales_xml_LSSerializerFactory"></a>object LSSerializerFactory extends LSSerializerConcurrentCacheFactory {
</td>
          </tr><tr>
            <td class="black">258</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">259</td>
            <td>
</td>
          </tr><tr>
            <td class="black">260</td>
            <td><a id="Trait_scales_xml_LSSerializerConcurrentCacheFactory"></a>trait LSSerializerConcurrentCacheFactory extends LSSerializerFactoryBase {
</td>
          </tr><tr>
            <td class="black">261</td>
            <td>  import java.util.concurrent.ConcurrentHashMap
</td>
          </tr><tr>
            <td class="black">262</td>
            <td>
</td>
          </tr><tr>
            <td class="black">263</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">264</td>
            <td>   * On the assumption that a given apps qname population is larger than that of its possible encodings.
</td>
          </tr><tr>
            <td class="black">265</td>
            <td>   */
</td>
          </tr><tr>
            <td class="green">266</td>
            <td>  val globalEncMap = new ConcurrentHashMap[String, ConcurrentHashMap[Charset, Once[Option[Throwable]]]]
</td>
          </tr><tr>
            <td class="black">267</td>
            <td>
</td>
          </tr><tr>
            <td class="black">268</td>
            <td>  val encF = { encoding: Charset =&gt;
</td>
          </tr><tr>
            <td class="green">269</td>
            <td>    val encoder = encoding.newEncoder
</td>
          </tr><tr>
            <td class="black">270</td>
            <td>
</td>
          </tr><tr>
            <td class="black">271</td>
            <td>    /**
</td>
          </tr><tr>
            <td class="black">272</td>
            <td>     * Perhaps silly optimisation given a bug about it but worth trying
</td>
          </tr><tr>
            <td class="black">273</td>
            <td>     *
</td>
          </tr><tr>
            <td class="black">274</td>
            <td>     * If the charset contains utf8 then its able to support all unicode characters that utf8 can.  Wierdly I would also have expected utf8 to contain32 as it contains utf16 - must verify.
</td>
          </tr><tr>
            <td class="black">275</td>
            <td>     */
</td>
          </tr><tr>
            <td class="green">276</td>
            <td>    if (encoding.contains(defaultCharset)) { s: String =&gt; None }
</td>
          </tr><tr>
            <td class="black">277</td>
            <td>    else { s: String =&gt;
</td>
          </tr><tr>
            <td class="black">278</td>
            <td>
</td>
          </tr><tr>
            <td class="green">279</td>
            <td>      calcOnce(encoding, value(s, globalEncMap)(new ConcurrentHashMap[Charset, Once[Option[Throwable]]]())) {
</td>
          </tr><tr>
            <td class="green">280</td>
            <td>        if (encoder.canEncode(s))
</td>
          </tr><tr>
            <td class="green">281</td>
            <td>          None // it can do it
</td>
          </tr><tr>
            <td class="black">282</td>
            <td>        else
</td>
          </tr><tr>
            <td class="green">283</td>
            <td>          Some(InvalidCharacterInMarkup(s))
</td>
          </tr><tr>
            <td class="black">284</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">285</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">286</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">287</td>
            <td>
</td>
          </tr><tr>
            <td class="black">288</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">289</td>
            <td>
</td>
          </tr><tr>
            <td class="black">290</td>
            <td><a id="Object_scales_xml_LSSerializerNoCacheFactory"></a>object LSSerializerNoCacheFactory extends LSSerializerNoCacheFactoryT {
</td>
          </tr><tr>
            <td class="black">291</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">292</td>
            <td>
</td>
          </tr><tr>
            <td class="black">293</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">294</td>
            <td> * This variety does not use a thread safe global cache, use when your data
</td>
          </tr><tr>
            <td class="black">295</td>
            <td> * is progressivly radically different for each run.
</td>
          </tr><tr>
            <td class="black">296</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">297</td>
            <td> * If you don't like this scheme either simply implement LSSerializerFactoryBase with your own caching needs.
</td>
          </tr><tr>
            <td class="black">298</td>
            <td> */
</td>
          </tr><tr>
            <td class="black">299</td>
            <td><a id="Trait_scales_xml_LSSerializerNoCacheFactoryT"></a>trait LSSerializerNoCacheFactoryT extends LSSerializerFactoryBase {
</td>
          </tr><tr>
            <td class="black">300</td>
            <td>  import java.util.HashMap
</td>
          </tr><tr>
            <td class="black">301</td>
            <td>
</td>
          </tr><tr>
            <td class="black">302</td>
            <td>  val encF = { encoding: Charset =&gt;
</td>
          </tr><tr>
            <td class="red">303</td>
            <td>    val encoder = <span class="non">encoding.newEncoder
</span></td>
          </tr><tr>
            <td class="red">304</td>
            <td>    val map = <span class="non">new HashMap[String, Option[Throwable]]
</span></td>
          </tr><tr>
            <td class="black">305</td>
            <td>
</td>
          </tr><tr>
            <td class="black">306</td>
            <td>    /**
</td>
          </tr><tr>
            <td class="black">307</td>
            <td>     * See the above explanation for this
</td>
          </tr><tr>
            <td class="black">308</td>
            <td>     */
</td>
          </tr><tr>
            <td class="red">309</td>
            <td>    if (<span class="non">encoding.contains(defaultCharset)) { s: String =&gt; None }
</span></td>
          </tr><tr>
            <td class="black">310</td>
            <td>    else { s: String =&gt;
</td>
          </tr><tr>
            <td class="black">311</td>
            <td>
</td>
          </tr><tr>
            <td class="red">312</td>
            <td>      var r = <span class="non">map.get(s)
</span></td>
          </tr><tr>
            <td class="red">313</td>
            <td>      if (<span class="non">r eq null) {
</span></td>
          </tr><tr>
            <td class="red">314</td>
            <td>        <span class="non">r = if (encoder.canEncode(s))
</span></td>
          </tr><tr>
            <td class="red">315</td>
            <td>          <span class="non">None // it can do it
</span></td>
          </tr><tr>
            <td class="black">316</td>
            <td>        else
</td>
          </tr><tr>
            <td class="red">317</td>
            <td>          <span class="non">Some(InvalidCharacterInMarkup(s))
</span></td>
          </tr><tr>
            <td class="black">318</td>
            <td>
</td>
          </tr><tr>
            <td class="red">319</td>
            <td>        <span class="non">map.put(s, r)
</span></td>
          </tr><tr>
            <td class="black">320</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">321</td>
            <td>
</td>
          </tr><tr>
            <td class="red">322</td>
            <td>      <span class="non">r
</span></td>
          </tr><tr>
            <td class="black">323</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">324</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">325</td>
            <td>
</td>
          </tr><tr>
            <td class="black">326</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">327</td>
            <td>
</td>
          </tr><tr>
            <td class="black">328</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">329</td>
            <td> * Adds an extra space after an empty element
</td>
          </tr><tr>
            <td class="black">330</td>
            <td> */ 
</td>
          </tr><tr>
            <td class="black">331</td>
            <td><a id="Trait_scales_xml_XHTMLLSSerializer"></a>trait XHTMLLSSerializer extends LSSerializer {
</td>
          </tr><tr>
            <td class="black">332</td>
            <td>  import data._
</td>
          </tr><tr>
            <td class="black">333</td>
            <td>
</td>
          </tr><tr>
            <td class="black">334</td>
            <td>  override def emptyElement(qName: QName, attributes: Traversable[Attribute], namespaces: Map[String, String], declareDefaultNS: Option[String], path: List[QName]): Option[Throwable] =
</td>
          </tr><tr>
            <td class="red">335</td>
            <td>    <span class="non">doElem(qName, attributes, namespaces, declareDefaultNS) orElse {
</span></td>
          </tr><tr>
            <td class="red">336</td>
            <td>      <span class="non">out.append(&quot; /&gt;&quot;)
</span></td>
          </tr><tr>
            <td class="red">337</td>
            <td>      <span class="non">None
</span></td>
          </tr><tr>
            <td class="black">338</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">339</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">340</td>
            <td>
</td>
          </tr><tr>
            <td class="black">341</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">342</td>
            <td> * Default serializer, correctness first.  Uses the LSSerializer present in each DOM L3 impl.  XmlItems are always serialized with the LS, elements and attributes are however for speed reasons, verified for encoding once per QName; the attribute values themselves are written via Text nodes and LS.
</td>
          </tr><tr>
            <td class="black">343</td>
            <td> */
</td>
          </tr><tr>
            <td class="black">344</td>
            <td><a id="Trait_scales_xml_LSSerializer"></a>trait LSSerializer extends Serializer {
</td>
          </tr><tr>
            <td class="black">345</td>
            <td>  import javax.xml.parsers._
</td>
          </tr><tr>
            <td class="black">346</td>
            <td>  import org.w3c.dom._
</td>
          </tr><tr>
            <td class="black">347</td>
            <td>  import ls._
</td>
          </tr><tr>
            <td class="black">348</td>
            <td>  import java.util.concurrent.ConcurrentHashMap
</td>
          </tr><tr>
            <td class="black">349</td>
            <td>
</td>
          </tr><tr>
            <td class="black">350</td>
            <td>  val data: SerializerData
</td>
          </tr><tr>
            <td class="black">351</td>
            <td>  import data._
</td>
          </tr><tr>
            <td class="black">352</td>
            <td>
</td>
          </tr><tr>
            <td class="black">353</td>
            <td>  val doc: Document
</td>
          </tr><tr>
            <td class="black">354</td>
            <td>  val impl: DOMImplementationLS
</td>
          </tr><tr>
            <td class="black">355</td>
            <td>  val lsout: LSOutput
</td>
          </tr><tr>
            <td class="black">356</td>
            <td>  val lss: ls.LSSerializer
</td>
          </tr><tr>
            <td class="black">357</td>
            <td>
</td>
          </tr><tr>
            <td class="black">358</td>
            <td>  val lsaout: LSOutput
</td>
          </tr><tr>
            <td class="black">359</td>
            <td>
</td>
          </tr><tr>
            <td class="black">360</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">361</td>
            <td>   * Can the ncName be mapped for a given encoding
</td>
          </tr><tr>
            <td class="black">362</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">363</td>
            <td>  val encMap: String =&gt; Option[Throwable]
</td>
          </tr><tr>
            <td class="black">364</td>
            <td>
</td>
          </tr><tr>
            <td class="green">365</td>
            <td>  lazy val textNode = doc.createTextNode(&quot;&quot;)
</td>
          </tr><tr>
            <td class="black">366</td>
            <td>
</td>
          </tr><tr>
            <td class="green">367</td>
            <td>  lazy val encoder = encoding.newEncoder()
</td>
          </tr><tr>
            <td class="black">368</td>
            <td>
</td>
          </tr><tr>
            <td class="black">369</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">370</td>
            <td>   * See default SF for logic on this, however faulty :-)
</td>
          </tr><tr>
            <td class="black">371</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">372</td>
            <td>  lazy val canEncode =
</td>
          </tr><tr>
            <td class="yellow">373</td>
            <td>    if (encoding.contains(defaultCharset)) { s: String =&gt; <span class="non">true }
</span></td>
          </tr><tr>
            <td class="green">374</td>
            <td>    else { s: String =&gt; encoder.canEncode(s) }
</td>
          </tr><tr>
            <td class="black">375</td>
            <td>
</td>
          </tr><tr>
            <td class="black">376</td>
            <td>  def ct(t: =&gt; Boolean, s: =&gt; String): Option[Throwable] = {
</td>
          </tr><tr>
            <td class="black">377</td>
            <td>    try {
</td>
          </tr><tr>
            <td class="green">378</td>
            <td>      if (t)
</td>
          </tr><tr>
            <td class="green">379</td>
            <td>        None
</td>
          </tr><tr>
            <td class="black">380</td>
            <td>      else
</td>
          </tr><tr>
            <td class="red">381</td>
            <td>        <span class="non">Some(CannotSerialize(s))
</span></td>
          </tr><tr>
            <td class="black">382</td>
            <td>    } catch {
</td>
          </tr><tr>
            <td class="red">383</td>
            <td>      case t: Throwable =&gt; <span class="non">Some(t)
</span></td>
          </tr><tr>
            <td class="black">384</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">385</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">386</td>
            <td>
</td>
          </tr><tr>
            <td class="black">387</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">388</td>
            <td>   * Performs the actual write for Comments/CData/PI, due to LSSerializer issues this function is seperated for easy overriding, should anyone really trust their DOM/JAXP versions.
</td>
          </tr><tr>
            <td class="black">389</td>
            <td>   *
</td>
          </tr><tr>
            <td class="black">390</td>
            <td>   * For this method to be called the encoding has already been verified.
</td>
          </tr><tr>
            <td class="black">391</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">392</td>
            <td>  def writeNonText(item: XmlItem, path: List[QName]): Option[Throwable] =
</td>
          </tr><tr>
            <td class="green">393</td>
            <td>    SerializerHelpers.item(out, item, path)
</td>
          </tr><tr>
            <td class="black">394</td>
            <td>
</td>
          </tr><tr>
            <td class="black">395</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">396</td>
            <td>   * LSSerializer in 6_24 is garbage, but the xalan one isn't much better.  jre uses hex, xalan numberic character refs.  And jre is totally useless for cdata, writing no end part, both ignore the split-cdata-sections option when escaping, choosing to split, I assume this is only being done for character refs but follows the DOMConfiguration (instead of the load and save spec) for end sequence splitting.
</td>
          </tr><tr>
            <td class="black">397</td>
            <td>   *
</td>
          </tr><tr>
            <td class="black">398</td>
            <td>   * As such there only seems to be one safe way to handle this:
</td>
          </tr><tr>
            <td class="black">399</td>
            <td>   *   # Use the encoder to check if a CData or Comment can be written without splitting, throw if it can't.
</td>
          </tr><tr>
            <td class="black">400</td>
            <td>   *   # Write the start and end CData directly
</td>
          </tr><tr>
            <td class="black">401</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">402</td>
            <td>  def item(item: XmlItem, path: List[QName]): Option[Throwable] = {
</td>
          </tr><tr>
            <td class="green">403</td>
            <td>    val canEncodeI: Option[Throwable] = item match {
</td>
          </tr><tr>
            <td class="black">404</td>
            <td>      case x: scales.xml.Text =&gt;
</td>
          </tr><tr>
            <td class="green">405</td>
            <td>        None // never a problem
</td>
          </tr><tr>
            <td class="black">406</td>
            <td>      case x: CData =&gt;
</td>
          </tr><tr>
            <td class="green">407</td>
            <td>        if (canEncode(item.value))
</td>
          </tr><tr>
            <td class="green">408</td>
            <td>          None
</td>
          </tr><tr>
            <td class="black">409</td>
            <td>        else
</td>
          </tr><tr>
            <td class="green">410</td>
            <td>          Some(CDataCannotBeEncoded(item.value))
</td>
          </tr><tr>
            <td class="black">411</td>
            <td>      case x: scales.xml.Comment =&gt;
</td>
          </tr><tr>
            <td class="green">412</td>
            <td>        if (canEncode(item.value))
</td>
          </tr><tr>
            <td class="green">413</td>
            <td>          None
</td>
          </tr><tr>
            <td class="black">414</td>
            <td>        else
</td>
          </tr><tr>
            <td class="green">415</td>
            <td>          Some(CommentCannotBeEncoded(item.value))
</td>
          </tr><tr>
            <td class="black">416</td>
            <td>      case x: scales.xml.PI =&gt;
</td>
          </tr><tr>
            <td class="green">417</td>
            <td>        if (canEncode(x.value) &amp;&amp; canEncode(x.target))
</td>
          </tr><tr>
            <td class="green">418</td>
            <td>          None
</td>
          </tr><tr>
            <td class="black">419</td>
            <td>        else
</td>
          </tr><tr>
            <td class="red">420</td>
            <td>          <span class="non">Some(PICannotBeEncoded(&quot;Target: &quot; + x.target + &quot; value: &quot; + x.value))
</span></td>
          </tr><tr>
            <td class="black">421</td>
            <td>    }
</td>
          </tr><tr>
            <td class="green">422</td>
            <td>    canEncodeI orElse { // its serializeable, without cdata breaks
</td>
          </tr><tr>
            <td class="black">423</td>
            <td>
</td>
          </tr><tr>
            <td class="green">424</td>
            <td>      item match {
</td>
          </tr><tr>
            <td class="black">425</td>
            <td>        case x: scales.xml.Text =&gt;
</td>
          </tr><tr>
            <td class="green">426</td>
            <td>          textNode.setNodeValue(item.value) // twice for pi's but I'm not going to work around them
</td>
          </tr><tr>
            <td class="green">427</td>
            <td>          ct(lss.write(textNode, lsout),
</td>
          </tr><tr>
            <td class="black">428</td>
            <td>            {
</td>
          </tr><tr>
            <td class="red">429</td>
            <td>              val str = <span class="non">new java.io.StringWriter();
</span></td>
          </tr><tr>
            <td class="red">430</td>
            <td>              <span class="non">SerializerHelpers.item(str, item, path)
</span></td>
          </tr><tr>
            <td class="red">431</td>
            <td>              <span class="non">str.toString
</span></td>
          </tr><tr>
            <td class="black">432</td>
            <td>            })
</td>
          </tr><tr>
            <td class="black">433</td>
            <td>        case _ =&gt;
</td>
          </tr><tr>
            <td class="green">434</td>
            <td>          writeNonText(item, path)
</td>
          </tr><tr>
            <td class="black">435</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">436</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">437</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">438</td>
            <td>
</td>
          </tr><tr>
            <td class="black">439</td>
            <td>  def writeAttr(before: =&gt; String, toCt: =&gt; String, after: =&gt; String) =
</td>
          </tr><tr>
            <td class="green">440</td>
            <td>    ct({
</td>
          </tr><tr>
            <td class="green">441</td>
            <td>      out.append(before)
</td>
          </tr><tr>
            <td class="black">442</td>
            <td>      // every other escape takes place
</td>
          </tr><tr>
            <td class="black">443</td>
            <td>      // 
</td>
          </tr><tr>
            <td class="green">444</td>
            <td>      textNode.setNodeValue(toCt)
</td>
          </tr><tr>
            <td class="green">445</td>
            <td>      val str = new java.io.StringWriter();
</td>
          </tr><tr>
            <td class="green">446</td>
            <td>      lsaout.setCharacterStream(str)
</td>
          </tr><tr>
            <td class="green">447</td>
            <td>      val r = lss.write(textNode, lsaout)
</td>
          </tr><tr>
            <td class="green">448</td>
            <td>      lsaout.setCharacterStream(null) // let it be collected
</td>
          </tr><tr>
            <td class="green">449</td>
            <td>      if (r) {
</td>
          </tr><tr>
            <td class="green">450</td>
            <td>        out.append(str.toString.replaceAll(&quot;\&quot;&quot;, &quot;&amp;quot;&quot;))
</td>
          </tr><tr>
            <td class="green">451</td>
            <td>        out.append(after)
</td>
          </tr><tr>
            <td class="black">452</td>
            <td>      }
</td>
          </tr><tr>
            <td class="green">453</td>
            <td>      r
</td>
          </tr><tr>
            <td class="black">454</td>
            <td>    }, before + toCt + after)
</td>
          </tr><tr>
            <td class="black">455</td>
            <td>
</td>
          </tr><tr>
            <td class="black">456</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">457</td>
            <td>   * Override this to order the attributes.
</td>
          </tr><tr>
            <td class="black">458</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">459</td>
            <td>  def doElem(qName: QName, attribs: Traversable[Attribute], ns: Map[String, String], declareDefaultNS: Option[String]): Option[Throwable] = {
</td>
          </tr><tr>
            <td class="black">460</td>
            <td>
</td>
          </tr><tr>
            <td class="black">461</td>
            <td>    {
</td>
          </tr><tr>
            <td class="green">462</td>
            <td>      if (qName.qNameVersion == Xml11 &amp;&amp; version == Xml10)
</td>
          </tr><tr>
            <td class="green">463</td>
            <td>        Some(IncompatibleQNameVersions(qName.qName))
</td>
          </tr><tr>
            <td class="black">464</td>
            <td>      else
</td>
          </tr><tr>
            <td class="green">465</td>
            <td>        None
</td>
          </tr><tr>
            <td class="black">466</td>
            <td>    } orElse {
</td>
          </tr><tr>
            <td class="black">467</td>
            <td>      // we don't have to encode it, just check it can be encoded, the writer will do the rest for markup
</td>
          </tr><tr>
            <td class="black">468</td>
            <td>      encMap(qName.qName)
</td>
          </tr><tr>
            <td class="black">469</td>
            <td>    } orElse {
</td>
          </tr><tr>
            <td class="black">470</td>
            <td>
</td>
          </tr><tr>
            <td class="green">471</td>
            <td>      out.append(&quot;&lt;&quot; + qName.qName)
</td>
          </tr><tr>
            <td class="green">472</td>
            <td>      None
</td>
          </tr><tr>
            <td class="black">473</td>
            <td>
</td>
          </tr><tr>
            <td class="black">474</td>
            <td>    } orElse {
</td>
          </tr><tr>
            <td class="black">475</td>
            <td>
</td>
          </tr><tr>
            <td class="black">476</td>
            <td>      declareDefaultNS.flatMap { dns =&gt;
</td>
          </tr><tr>
            <td class="green">477</td>
            <td>        writeAttr(&quot; xmlns=\&quot;&quot;, dns, &quot;\&quot;&quot;)
</td>
          </tr><tr>
            <td class="black">478</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">479</td>
            <td>    } orElse {
</td>
          </tr><tr>
            <td class="black">480</td>
            <td>
</td>
          </tr><tr>
            <td class="black">481</td>
            <td>      ns.foldLeft(None: Option[Throwable]) { (r, x) =&gt;
</td>
          </tr><tr>
            <td class="green">482</td>
            <td>        r orElse {
</td>
          </tr><tr>
            <td class="black">483</td>
            <td>          // check the prefix is valid
</td>
          </tr><tr>
            <td class="green">484</td>
            <td>          if (QNameCharUtils.validXmlPrefix(x._1)(version)) {
</td>
          </tr><tr>
            <td class="green">485</td>
            <td>            out.append(&quot; xmlns:&quot;)
</td>
          </tr><tr>
            <td class="green">486</td>
            <td>            encMap(x._1) orElse
</td>
          </tr><tr>
            <td class="black">487</td>
            <td>              writeAttr(x._1 + &quot;=\&quot;&quot;, x._2, &quot;\&quot;&quot;)
</td>
          </tr><tr>
            <td class="black">488</td>
            <td>          } else
</td>
          </tr><tr>
            <td class="red">489</td>
            <td>            <span class="non">Some(IncompatibleQNameVersions(x._1))
</span></td>
          </tr><tr>
            <td class="black">490</td>
            <td>        }
</td>
          </tr><tr>
            <td class="black">491</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">492</td>
            <td>
</td>
          </tr><tr>
            <td class="black">493</td>
            <td>    } orElse {
</td>
          </tr><tr>
            <td class="black">494</td>
            <td>
</td>
          </tr><tr>
            <td class="black">495</td>
            <td>      import ScalesXml._
</td>
          </tr><tr>
            <td class="black">496</td>
            <td>
</td>
          </tr><tr>
            <td class="green">497</td>
            <td>      attribs.foldLeft(None: Option[Throwable]) { (r, x) =&gt;
</td>
          </tr><tr>
            <td class="green">498</td>
            <td>        r orElse {
</td>
          </tr><tr>
            <td class="black">499</td>
            <td>          // is the name valid
</td>
          </tr><tr>
            <td class="green">500</td>
            <td>          if (qName.qNameVersion == Xml11 &amp;&amp; version == Xml10)
</td>
          </tr><tr>
            <td class="red">501</td>
            <td>            <span class="non">Some(IncompatibleQNameVersions(qName.qName))
</span></td>
          </tr><tr>
            <td class="black">502</td>
            <td>          else {
</td>
          </tr><tr>
            <td class="green">503</td>
            <td>            val n = x.name.qName
</td>
          </tr><tr>
            <td class="green">504</td>
            <td>            encMap(n) orElse
</td>
          </tr><tr>
            <td class="black">505</td>
            <td>              writeAttr(&quot; &quot; + n + &quot;=\&quot;&quot;, x.value, &quot;\&quot;&quot;)
</td>
          </tr><tr>
            <td class="black">506</td>
            <td>          }
</td>
          </tr><tr>
            <td class="black">507</td>
            <td>        }
</td>
          </tr><tr>
            <td class="black">508</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">509</td>
            <td>
</td>
          </tr><tr>
            <td class="black">510</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">511</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">512</td>
            <td>
</td>
          </tr><tr>
            <td class="black">513</td>
            <td>  def emptyElement(qName: QName, attributes: Traversable[Attribute], namespaces: Map[String, String], declareDefaultNS: Option[String], path: List[QName]): Option[Throwable] =
</td>
          </tr><tr>
            <td class="green">514</td>
            <td>    doElem(qName, attributes, namespaces, declareDefaultNS) orElse {
</td>
          </tr><tr>
            <td class="green">515</td>
            <td>      out.append(&quot;/&gt;&quot;)
</td>
          </tr><tr>
            <td class="green">516</td>
            <td>      None
</td>
          </tr><tr>
            <td class="black">517</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">518</td>
            <td>
</td>
          </tr><tr>
            <td class="black">519</td>
            <td>  def startElement(qName: QName, attributes: Traversable[Attribute], namespaces: Map[String, String], declareDefaultNS: Option[String], path: List[QName]): Option[Throwable] =
</td>
          </tr><tr>
            <td class="green">520</td>
            <td>    doElem(qName, attributes, namespaces, declareDefaultNS) orElse {
</td>
          </tr><tr>
            <td class="green">521</td>
            <td>      out.append(&quot;&gt;&quot;)
</td>
          </tr><tr>
            <td class="green">522</td>
            <td>      None
</td>
          </tr><tr>
            <td class="black">523</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">524</td>
            <td>
</td>
          </tr><tr>
            <td class="black">525</td>
            <td>  def endElement(qName: QName, path: List[QName]): Option[Throwable] = {
</td>
          </tr><tr>
            <td class="green">526</td>
            <td>    out.append(&quot;&lt;/&quot; + qName.qName + &quot;&gt;&quot;) // to get here it must be valid
</td>
          </tr><tr>
            <td class="green">527</td>
            <td>    None
</td>
          </tr><tr>
            <td class="black">528</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">529</td>
            <td>
</td>
          </tr><tr>
            <td class="green">530</td>
            <td>  def xmlDeclaration(encoding: Charset, version: XmlVersion): Option[Throwable] = SerializerHelpers.xmlDecl(out, encoding, version)
</td>
          </tr><tr>
            <td class="black">531</td>
            <td>
</td>
          </tr><tr>
            <td class="black">532</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">533</td>
            <td>
</td>
          </tr><tr>
            <td class="black">534</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">535</td>
            <td> * Defaults to correctness and checking everything
</td>
          </tr><tr>
            <td class="black">536</td>
            <td> * Possible approach to easily configuring some performance aspects
</td>
          </tr><tr>
            <td class="black">537</td>
            <td> * I.e. the are really sure that after the 100th time of sending the same
</td>
          </tr><tr>
            <td class="black">538</td>
            <td> * message template they don't need to verify the QNames again.
</td>
          </tr><tr>
            <td class="black">539</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">540</td>
            <td> * case class SerializationOptions(
</td>
          </tr><tr>
            <td class="black">541</td>
            <td> * checkCDataEncoding : Boolean = true,
</td>
          </tr><tr>
            <td class="black">542</td>
            <td> * checkCommentEncoding : Boolean = true,
</td>
          </tr><tr>
            <td class="black">543</td>
            <td> * checkPIEncoding : Boolean = true,
</td>
          </tr><tr>
            <td class="black">544</td>
            <td> * checkNSDeclPrefix : Boolean = true,
</td>
          </tr><tr>
            <td class="black">545</td>
            <td> * checkNSDeclPrefixEncoding : Boolean = true,
</td>
          </tr><tr>
            <td class="black">546</td>
            <td> * check
</td>
          </tr><tr>
            <td class="black">547</td>
            <td> * )
</td>
          </tr><tr>
            <td class="black">548</td>
            <td> */
</td>
          </tr><tr>
            <td class="black">549</td>
            <td>
</td>
          </tr><tr>
            <td class="black">550</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">551</td>
            <td> * This class represents state during a serialization
</td>
          </tr><tr>
            <td class="black">552</td>
            <td> */
</td>
          </tr><tr>
            <td class="green">553</td>
            <td>case class XmlOutput(data: SerializerData,
</td>
          </tr><tr>
            <td class="black">554</td>
            <td>  currentMappings: Stack[Map[String, String]] = Stack[Map[String, String]]().push(
</td>
          </tr><tr>
            <td class="black">555</td>
            <td>    Map[String, String]() + (&quot;&quot; -&gt; &quot;&quot;) // default namespace 
</td>
          </tr><tr>
            <td class="black">556</td>
            <td>    ), path: List[QName] = List())(implicit serializerFI: SerializerFactory) {
</td>
          </tr><tr>
            <td class="green">557</td>
            <td>  val serializerF = serializerFI
</td>
          </tr><tr>
            <td class="black">558</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">559</td>
            <td>
</td>
          </tr><tr>
            <td class="black">560</td>
            <td>trait XmlPrinterImplicits {
</td>
          </tr><tr>
            <td class="black">561</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">562</td>
            <td>   * Import to _ and replace with your own SerializerFactory if desired
</td>
          </tr><tr>
            <td class="black">563</td>
            <td>   */
</td>
          </tr><tr>
            <td class="green">564</td>
            <td>  implicit val defaultSerializerFactory = LSSerializerFactory
</td>
          </tr><tr>
            <td class="black">565</td>
            <td>
</td>
          </tr><tr>
            <td class="red">566</td>
            <td>  case class DeclarationConverter<span class="non">(decl: Declaration) {
</span></td>
          </tr><tr>
            <td class="red">567</td>
            <td>    def withWriter(out: Writer): SerializerData = <span class="non">scales.xml.withWriter(decl, out)
</span></td>
          </tr><tr>
            <td class="black">568</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">569</td>
            <td>
</td>
          </tr><tr>
            <td class="red">570</td>
            <td>  implicit def toWithWriter(decl: Declaration) = <span class="non">DeclarationConverter(decl)
</span></td>
          </tr><tr>
            <td class="black">571</td>
            <td>
</td>
          </tr><tr>
            <td class="black">572</td>
            <td>  import ScalesXml._
</td>
          </tr><tr>
            <td class="black">573</td>
            <td>
</td>
          </tr><tr>
            <td class="black">574</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">575</td>
            <td>   * The following implicits are essential so I'm keeping them here
</td>
          </tr><tr>
            <td class="black">576</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">577</td>
            <td>
</td>
          </tr><tr>
            <td class="black">578</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">579</td>
            <td>   * Serializes an XmlTree
</td>
          </tr><tr>
            <td class="black">580</td>
            <td>   */
</td>
          </tr><tr>
            <td class="green">581</td>
            <td><a id="Class_scales_xml_XmlPrinterImplicits"></a>  implicit val treeSerializeable: SerializeableXml[XmlTree] = new SerializeableXml[XmlTree] {
</td>
          </tr><tr>
            <td class="black">582</td>
            <td>    def doc(it: XmlTree) = Doc(it)
</td>
          </tr><tr>
            <td class="black">583</td>
            <td>    def apply(it: XmlTree)(out: XmlOutput, serializer: Serializer): (XmlOutput, Option[Throwable]) =
</td>
          </tr><tr>
            <td class="black">584</td>
            <td>
</td>
          </tr><tr>
            <td class="black">585</td>
            <td>      fold[XmlItem, Elem, XCC, (XmlOutput, Option[Throwable])]((out, None)) { (iorsw, pair) =&gt;
</td>
          </tr><tr>
            <td class="black">586</td>
            <td>        val (output, y) = pair
</td>
          </tr><tr>
            <td class="black">587</td>
            <td>
</td>
          </tr><tr>
            <td class="black">588</td>
            <td>        if (y.isDefined) pair
</td>
          </tr><tr>
            <td class="black">589</td>
            <td>        else
</td>
          </tr><tr>
            <td class="black">590</td>
            <td>          iorsw match {
</td>
          </tr><tr>
            <td class="black">591</td>
            <td>            case Left(item) =&gt; (output, serializer.item(item, output.path))
</td>
          </tr><tr>
            <td class="black">592</td>
            <td>            case Right(walk) =&gt;
</td>
          </tr><tr>
            <td class="black">593</td>
            <td>              val x = walk.section
</td>
          </tr><tr>
            <td class="black">594</td>
            <td>              if (!walk.hasChildren) {
</td>
          </tr><tr>
            <td class="black">595</td>
            <td>
</td>
          </tr><tr>
            <td class="black">596</td>
            <td>                // x.namespaces can't be used any further
</td>
          </tr><tr>
            <td class="black">597</td>
            <td>                val (mappings, (attribs, declMap, addDef)) = doElement(x, output)
</td>
          </tr><tr>
            <td class="black">598</td>
            <td>                (output, serializer.emptyElement(x.name, attribs, declMap, addDef, x.name :: output.path))
</td>
          </tr><tr>
            <td class="black">599</td>
            <td>              } else {
</td>
          </tr><tr>
            <td class="black">600</td>
            <td>                if (walk.isStart) {
</td>
          </tr><tr>
            <td class="black">601</td>
            <td>
</td>
          </tr><tr>
            <td class="black">602</td>
            <td>                  val npath = x.name :: output.path
</td>
          </tr><tr>
            <td class="black">603</td>
            <td>
</td>
          </tr><tr>
            <td class="black">604</td>
            <td>                  val (mappings, (attribs, declMap, addDef)) = doElement(x, output)
</td>
          </tr><tr>
            <td class="black">605</td>
            <td>
</td>
          </tr><tr>
            <td class="black">606</td>
            <td>                  (output.copy(currentMappings = output.currentMappings.push(mappings),
</td>
          </tr><tr>
            <td class="black">607</td>
            <td>                    path = npath),
</td>
          </tr><tr>
            <td class="black">608</td>
            <td>                    serializer.startElement(x.name, attribs, declMap, addDef, npath))
</td>
          </tr><tr>
            <td class="black">609</td>
            <td>                } else {
</td>
          </tr><tr>
            <td class="black">610</td>
            <td>                  // pop the last ones
</td>
          </tr><tr>
            <td class="black">611</td>
            <td>                  (output.copy(currentMappings = output.currentMappings.pop,
</td>
          </tr><tr>
            <td class="black">612</td>
            <td>                    path = output.path.tail), serializer.endElement(x.name, output.path))
</td>
          </tr><tr>
            <td class="black">613</td>
            <td>                }
</td>
          </tr><tr>
            <td class="black">614</td>
            <td>              }
</td>
          </tr><tr>
            <td class="black">615</td>
            <td>          }
</td>
          </tr><tr>
            <td class="black">616</td>
            <td>      }(it)
</td>
          </tr><tr>
            <td class="black">617</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">618</td>
            <td>
</td>
          </tr><tr>
            <td class="black">619</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">620</td>
            <td>   * Serializes a DslBuilder
</td>
          </tr><tr>
            <td class="black">621</td>
            <td>   */
</td>
          </tr><tr>
            <td class="green">622</td>
            <td>  implicit val builderSerializeable = new SerializeableXml[DslBuilder] {
</td>
          </tr><tr>
            <td class="black">623</td>
            <td>    def doc(it: DslBuilder) = Doc(it.toTree)
</td>
          </tr><tr>
            <td class="black">624</td>
            <td>    def apply(it: DslBuilder)(out: XmlOutput, serializer: Serializer): (XmlOutput, Option[Throwable]) = treeSerializeable(it.toTree)(out, serializer)
</td>
          </tr><tr>
            <td class="black">625</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">626</td>
            <td>
</td>
          </tr><tr>
            <td class="black">627</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">628</td>
            <td>   * Serializes a Doc (Wrapped XmlTree)
</td>
          </tr><tr>
            <td class="black">629</td>
            <td>   */
</td>
          </tr><tr>
            <td class="green">630</td>
            <td>  implicit val docSerializeable = new SerializeableXml[Doc] {
</td>
          </tr><tr>
            <td class="black">631</td>
            <td>    def doc(it: Doc) = it
</td>
          </tr><tr>
            <td class="black">632</td>
            <td>    def apply(it: Doc)(out: XmlOutput, serializer: Serializer): (XmlOutput, Option[Throwable]) = treeSerializeable(it.rootElem)(out, serializer)
</td>
          </tr><tr>
            <td class="black">633</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">634</td>
            <td>
</td>
          </tr><tr>
            <td class="black">635</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">636</td>
            <td>   * Serializes an Xml Stream
</td>
          </tr><tr>
            <td class="black">637</td>
            <td>   */
</td>
          </tr><tr>
            <td class="green">638</td>
            <td>  implicit val streamSerializeable: SerializeableXml[Iterator[PullType]] = new SerializeableXml[Iterator[PullType]] {
</td>
          </tr><tr>
            <td class="black">639</td>
            <td>
</td>
          </tr><tr>
            <td class="green">640</td>
            <td>    val dummy: Iterable[PullType] = List(Left(Elem(&quot;dummy&quot;l)))
</td>
          </tr><tr>
            <td class="black">641</td>
            <td>
</td>
          </tr><tr>
            <td class="black">642</td>
            <td>    def doc(it: Iterator[PullType]) = EmptyDoc()
</td>
          </tr><tr>
            <td class="black">643</td>
            <td>    def apply(it: Iterator[PullType])(out: XmlOutput, serializer: Serializer): (XmlOutput, Option[Throwable]) = {
</td>
          </tr><tr>
            <td class="black">644</td>
            <td>      // left of the sequence is our actual, 
</td>
          </tr><tr>
            <td class="black">645</td>
            <td>      val r = it.++(dummy.iterator).sliding(2).foldLeft((out, None: Option[Throwable], false)) { (cur, two) =&gt;
</td>
          </tr><tr>
            <td class="black">646</td>
            <td>        val (output, y, isEmpty) = cur
</td>
          </tr><tr>
            <td class="black">647</td>
            <td>        if (y.isDefined) cur
</td>
          </tr><tr>
            <td class="black">648</td>
            <td>        else {
</td>
          </tr><tr>
            <td class="black">649</td>
            <td>          val List(ev, next) = two.toList
</td>
          </tr><tr>
            <td class="black">650</td>
            <td>          ev match {
</td>
          </tr><tr>
            <td class="black">651</td>
            <td>            case Left(i: XmlItem) =&gt;
</td>
          </tr><tr>
            <td class="black">652</td>
            <td>              (output, serializer.item(i, output.path), false)
</td>
          </tr><tr>
            <td class="black">653</td>
            <td>            case Left(x: Elem) =&gt;
</td>
          </tr><tr>
            <td class="black">654</td>
            <td>              // if next is an end elem then its an empty
</td>
          </tr><tr>
            <td class="black">655</td>
            <td>              if (next.isRight) {
</td>
          </tr><tr>
            <td class="black">656</td>
            <td>
</td>
          </tr><tr>
            <td class="black">657</td>
            <td>                // x.namespaces can't be used any further
</td>
          </tr><tr>
            <td class="black">658</td>
            <td>                val (mappings, (attribs, declMap, addDef)) = doElement(x, output)
</td>
          </tr><tr>
            <td class="black">659</td>
            <td>                (output, serializer.emptyElement(x.name, attribs, declMap, addDef, x.name :: output.path), true) // let us know to ignore the next end
</td>
          </tr><tr>
            <td class="black">660</td>
            <td>              } else {
</td>
          </tr><tr>
            <td class="black">661</td>
            <td>                val npath = x.name :: output.path
</td>
          </tr><tr>
            <td class="black">662</td>
            <td>
</td>
          </tr><tr>
            <td class="black">663</td>
            <td>                val (mappings, (attribs, declMap, addDef)) = doElement(x, output)
</td>
          </tr><tr>
            <td class="black">664</td>
            <td>
</td>
          </tr><tr>
            <td class="black">665</td>
            <td>                (output.copy(currentMappings = output.currentMappings.push(mappings), path = npath),
</td>
          </tr><tr>
            <td class="black">666</td>
            <td>                  serializer.startElement(x.name, attribs, declMap, addDef, npath), false)
</td>
          </tr><tr>
            <td class="black">667</td>
            <td>              }
</td>
          </tr><tr>
            <td class="black">668</td>
            <td>            case Right(endElem) =&gt;
</td>
          </tr><tr>
            <td class="black">669</td>
            <td>              if (isEmpty)
</td>
          </tr><tr>
            <td class="black">670</td>
            <td>                (output, None, false)
</td>
          </tr><tr>
            <td class="black">671</td>
            <td>              else
</td>
          </tr><tr>
            <td class="black">672</td>
            <td>                // pop the last ones
</td>
          </tr><tr>
            <td class="black">673</td>
            <td>                (output.copy(currentMappings = output.currentMappings.pop,
</td>
          </tr><tr>
            <td class="black">674</td>
            <td>                  path = output.path.tail), serializer.endElement(endElem.name, output.path), false)
</td>
          </tr><tr>
            <td class="black">675</td>
            <td>
</td>
          </tr><tr>
            <td class="black">676</td>
            <td>          }
</td>
          </tr><tr>
            <td class="black">677</td>
            <td>        }
</td>
          </tr><tr>
            <td class="black">678</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">679</td>
            <td>      (r._1, r._2)
</td>
          </tr><tr>
            <td class="black">680</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">681</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">682</td>
            <td>
</td>
          </tr><tr>
            <td class="black">683</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">684</td>
            <td>   * Serializes an XmlPull
</td>
          </tr><tr>
            <td class="black">685</td>
            <td>   */
</td>
          </tr><tr>
            <td class="green">686</td>
            <td>  implicit val pullCloseableOnlySerializeable: SerializeableXml[CloseablePull] = new SerializeableXml[CloseablePull] {
</td>
          </tr><tr>
            <td class="black">687</td>
            <td>    def doc(it: CloseablePull) = it
</td>
          </tr><tr>
            <td class="black">688</td>
            <td>    def apply(it: CloseablePull)(out: XmlOutput, serializer: Serializer): (XmlOutput, Option[Throwable]) = streamSerializeable(it)(out, serializer)
</td>
          </tr><tr>
            <td class="black">689</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">690</td>
            <td>
</td>
          </tr><tr>
            <td class="black">691</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">692</td>
            <td>   * Serializes an XmlPull Resource
</td>
          </tr><tr>
            <td class="black">693</td>
            <td>   */
</td>
          </tr><tr>
            <td class="green">694</td>
            <td>  implicit val pullOnlySerializeable: SerializeableXml[XmlPull] = new SerializeableXml[XmlPull] {
</td>
          </tr><tr>
            <td class="black">695</td>
            <td>    def doc(it: XmlPull) = it
</td>
          </tr><tr>
            <td class="black">696</td>
            <td>    def apply(it: XmlPull)(out: XmlOutput, serializer: Serializer): (XmlOutput, Option[Throwable]) = streamSerializeable(it)(out, serializer)
</td>
          </tr><tr>
            <td class="black">697</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">698</td>
            <td>
</td>
          </tr><tr>
            <td class="black">699</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">700</td>
            <td>   * Serializes an Iterator and DocLike
</td>
          </tr><tr>
            <td class="black">701</td>
            <td>   */
</td>
          </tr><tr>
            <td class="green">702</td>
            <td>  implicit val pullAndDocSerializeable: SerializeableXml[(Iterator[PullType], DocLike)] = new SerializeableXml[(Iterator[PullType], DocLike)] {
</td>
          </tr><tr>
            <td class="black">703</td>
            <td>    def doc(it: (Iterator[PullType], DocLike)) = it._2
</td>
          </tr><tr>
            <td class="black">704</td>
            <td>    def apply(it: (Iterator[PullType], DocLike))(out: XmlOutput, serializer: Serializer): (XmlOutput, Option[Throwable]) = streamSerializeable(it._1)(out, serializer)
</td>
          </tr><tr>
            <td class="black">705</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">706</td>
            <td>
</td>
          </tr><tr>
            <td class="black">707</td>
            <td>
</td>
          </tr><tr>
            <td class="black">708</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">709</td>
            <td>
</td>
          </tr><tr>
            <td class="black">710</td>
            <td><a id="Trait_scales_xml_XmlPrinter"></a>trait XmlPrinter {
</td>
          </tr><tr>
            <td class="black">711</td>
            <td>  import ScalesXml._
</td>
          </tr><tr>
            <td class="black">712</td>
            <td>
</td>
          </tr><tr>
            <td class="black">713</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">714</td>
            <td>   * a) add / replace in mappings
</td>
          </tr><tr>
            <td class="black">715</td>
            <td>   * b) add to declMap
</td>
          </tr><tr>
            <td class="black">716</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">717</td>
            <td>  def laddNS(entry: (String, String), mappings: Map[String, String], declMap: Map[String, String]) = {
</td>
          </tr><tr>
            <td class="green">718</td>
            <td>    val mapping = mappings.get(entry._1)
</td>
          </tr><tr>
            <td class="black">719</td>
            <td>
</td>
          </tr><tr>
            <td class="green">720</td>
            <td>    if (mapping.isDefined) {
</td>
          </tr><tr>
            <td class="black">721</td>
            <td>      // currently exists
</td>
          </tr><tr>
            <td class="green">722</td>
            <td>      if (mapping.get == entry._2) {
</td>
          </tr><tr>
            <td class="black">723</td>
            <td>        // do nothing
</td>
          </tr><tr>
            <td class="green">724</td>
            <td>        (mappings, declMap)
</td>
          </tr><tr>
            <td class="black">725</td>
            <td>      } else {
</td>
          </tr><tr>
            <td class="black">726</td>
            <td>        // replace and redefine
</td>
          </tr><tr>
            <td class="red">727</td>
            <td>        <span class="non">(mappings.updated(entry._1, entry._2),
</span></td>
          </tr><tr>
            <td class="black">728</td>
            <td>          declMap + entry)
</td>
          </tr><tr>
            <td class="black">729</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">730</td>
            <td>    } else {
</td>
          </tr><tr>
            <td class="black">731</td>
            <td>      // map and define
</td>
          </tr><tr>
            <td class="green">732</td>
            <td>      (mappings + (entry._1 -&gt; entry._2),
</td>
          </tr><tr>
            <td class="black">733</td>
            <td>        declMap + entry)
</td>
          </tr><tr>
            <td class="black">734</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">735</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">736</td>
            <td>
</td>
          </tr><tr>
            <td class="black">737</td>
            <td>  def doElement(x: Elem, out: XmlOutput) = {
</td>
          </tr><tr>
            <td class="black">738</td>
            <td>
</td>
          </tr><tr>
            <td class="black">739</td>
            <td>    // for each of our namespace mappings that differ (or are not there)
</td>
          </tr><tr>
            <td class="green">740</td>
            <td>    var (mappings, declMap) = x.namespaces.foldLeft( // (nsmappings start with top , what we declare)
</td>
          </tr><tr>
            <td class="black">741</td>
            <td>      (out.currentMappings.top, Map[String, String]()))((p, a) =&gt; laddNS(a, p._1, p._2))
</td>
          </tr><tr>
            <td class="black">742</td>
            <td>
</td>
          </tr><tr>
            <td class="black">743</td>
            <td>    // with our attributes
</td>
          </tr><tr>
            <td class="green">744</td>
            <td>    val t = x.attributes.foldLeft((mappings, declMap)) { (p, a) =&gt;
</td>
          </tr><tr>
            <td class="green">745</td>
            <td>      val e = a
</td>
          </tr><tr>
            <td class="green">746</td>
            <td>      if (e.prefix.isDefined)
</td>
          </tr><tr>
            <td class="green">747</td>
            <td>        laddNS((e.prefix.get, e.namespace.uri), p._1, p._2)
</td>
          </tr><tr>
            <td class="green">748</td>
            <td>      else p
</td>
          </tr><tr>
            <td class="black">749</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">750</td>
            <td>
</td>
          </tr><tr>
            <td class="green">751</td>
            <td>    mappings = t._1
</td>
          </tr><tr>
            <td class="green">752</td>
            <td>    declMap = t._2
</td>
          </tr><tr>
            <td class="black">753</td>
            <td>
</td>
          </tr><tr>
            <td class="black">754</td>
            <td>    // is this namespace declared?
</td>
          </tr><tr>
            <td class="black">755</td>
            <td>    val addedDefaultNS = {
</td>
          </tr><tr>
            <td class="green">756</td>
            <td>      val currentDefault = mappings(Default.namespace.uri)
</td>
          </tr><tr>
            <td class="green">757</td>
            <td>      if (x.name.namespace != Default.noNamespace) {
</td>
          </tr><tr>
            <td class="black">758</td>
            <td>        // is there a prefix?
</td>
          </tr><tr>
            <td class="green">759</td>
            <td>        if (x.name.prefix.isDefined) {
</td>
          </tr><tr>
            <td class="black">760</td>
            <td>          // then it is a normal laddNS
</td>
          </tr><tr>
            <td class="green">761</td>
            <td>          val (imappings, ideclMap) = laddNS((x.name.prefix.get, x.name.namespace.uri), mappings, declMap)
</td>
          </tr><tr>
            <td class="green">762</td>
            <td>          mappings = imappings
</td>
          </tr><tr>
            <td class="green">763</td>
            <td>          declMap = ideclMap
</td>
          </tr><tr>
            <td class="black">764</td>
            <td>          // push the current on again
</td>
          </tr><tr>
            <td class="green">765</td>
            <td>          false
</td>
          </tr><tr>
            <td class="black">766</td>
            <td>        } else {
</td>
          </tr><tr>
            <td class="black">767</td>
            <td>          // there will always be on as we don't remove only redefine.
</td>
          </tr><tr>
            <td class="black">768</td>
            <td>
</td>
          </tr><tr>
            <td class="black">769</td>
            <td>          // is it the current default namespace? 
</td>
          </tr><tr>
            <td class="green">770</td>
            <td>          if (currentDefault == x.name.namespace.uri) {
</td>
          </tr><tr>
            <td class="black">771</td>
            <td>            // keep the current
</td>
          </tr><tr>
            <td class="red">772</td>
            <td>            <span class="non">false
</span></td>
          </tr><tr>
            <td class="black">773</td>
            <td>          } else {
</td>
          </tr><tr>
            <td class="black">774</td>
            <td>            // must redefine it
</td>
          </tr><tr>
            <td class="black">775</td>
            <td>            // then the namespace has been badly declared as we have a conflict, but in order for at
</td>
          </tr><tr>
            <td class="black">776</td>
            <td>            // least this element to be valid we must remap it, log it?
</td>
          </tr><tr>
            <td class="green">777</td>
            <td>            mappings = mappings.updated(Default.namespace.uri, x.name.namespace.uri)
</td>
          </tr><tr>
            <td class="green">778</td>
            <td>            true
</td>
          </tr><tr>
            <td class="black">779</td>
            <td>          }
</td>
          </tr><tr>
            <td class="black">780</td>
            <td>        }
</td>
          </tr><tr>
            <td class="black">781</td>
            <td>      } else {
</td>
          </tr><tr>
            <td class="black">782</td>
            <td>        // then if the current default is not &quot;&quot; we must redeclare it
</td>
          </tr><tr>
            <td class="green">783</td>
            <td>        if (currentDefault == Default.noNamespace.uri) {
</td>
          </tr><tr>
            <td class="green">784</td>
            <td>          false
</td>
          </tr><tr>
            <td class="black">785</td>
            <td>        } else {
</td>
          </tr><tr>
            <td class="green">786</td>
            <td>          mappings = mappings.updated(Default.namespace.uri, Default.noNamespace.uri)
</td>
          </tr><tr>
            <td class="green">787</td>
            <td>          true
</td>
          </tr><tr>
            <td class="black">788</td>
            <td>        }
</td>
          </tr><tr>
            <td class="black">789</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">790</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">791</td>
            <td>
</td>
          </tr><tr>
            <td class="black">792</td>
            <td>    // don't render it here, mappings contains it
</td>
          </tr><tr>
            <td class="green">793</td>
            <td>    declMap = declMap - Default.namespace.uri
</td>
          </tr><tr>
            <td class="black">794</td>
            <td>
</td>
          </tr><tr>
            <td class="green">795</td>
            <td>    val default = x.namespaces.get(Default.namespace.uri)
</td>
          </tr><tr>
            <td class="black">796</td>
            <td>    val addDef =
</td>
          </tr><tr>
            <td class="green">797</td>
            <td>      if (addedDefaultNS || default.isDefined) {
</td>
          </tr><tr>
            <td class="black">798</td>
            <td>        // we have a new mapping, old one doesn't work anymore
</td>
          </tr><tr>
            <td class="green">799</td>
            <td>        Some(mappings(Default.namespace.uri))
</td>
          </tr><tr>
            <td class="black">800</td>
            <td>      } else
</td>
          </tr><tr>
            <td class="green">801</td>
            <td>        None
</td>
          </tr><tr>
            <td class="black">802</td>
            <td>
</td>
          </tr><tr>
            <td class="green">803</td>
            <td>    (mappings, (x.attributes, declMap, addDef))
</td>
          </tr><tr>
            <td class="black">804</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">805</td>
            <td>
</td>
          </tr><tr>
            <td class="red">806</td>
            <td>  def withWriter(decl: Declaration, out: Writer): SerializerData = <span class="non">SerializerData(out, decl.version, decl.encoding)
</span></td>
          </tr><tr>
            <td class="black">807</td>
            <td>
</td>
          </tr><tr>
            <td class="black">808</td>
            <td>  protected def serializeMisc(pout: XmlOutput, misc: Iterable[Misc], serializer: Serializer) = {
</td>
          </tr><tr>
            <td class="green">809</td>
            <td>    val opt = misc.foldLeft(None: Option[Throwable]) { (x, m) =&gt;
</td>
          </tr><tr>
            <td class="green">810</td>
            <td>      x.orElse {
</td>
          </tr><tr>
            <td class="green">811</td>
            <td>        serializer.item(m.fold[XmlItem](z =&gt; z, y =&gt; y), List())
</td>
          </tr><tr>
            <td class="black">812</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">813</td>
            <td>    }
</td>
          </tr><tr>
            <td class="green">814</td>
            <td>    (pout, opt)
</td>
          </tr><tr>
            <td class="black">815</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">816</td>
            <td>
</td>
          </tr><tr>
            <td class="black">817</td>
            <td>  def headerAndFooter(pout: XmlOutput, doc: DocLike)(serializerf: (XmlOutput, Serializer) =&gt; (XmlOutput, Option[Throwable])): Serializer =&gt; Option[Throwable] = { serializer =&gt;
</td>
          </tr><tr>
            <td class="black">818</td>
            <td>
</td>
          </tr><tr>
            <td class="green">819</td>
            <td>    var out = pout
</td>
          </tr><tr>
            <td class="black">820</td>
            <td>    // TODO DTD and header
</td>
          </tr><tr>
            <td class="green">821</td>
            <td>    serializer.xmlDeclaration(pout.data.encoding, pout.data.version).orElse {
</td>
          </tr><tr>
            <td class="black">822</td>
            <td>      // DTD
</td>
          </tr><tr>
            <td class="black">823</td>
            <td>      None
</td>
          </tr><tr>
            <td class="black">824</td>
            <td>    }.orElse {
</td>
          </tr><tr>
            <td class="green">825</td>
            <td>      val (pout, opt) = serializeMisc(out, doc.prolog.misc, serializer)
</td>
          </tr><tr>
            <td class="green">826</td>
            <td>      out = pout
</td>
          </tr><tr>
            <td class="green">827</td>
            <td>      opt
</td>
          </tr><tr>
            <td class="black">828</td>
            <td>    }.orElse {
</td>
          </tr><tr>
            <td class="green">829</td>
            <td>      val (pout, opt) = serializerf(out, serializer)
</td>
          </tr><tr>
            <td class="green">830</td>
            <td>      out = pout
</td>
          </tr><tr>
            <td class="green">831</td>
            <td>      opt
</td>
          </tr><tr>
            <td class="black">832</td>
            <td>    }.orElse {
</td>
          </tr><tr>
            <td class="green">833</td>
            <td>      val (pout, opt) = serializeMisc(out, doc.end.misc, serializer)
</td>
          </tr><tr>
            <td class="green">834</td>
            <td>      out = pout
</td>
          </tr><tr>
            <td class="green">835</td>
            <td>      opt
</td>
          </tr><tr>
            <td class="black">836</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">837</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">838</td>
            <td>
</td>
          </tr><tr>
            <td class="black">839</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">840</td>
            <td>   * Type class for choosing a serializing algo
</td>
          </tr><tr>
            <td class="black">841</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">842</td>
            <td><a id="Trait_scales_xml_XmlPrinter_SerializeableXml"></a>  trait SerializeableXml[T] {
</td>
          </tr><tr>
            <td class="black">843</td>
            <td>
</td>
          </tr><tr>
            <td class="black">844</td>
            <td>    def doc(it: T): DocLike
</td>
          </tr><tr>
            <td class="black">845</td>
            <td>
</td>
          </tr><tr>
            <td class="black">846</td>
            <td>    def apply(it: T)(out: XmlOutput, serializer: Serializer): (XmlOutput, Option[Throwable])
</td>
          </tr><tr>
            <td class="black">847</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">848</td>
            <td>
</td>
          </tr><tr>
            <td class="black">849</td>
            <td>  type CloseablePull = XmlPull with java.io.Closeable with scales.utils.IsClosed
</td>
          </tr><tr>
            <td class="black">850</td>
            <td>
</td>
          </tr><tr>
            <td class="black">851</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">852</td>
            <td>   * Placeholder - prefer serialize instead
</td>
          </tr><tr>
            <td class="black">853</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">854</td>
            <td>  def foldPrint[T: SerializeableXml](pout: XmlOutput)(it: T) =
</td>
          </tr><tr>
            <td class="green">855</td>
            <td>    serialize(pout)(it)
</td>
          </tr><tr>
            <td class="black">856</td>
            <td>
</td>
          </tr><tr>
            <td class="black">857</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">858</td>
            <td>   * Serializes items which can behave like xml.
</td>
          </tr><tr>
            <td class="black">859</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">860</td>
            <td>  def serialize[T: SerializeableXml](pout: XmlOutput)(it: T) =
</td>
          </tr><tr>
            <td class="green">861</td>
            <td>    pout.serializerF {
</td>
          </tr><tr>
            <td class="green">862</td>
            <td>      val sxml = implicitly[SerializeableXml[T]]
</td>
          </tr><tr>
            <td class="green">863</td>
            <td>      headerAndFooter(pout, sxml.doc(it))(
</td>
          </tr><tr>
            <td class="green">864</td>
            <td>        sxml(it))
</td>
          </tr><tr>
            <td class="black">865</td>
            <td>    }(pout.data)
</td>
          </tr><tr>
            <td class="black">866</td>
            <td>
</td>
          </tr><tr>
            <td class="black">867</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">868</td>
            <td>   * Prints to stdout, useful for testing etc  Will dump an error if one is found.
</td>
          </tr><tr>
            <td class="black">869</td>
            <td>   *
</td>
          </tr><tr>
            <td class="black">870</td>
            <td>   * Note it outputs to the vmDefaultCharset so it should always be C+P able
</td>
          </tr><tr>
            <td class="black">871</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">872</td>
            <td>  def printTree[T](xml: T)(implicit serf: SerializerFactory, sxml: SerializeableXml[T]): Unit = {
</td>
          </tr><tr>
            <td class="red">873</td>
            <td>    val out = <span class="non">new java.io.PrintWriter(System.out)
</span></td>
          </tr><tr>
            <td class="red">874</td>
            <td>    <span class="non">serialize(XmlOutput(SerializerData(out, encoding = vmDefaultCharset)))(xml) foreach { e =&gt;
</span></td>
          </tr><tr>
            <td class="red">875</td>
            <td>      <span class="non">out.println(&quot;Could not serialize got the following exception &quot; + e.getClass.getName + &quot; - &quot; + e.getMessage)
</span></td>
          </tr><tr>
            <td class="red">876</td>
            <td>      <span class="non">e.printStackTrace(out)
</span></td>
          </tr><tr>
            <td class="black">877</td>
            <td>    }
</td>
          </tr><tr>
            <td class="red">878</td>
            <td>    <span class="non">out.flush
</span></td>
          </tr><tr>
            <td class="black">879</td>
            <td>    //out.close, v bad to close stdout :-)
</td>
          </tr><tr>
            <td class="red">880</td>
            <td>    <span class="non">println()
</span></td>
          </tr><tr>
            <td class="black">881</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">882</td>
            <td>
</td>
          </tr><tr>
            <td class="black">883</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">884</td>
            <td>   * Returns a string version of the tree or throws
</td>
          </tr><tr>
            <td class="black">885</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">886</td>
            <td>  def asString[T](xml: T)(implicit serf: SerializerFactory, sxml: SerializeableXml[T]): String = {
</td>
          </tr><tr>
            <td class="green">887</td>
            <td>    val builder = new java.io.StringWriter()
</td>
          </tr><tr>
            <td class="green">888</td>
            <td>    foldPrint(XmlOutput(SerializerData(builder)))(xml) foreach {
</td>
          </tr><tr>
            <td class="red">889</td>
            <td>      <span class="non">throw _
</span></td>
          </tr><tr>
            <td class="black">890</td>
            <td>    }
</td>
          </tr><tr>
            <td class="green">891</td>
            <td>    builder.toString
</td>
          </tr><tr>
            <td class="black">892</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">893</td>
            <td>}
</td>
          </tr></tbody></table>