<table class="classes"><tbody><tr>
      <td class="barContainerLeft"><a href="#">&#x200B;scales/&#x200B;xml/<span class="header">&#x200B;XmlTypes.scala</span></a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">64 %</div>
        <div class="greenBar" style="width:128px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlTypes.scala.html#Object_scales_xml_Attr"><img src="object.png"></img>Attr</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlTypes.scala.html#Class_scales_xml_Attribute"><img src="class.png"></img>Attribute</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlTypes.scala.html#Class_scales_xml_AttributeKey"><img src="class.png"></img>AttributeKey</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlTypes.scala.html#Class_scales_xml_CData"><img src="class.png"></img>CData</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlTypes.scala.html#Object_scales_xml_CData"><img src="object.png"></img>CData</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlTypes.scala.html#Trait_scales_xml_CData"><img src="trait.png"></img>CData</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlTypes.scala.html#Class_scales_xml_Comment"><img src="class.png"></img>Comment</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlTypes.scala.html#Object_scales_xml_Comment"><img src="object.png"></img>Comment</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlTypes.scala.html#Trait_scales_xml_Comment"><img src="trait.png"></img>Comment</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlTypes.scala.html#Class_scales_xml_DTD"><img src="class.png"></img>DTD</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlTypes.scala.html#Class_scales_xml_Declaration"><img src="class.png"></img>Declaration</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlTypes.scala.html#Class_scales_xml_Doc"><img src="class.png"></img>Doc</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">50 %</div>
        <div class="greenBar" style="width:100px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlTypes.scala.html#Trait_scales_xml_DocLike"><img src="trait.png"></img>DocLike</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlTypes.scala.html#Class_scales_xml_Elem"><img src="class.png"></img>Elem</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlTypes.scala.html#Object_scales_xml_Elem"><img src="object.png"></img>Elem</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlTypes.scala.html#Trait_scales_xml_Elem"><img src="trait.png"></img>Elem</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">75 %</div>
        <div class="greenBar" style="width:150px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlTypes.scala.html#Class_scales_xml_ElemKey"><img src="class.png"></img>ElemKey</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">86 %</div>
        <div class="greenBar" style="width:172px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlTypes.scala.html#Class_scales_xml_EmptyDoc"><img src="class.png"></img>EmptyDoc</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlTypes.scala.html#Class_scales_xml_EndMisc"><img src="class.png"></img>EndMisc</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlTypes.scala.html#Object_scales_xml_ExtraTypesImplicits"><img src="object.png"></img>ExtraTypesImplicits</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlTypes.scala.html#Trait_scales_xml_FromParser"><img src="trait.png"></img>FromParser</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlTypes.scala.html#Class_scales_xml_PI"><img src="class.png"></img>PI</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">50 %</div>
        <div class="greenBar" style="width:100px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlTypes.scala.html#Object_scales_xml_PI"><img src="object.png"></img>PI</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlTypes.scala.html#Trait_scales_xml_PI"><img src="trait.png"></img>PI</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlTypes.scala.html#Class_scales_xml_Prolog"><img src="class.png"></img>Prolog</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlTypes.scala.html#Class_scales_xml_Text"><img src="class.png"></img>Text</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlTypes.scala.html#Trait_scales_xml_XmlEvent"><img src="trait.png"></img>XmlEvent</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlTypes.scala.html#Trait_scales_xml_XmlItem"><img src="trait.png"></img>XmlItem</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">20 %</div>
        <div class="greenBar" style="width:40px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlTypes.scala.html#Class_scales_xml_XmlTypes"><img src="class.png"></img>XmlTypes</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlTypes.scala.html#Trait_scales_xml_XmlTypes"><img src="trait.png"></img>XmlTypes</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">95 %</div>
        <div class="greenBar" style="width:190px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlTypes.scala.html#Object_scales_xml_XmlTypes_IsFromParser"><img src="object.png"></img>XmlTypes.IsFromParser</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlTypes.scala.html#Object_scales_xml_XmlTypes_NotFromParserO"><img src="object.png"></img>XmlTypes.NotFromParserO</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlTypes.scala.html#Trait_scales_xml_XmlTypesImplicits"><img src="trait.png"></img>XmlTypesImplicits</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">57 %</div>
        <div class="greenBar" style="width:114px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_scales_xml_XmlTypes.scala.html#Object_scales_xml_XmlTypesImplicits_AttributeOrdering"><img src="object.png"></img>XmlTypesImplicits.AttributeOrdering</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr></tbody></table><table class="source"><tbody><tr>
            <td class="black">1</td>
            <td>package scales.xml
</td>
          </tr><tr>
            <td class="black">2</td>
            <td>
</td>
          </tr><tr>
            <td class="black">3</td>
            <td>import scala.collection.immutable.Map
</td>
          </tr><tr>
            <td class="black">4</td>
            <td>
</td>
          </tr><tr>
            <td class="black">5</td>
            <td>import scala.collection.generic.CanBuildFrom
</td>
          </tr><tr>
            <td class="black">6</td>
            <td>
</td>
          </tr><tr>
            <td class="black">7</td>
            <td>import scalaz._
</td>
          </tr><tr>
            <td class="black">8</td>
            <td>import Scalaz._
</td>
          </tr><tr>
            <td class="black">9</td>
            <td>
</td>
          </tr><tr>
            <td class="black">10</td>
            <td>import scales.utils.{ListSet, MapSet, Key, ImmutableArray, EitherLike, LeftLike, Tree}
</td>
          </tr><tr>
            <td class="black">11</td>
            <td>
</td>
          </tr><tr>
            <td class="black">12</td>
            <td>import java.nio.charset.Charset
</td>
          </tr><tr>
            <td class="black">13</td>
            <td>
</td>
          </tr><tr>
            <td class="black">14</td>
            <td>//import scales.collection.immutable.Vector
</td>
          </tr><tr>
            <td class="black">15</td>
            <td>
</td>
          </tr><tr>
            <td class="black">16</td>
            <td><a id="Trait_scales_xml_XmlTypesImplicits"></a>trait XmlTypesImplicits {
</td>
          </tr><tr>
            <td class="black">17</td>
            <td>//  implicit def toAttrQNameN(nons: NoNamespaceQName): AttributeQName = Right(nons)
</td>
          </tr><tr>
            <td class="black">18</td>
            <td>
</td>
          </tr><tr>
            <td class="black">19</td>
            <td><a id="Class_scales_xml_Prolog"></a><a id="Class_scales_xml_Doc"></a><a id="Class_scales_xml_DTD"></a><a id="Class_scales_xml_Declaration"></a><a id="Class_scales_xml_EmptyDoc"></a><a id="Class_scales_xml_EndMisc"></a><a id="Class_scales_xml_Text"></a><a id="Class_scales_xml_Attribute"></a>//  implicit def toAttrQNameP(prens: PrefixedQName): AttributeQName = Left(prens)
</td>
          </tr><tr>
            <td class="black">20</td>
            <td>
</td>
          </tr><tr>
            <td class="red">21</td>
            <td>  implicit def toAttrQNameN(nons: NoNamespaceQName): AttributeQName = <span class="non">nons
</span></td>
          </tr><tr>
            <td class="black">22</td>
            <td>
</td>
          </tr><tr>
            <td class="red">23</td>
            <td>  implicit def toAttrQNameP(prens: PrefixedQName): AttributeQName = <span class="non">prens
</span></td>
          </tr><tr>
            <td class="black">24</td>
            <td>
</td>
          </tr><tr>
            <td class="black">25</td>
            <td>//  implicit def toAttrQNameS(local: String)(implicit ver: XmlVersion): AttributeQName = toAttrQNameN(NoNamespaceQName(local))
</td>
          </tr><tr>
            <td class="black">26</td>
            <td>
</td>
          </tr><tr>
            <td class="black">27</td>
            <td>//  implicit def toAttrQNameS(local: String)(implicit ver: XmlVersion, fromParser : FromParser): AttributeQName = NoNamespaceQName(local)(ver, fromParser)
</td>
          </tr><tr>
            <td class="black">28</td>
            <td>
</td>
          </tr><tr>
            <td class="green">29</td>
            <td>  implicit def toAttr(pair: (String, String))(implicit ver: XmlVersion, fromParser : FromParser) = Attribute(NoNamespaceQName(pair._1)(ver, fromParser), pair._2)
</td>
          </tr><tr>
            <td class="black">30</td>
            <td>
</td>
          </tr><tr>
            <td class="black">31</td>
            <td>//  implicit def toAttrQNamePairN[T](pair: (NoNamespaceQName, T)) = (toAttrQNameN(pair._1), pair._2)
</td>
          </tr><tr>
            <td class="black">32</td>
            <td>
</td>
          </tr><tr>
            <td class="black">33</td>
            <td>//  implicit def toAttrQNamePairP[T](pair: (PrefixedQName, T)) = (toAttrQNameP(pair._1), pair._2)
</td>
          </tr><tr>
            <td class="black">34</td>
            <td>
</td>
          </tr><tr>
            <td class="green">35</td>
            <td>  implicit val aqnameEqual = equal { (a: Attribute, b: Attribute) =&gt; a.name =:= b.name }
</td>
          </tr><tr>
            <td class="green">36</td>
            <td>  implicit val qnameEqual = equal { (a: QName, b: QName) =&gt; a =:= b }
</td>
          </tr><tr>
            <td class="black">37</td>
            <td>//  implicit val toQNameF = (a: Attribute) =&gt; { toQName(a.name) }
</td>
          </tr><tr>
            <td class="green">38</td>
            <td>  implicit val toQNameF = (a: Attribute) =&gt; { a.name : QName }
</td>
          </tr><tr>
            <td class="red">39</td>
            <td>  implicit val toAQNameF = (a: Attribute) =&gt; { <span class="non">a.name }
</span></td>
          </tr><tr>
            <td class="green">40</td>
            <td>  implicit val qnameEquiv = new scales.utils.Equiv[QName]
</td>
          </tr><tr>
            <td class="black">41</td>
            <td>
</td>
          </tr><tr>
            <td class="black">42</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">43</td>
            <td>   * which ever it is, is still a qname
</td>
          </tr><tr>
            <td class="black">44</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">45</td>
            <td>//  implicit def toQName(attribQName: AttributeQName): QName = attribQName.fold({ x =&gt; x }, { x =&gt; x })
</td>
          </tr><tr>
            <td class="green">46</td>
            <td>  implicit def toQName(attribQName: AttributeQName): QName = attribQName.asInstanceOf[QName] // otherwise it blows the stack calling itself
</td>
          </tr><tr>
            <td class="black">47</td>
            <td>
</td>
          </tr><tr>
            <td class="black">48</td>
            <td>  import scales.utils._
</td>
          </tr><tr>
            <td class="black">49</td>
            <td>
</td>
          </tr><tr>
            <td class="black">50</td>
            <td>//  implicit val childrenCBF// : CanBuildFrom[IndexedSeq[_], ItemOrTree[XmlItem,Elem], IndexedSeq[ItemOrTree[XmlItem,Elem]]] 
</td>
          </tr><tr>
            <td class="black">51</td>
            <td>//      = Rope.canBuildFrom(reflect.ClassManifest.classType[ItemOrTree[XmlItem,Elem]](Array[ItemOrTree[XmlItem,Elem]]().getClass.getComponentType)) 
</td>
          </tr><tr>
            <td class="black">52</td>
            <td>
</td>
          </tr><tr>
            <td class="black">53</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">54</td>
            <td>   * Provided for those who don't care about the rest
</td>
          </tr><tr>
            <td class="black">55</td>
            <td>   */
</td>
          </tr><tr>
            <td class="green">56</td>
            <td>  implicit def docToTree(doc: Doc): XmlTree = doc.rootElem
</td>
          </tr><tr>
            <td class="black">57</td>
            <td>
</td>
          </tr><tr>
            <td class="black">58</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">59</td>
            <td>   * Default cbf for xml trees
</td>
          </tr><tr>
            <td class="black">60</td>
            <td>   */ 
</td>
          </tr><tr>
            <td class="green">61</td>
            <td>  implicit val xmlCBF = implicitly[XmlCBF]//defaultXmlCBF//
</td>
          </tr><tr>
            <td class="black">62</td>
            <td>
</td>
          </tr><tr>
            <td class="black">63</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">64</td>
            <td>   * Implicit manifest for sorting positions, big silent cpu eater otherwise, just like the builders.
</td>
          </tr><tr>
            <td class="black">65</td>
            <td>   */ 
</td>
          </tr><tr>
            <td class="green">66</td>
            <td>  implicit val xpathSortingClassManifest = implicitly[ClassManifest[(scales.utils.Position[XmlItem,Elem,XCC], XmlPath)]]
</td>
          </tr><tr>
            <td class="black">67</td>
            <td>
</td>
          </tr><tr>
            <td class="black">68</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">69</td>
            <td>   * Defaults to NotFromParser
</td>
          </tr><tr>
            <td class="black">70</td>
            <td>   */ 
</td>
          </tr><tr>
            <td class="green">71</td>
            <td>  implicit val fromParserDefault : FromParser = NotFromParser
</td>
          </tr><tr>
            <td class="black">72</td>
            <td>
</td>
          </tr><tr>
            <td class="black">73</td>
            <td><a id="Object_scales_xml_XmlTypesImplicits_AttributeOrdering"></a>  implicit object AttributeOrdering extends scala.math.Ordering[Attribute] {
</td>
          </tr><tr>
            <td class="black">74</td>
            <td>    def compare(at1 : Attribute, at2 : Attribute) : Int = {
</td>
          </tr><tr>
            <td class="black">75</td>
            <td>      // don't use toQName
</td>
          </tr><tr>
            <td class="red">76</td>
            <td>      val aq1 = <span class="non">at1.name : QName
</span></td>
          </tr><tr>
            <td class="red">77</td>
            <td>      val aq2 = <span class="non">at2.name : QName
</span></td>
          </tr><tr>
            <td class="black">78</td>
            <td>
</td>
          </tr><tr>
            <td class="red">79</td>
            <td>      if ((<span class="non">aq1 eq aq2) || (aq1 =:= aq2)) 
</span></td>
          </tr><tr>
            <td class="red">80</td>
            <td>  <span class="non">0
</span></td>
          </tr><tr>
            <td class="black">81</td>
            <td>      else {// do each field seperately no string concats.., don't look at prefix, namespaces are likely shared across docs, so check local first
</td>
          </tr><tr>
            <td class="black">82</td>
            <td>//  ....
</td>
          </tr><tr>
            <td class="red">83</td>
            <td>  val l = <span class="non">aq1.local.compare( aq2.local )
</span></td>
          </tr><tr>
            <td class="red">84</td>
            <td>  if (<span class="non">l == 0) {
</span></td>
          </tr><tr>
            <td class="red">85</td>
            <td>    <span class="non">aq1.namespace.uri.compare( aq2.namespace.uri )
</span></td>
          </tr><tr>
            <td class="red">86</td>
            <td>  } else <span class="non">l
</span></td>
          </tr><tr>
            <td class="black">87</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">88</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">89</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">90</td>
            <td>
</td>
          </tr><tr>
            <td class="black">91</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">92</td>
            <td>   * Only used for lookups
</td>
          </tr><tr>
            <td class="black">93</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">94</td>
            <td>//  implicit val toAttrN = (nons: AttributeQName) =&gt; Attribute(nons, &quot;&quot;)
</td>
          </tr><tr>
            <td class="red">95</td>
            <td>  implicit def toAttrS(local: String)(implicit ver: XmlVersion): Attribute = <span class="non">Attribute(toAttrQNameN(NoNamespaceQName(local)), &quot;&quot;)
</span></td>
          </tr><tr>
            <td class="black">96</td>
            <td>
</td>
          </tr><tr>
            <td class="black">97</td>
            <td>  implicit val toAttrQ = (nons: QName) =&gt; 
</td>
          </tr><tr>
            <td class="red">98</td>
            <td>    <span class="non">Attribute(nons.withPrefix(&quot;f&quot;)(Xml10,IsFromParser), &quot;&quot;)
</span></td>
          </tr><tr>
            <td class="black">99</td>
            <td>
</td>
          </tr><tr>
            <td class="red">100</td>
            <td>  implicit def toAttrKS(local: String)(implicit ver: XmlVersion): Key[Attribute] = <span class="non">new AttributeKey(local, Default.noNamespace.uri)
</span></td>
          </tr><tr>
            <td class="black">101</td>
            <td>
</td>
          </tr><tr>
            <td class="black">102</td>
            <td>  implicit def toAttrKQ(q : QName) : Key[Attribute] =
</td>
          </tr><tr>
            <td class="red">103</td>
            <td>    <span class="non">new AttributeKey(q.local, q.namespace.uri)
</span></td>
          </tr><tr>
            <td class="black">104</td>
            <td>
</td>
          </tr><tr>
            <td class="black">105</td>
            <td>  implicit val toAttrK = (a : Attribute) =&gt; {
</td>
          </tr><tr>
            <td class="red">106</td>
            <td>    val q = <span class="non">a.name : QName
</span></td>
          </tr><tr>
            <td class="red">107</td>
            <td>    <span class="non">new AttributeKey(q.local, q.namespace.uri)
</span></td>
          </tr><tr>
            <td class="black">108</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">109</td>
            <td>
</td>
          </tr><tr>
            <td class="black">110</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">111</td>
            <td>
</td>
          </tr><tr>
            <td class="black">112</td>
            <td>// localName to avoid implicits
</td>
          </tr><tr>
            <td class="red">113</td>
            <td><a id="Class_scales_xml_AttributeKey"></a>class AttributeKey<span class="non">(val localName : String, val ns : String) extends Key[Attribute] {
</span></td>
          </tr><tr>
            <td class="red">114</td>
            <td>  override def equals( other : Any ) = <span class="non">other match {
</span></td>
          </tr><tr>
            <td class="black">115</td>
            <td>    case o : AttributeKey =&gt; 
</td>
          </tr><tr>
            <td class="red">116</td>
            <td>      (<span class="non">localName == o.localName) &amp;&amp; (ns == o.ns)
</span></td>
          </tr><tr>
            <td class="red">117</td>
            <td>    case _ =&gt; <span class="non">false
</span></td>
          </tr><tr>
            <td class="black">118</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">119</td>
            <td>
</td>
          </tr><tr>
            <td class="black">120</td>
            <td>  override def hashCode() : Int = {
</td>
          </tr><tr>
            <td class="red">121</td>
            <td>    var hs = <span class="non">1
</span></td>
          </tr><tr>
            <td class="red">122</td>
            <td>    <span class="non">hs = (hs * 31) + localName.hashCode
</span></td>
          </tr><tr>
            <td class="red">123</td>
            <td>    <span class="non">hs = (hs * 31) + ns.hashCode
</span></td>
          </tr><tr>
            <td class="red">124</td>
            <td>    <span class="non">hs
</span></td>
          </tr><tr>
            <td class="black">125</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">126</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">127</td>
            <td>
</td>
          </tr><tr>
            <td class="black">128</td>
            <td><a id="Object_scales_xml_ExtraTypesImplicits"></a>object ExtraTypesImplicits {
</td>
          </tr><tr>
            <td class="red">129</td>
            <td>  implicit val toAttrN = (nons: AttributeQName) =&gt; <span class="non">Attribute(nons, &quot;&quot;)
</span></td>
          </tr><tr>
            <td class="black">130</td>
            <td>
</td>
          </tr><tr>
            <td class="black">131</td>
            <td>  implicit def toAttrKAQ(aq : AttributeQName) : Key[Attribute] = {
</td>
          </tr><tr>
            <td class="red">132</td>
            <td>    val q = <span class="non">aq.asInstanceOf[QName]
</span></td>
          </tr><tr>
            <td class="red">133</td>
            <td>    <span class="non">new AttributeKey(q.local, q.namespace.uri)
</span></td>
          </tr><tr>
            <td class="black">134</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">135</td>
            <td>
</td>
          </tr><tr>
            <td class="black">136</td>
            <td>
</td>
          </tr><tr>
            <td class="black">137</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">138</td>
            <td>
</td>
          </tr><tr>
            <td class="black">139</td>
            <td>import ScalesXml._
</td>
          </tr><tr>
            <td class="black">140</td>
            <td>
</td>
          </tr><tr>
            <td class="black">141</td>
            <td><a id="Trait_scales_xml_FromParser"></a>sealed trait FromParser
</td>
          </tr><tr>
            <td class="black">142</td>
            <td>
</td>
          </tr><tr>
            <td class="black">143</td>
            <td><a id="Trait_scales_xml_XmlTypes"></a>trait XmlTypes {
</td>
          </tr><tr>
            <td class="black">144</td>
            <td>
</td>
          </tr><tr>
            <td class="black">145</td>
            <td><a id="Object_scales_xml_XmlTypes_IsFromParser"></a>  private[xml] case object IsFromParser extends FromParser
</td>
          </tr><tr>
            <td class="black">146</td>
            <td>
</td>
          </tr><tr>
            <td class="black">147</td>
            <td>//  private[xml] case object NotFromParser extends FromParser
</td>
          </tr><tr>
            <td class="black">148</td>
            <td><a id="Object_scales_xml_XmlTypes_NotFromParserO"></a>  private[xml] case object NotFromParserO extends FromParser
</td>
          </tr><tr>
            <td class="green">149</td>
            <td>  private[xml] val NotFromParser = NotFromParserO 
</td>
          </tr><tr>
            <td class="black">150</td>
            <td>
</td>
          </tr><tr>
            <td class="black">151</td>
            <td>//  private[XmlTypes] implicit val xmlCBF = 1 // kill the implicit
</td>
          </tr><tr>
            <td class="black">152</td>
            <td>
</td>
          </tr><tr>
            <td class="black">153</td>
            <td>  import scales.utils.{ Tree, ItemOrTree, subtree, item, top, noPath =&gt; fno, Path, TreeCBF, ImmutableArrayProxy }
</td>
          </tr><tr>
            <td class="black">154</td>
            <td>
</td>
          </tr><tr>
            <td class="black">155</td>
            <td>  type XmlCBF = TreeCBF[XmlItem, Elem, XCC]
</td>
          </tr><tr>
            <td class="black">156</td>
            <td>
</td>
          </tr><tr>
            <td class="black">157</td>
            <td>/*  val defaultXmlCBF : XmlCBF = 
</td>
          </tr><tr>
            <td class="black">158</td>
            <td>    new CanBuildFrom[XCC[_], ItemOrElem, XmlChildren] {
</td>
          </tr><tr>
            <td class="black">159</td>
            <td>      import collection.mutable.Builder
</td>
          </tr><tr>
            <td class="black">160</td>
            <td>
</td>
          </tr><tr>
            <td class="black">161</td>
            <td>      def apply(from : XCC[_]): Builder[ItemOrElem, XmlChildren] = apply()
</td>
          </tr><tr>
            <td class="black">162</td>
            <td>      def apply() : Builder[ItemOrElem, XmlChildren] = new RopeBuilder[ItemOrElem].mapResult(wrapRope(_))
</td>
          </tr><tr>
            <td class="black">163</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">164</td>
            <td>*/
</td>
          </tr><tr>
            <td class="black">165</td>
            <td>/*  import ImmutableArray._
</td>
          </tr><tr>
            <td class="black">166</td>
            <td>
</td>
          </tr><tr>
            <td class="black">167</td>
            <td>  val defaultXmlCBF : XmlCBF = 
</td>
          </tr><tr>
            <td class="black">168</td>
            <td>    new CanBuildFrom[XCC[_], ItemOrElem, XmlChildren] {
</td>
          </tr><tr>
            <td class="black">169</td>
            <td>      import collection.mutable.Builder
</td>
          </tr><tr>
            <td class="black">170</td>
            <td>
</td>
          </tr><tr>
            <td class="black">171</td>
            <td>      def apply(from : XCC[_]): Builder[ItemOrElem, XmlChildren] = apply()
</td>
          </tr><tr>
            <td class="black">172</td>
            <td>      def apply() : Builder[ItemOrElem, XmlChildren] = ImmutableArray.newBuilder[ItemOrElem](reflect.ClassManifest.classType[ItemOrElem](Array[ItemOrElem]().getClass.getComponentType)).mapResult(wrapArray(_))
</td>
          </tr><tr>
            <td class="black">173</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">174</td>
            <td>*/
</td>
          </tr><tr>
            <td class="black">175</td>
            <td>//  type AttributeQName = Either[PrefixedQName, NoNamespaceQName]
</td>
          </tr><tr>
            <td class="black">176</td>
            <td>  type AttributeQName = EitherLike[PrefixedQName, NoNamespaceQName]
</td>
          </tr><tr>
            <td class="black">177</td>
            <td>
</td>
          </tr><tr>
            <td class="black">178</td>
            <td>  type XmlTree = Tree[XmlItem, Elem, XCC]
</td>
          </tr><tr>
            <td class="black">179</td>
            <td>  type ItemOrElem = ItemOrTree[XmlItem, Elem, XCC]
</td>
          </tr><tr>
            <td class="black">180</td>
            <td>
</td>
          </tr><tr>
            <td class="black">181</td>
            <td>  type XmlChildren = XCC[ItemOrElem]
</td>
          </tr><tr>
            <td class="black">182</td>
            <td>
</td>
          </tr><tr>
            <td class="black">183</td>
            <td>  type XCC[T] = ImmutableArrayProxy[T]
</td>
          </tr><tr>
            <td class="black">184</td>
            <td>//  type XCC[T] = ImmutableArray[T]
</td>
          </tr><tr>
            <td class="black">185</td>
            <td>//  type XCC[T] = WrappedRope[T]
</td>
          </tr><tr>
            <td class="black">186</td>
            <td>//  type XCC[T] = Vector[T]
</td>
          </tr><tr>
            <td class="black">187</td>
            <td>//  type XCC[T] = WrappedImmutableArray[T]
</td>
          </tr><tr>
            <td class="black">188</td>
            <td>
</td>
          </tr><tr>
            <td class="black">189</td>
            <td>  type Misc = Either[Comment, PI]
</td>
          </tr><tr>
            <td class="black">190</td>
            <td>  type Miscs = Seq[Misc]
</td>
          </tr><tr>
            <td class="black">191</td>
            <td>
</td>
          </tr><tr>
            <td class="black">192</td>
            <td>  type Attributes = ListSet[Attribute]
</td>
          </tr><tr>
            <td class="black">193</td>
            <td>
</td>
          </tr><tr>
            <td class="green">194</td>
            <td>  val emptyMiscs = List[Misc]()
</td>
          </tr><tr>
            <td class="black">195</td>
            <td>
</td>
          </tr><tr>
            <td class="green">196</td>
            <td>  val emptyAttributes = ListSet.empty[Attribute]
</td>
          </tr><tr>
            <td class="black">197</td>
            <td>//  val emptyAttributes = ListSet.empty[Attribute]
</td>
          </tr><tr>
            <td class="green">198</td>
            <td>  val emptyNamespaces: Map[String, String] = Map[String, String]()
</td>
          </tr><tr>
            <td class="black">199</td>
            <td>
</td>
          </tr><tr>
            <td class="green">200</td>
            <td>  val emptyAttributesHash = emptyAttributes.hashCode
</td>
          </tr><tr>
            <td class="green">201</td>
            <td>  val emptyNamespacesHash = emptyNamespaces.hashCode
</td>
          </tr><tr>
            <td class="black">202</td>
            <td>
</td>
          </tr><tr>
            <td class="black">203</td>
            <td>//  val emptyChildren = Vector[ItemOrElem]()
</td>
          </tr><tr>
            <td class="black">204</td>
            <td>//  val emptyChildren = ImmutableArray[ItemOrElem]()
</td>
          </tr><tr>
            <td class="green">205</td>
            <td>  val emptyChildren = ImmutableArrayProxy[ItemOrElem]()
</td>
          </tr><tr>
            <td class="black">206</td>
            <td>
</td>
          </tr><tr>
            <td class="black">207</td>
            <td>  //val emptyChildren = wrapArray(fromArray[ItemOrElem](Array[ItemOrElem]()))
</td>
          </tr><tr>
            <td class="black">208</td>
            <td>
</td>
          </tr><tr>
            <td class="black">209</td>
            <td>//  private[XmlTypes] val wrapped = wrapRope(Rope.empty(reflect.ClassManifest.classType[ItemOrElem](Array[ItemOrElem]().getClass.getComponentType)))
</td>
          </tr><tr>
            <td class="black">210</td>
            <td>
</td>
          </tr><tr>
            <td class="black">211</td>
            <td>//  val emptyChildren : XmlChildren = wrapped
</td>
          </tr><tr>
            <td class="black">212</td>
            <td>
</td>
          </tr><tr>
            <td class="black">213</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">214</td>
            <td>   * Use to signify a &quot;null object&quot;, tree/path shouldn't work like this its a smell
</td>
          </tr><tr>
            <td class="black">215</td>
            <td>   */
</td>
          </tr><tr>
            <td class="green">216</td>
            <td>  val noXmlPath = fno[XmlItem, Elem, XCC]
</td>
          </tr><tr>
            <td class="black">217</td>
            <td>
</td>
          </tr><tr>
            <td class="black">218</td>
            <td>  type XmlPath = Path[XmlItem, Elem, XCC]
</td>
          </tr><tr>
            <td class="black">219</td>
            <td>
</td>
          </tr><tr>
            <td class="black">220</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">221</td>
            <td>   * Will match if the QNames are the same =:= and if the attributes are present (not requiring that these are the only attributes).
</td>
          </tr><tr>
            <td class="black">222</td>
            <td>   * What is returned is either a Seq of attribute values or a simple boolean
</td>
          </tr><tr>
            <td class="black">223</td>
            <td>   */
</td>
          </tr><tr>
            <td class="red">224</td>
            <td><a id="Class_scales_xml_XmlTypes"></a>  def ElemMatcher(name: QName, attributes: AttributeQName*) = <span class="non">new {
</span></td>
          </tr><tr>
            <td class="black">225</td>
            <td>    import ExtraTypesImplicits._
</td>
          </tr><tr>
            <td class="black">226</td>
            <td>
</td>
          </tr><tr>
            <td class="black">227</td>
            <td>    def matchAttribs(elem: Elem) = for (attribute &lt;- attributes; matches &lt;- elem.attributes(attribute)) yield matches
</td>
          </tr><tr>
            <td class="black">228</td>
            <td>
</td>
          </tr><tr>
            <td class="black">229</td>
            <td>    def unapply(elem: Elem): Option[(Elem, List[Attribute])] = {
</td>
          </tr><tr>
            <td class="black">230</td>
            <td>      val matched = matchAttribs(elem)
</td>
          </tr><tr>
            <td class="black">231</td>
            <td>      if (elem.name =:= name &amp;&amp; matched.size == attributes.size)
</td>
          </tr><tr>
            <td class="black">232</td>
            <td>        Some((elem, matched.toList))
</td>
          </tr><tr>
            <td class="black">233</td>
            <td>      else
</td>
          </tr><tr>
            <td class="black">234</td>
            <td>        None
</td>
          </tr><tr>
            <td class="black">235</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">236</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">237</td>
            <td>
</td>
          </tr><tr>
            <td class="black">238</td>
            <td>  final def addAndFocus(path: XmlPath, elem: Elem, dchildren : XmlChildren = emptyChildren) =
</td>
          </tr><tr>
            <td class="black">239</td>
            <td>    // start it off
</td>
          </tr><tr>
            <td class="green">240</td>
            <td>    if (path eq noXmlPath) {
</td>
          </tr><tr>
            <td class="green">241</td>
            <td>      top(Tree(
</td>
          </tr><tr>
            <td class="black">242</td>
            <td>        elem, dchildren))
</td>
          </tr><tr>
            <td class="black">243</td>
            <td>    } else {
</td>
          </tr><tr>
            <td class="black">244</td>
            <td>      // using a Function1 causes 2% of the cost for init alone
</td>
          </tr><tr>
            <td class="black">245</td>
            <td>      
</td>
          </tr><tr>
            <td class="black">246</td>
            <td>      // cache it here as we are going to fudge the path
</td>
          </tr><tr>
            <td class="green">247</td>
            <td>      val n : ItemOrElem = subtree(elem, dchildren)
</td>
          </tr><tr>
            <td class="green">248</td>
            <td>      var size = 0
</td>
          </tr><tr>
            <td class="black">249</td>
            <td>
</td>
          </tr><tr>
            <td class="black">250</td>
            <td>      import path.node.focus
</td>
          </tr><tr>
            <td class="green">251</td>
            <td>      val parent = focus.getRight
</td>
          </tr><tr>
            <td class="green">252</td>
            <td>      val c = parent.children
</td>
          </tr><tr>
            <td class="green">253</td>
            <td>      size = c.length
</td>
          </tr><tr>
            <td class="black">254</td>
            <td>      
</td>
          </tr><tr>
            <td class="black">255</td>
            <td>      // add a child, focus on it
</td>
          </tr><tr>
            <td class="green">256</td>
            <td>      val tpath = Path( path.top, 
</td>
          </tr><tr>
            <td class="black">257</td>
            <td>           scales.utils.Node( path.node.index, 
</td>
          </tr><tr>
            <td class="black">258</td>
            <td>          Tree(parent.section, //Right()
</td>
          </tr><tr>
            <td class="black">259</td>
            <td>               c :+ n)) )
</td>
          </tr><tr>
            <td class="black">260</td>
            <td>
</td>
          </tr><tr>
            <td class="black">261</td>
            <td>/*
</td>
          </tr><tr>
            <td class="black">262</td>
            <td>val tpath = path.modify { focus =&gt;
</td>
          </tr><tr>
            <td class="black">263</td>
            <td>        val parent = focus.right.get
</td>
          </tr><tr>
            <td class="black">264</td>
            <td>        val c = parent.children
</td>
          </tr><tr>
            <td class="black">265</td>
            <td>        size = c.length
</td>
          </tr><tr>
            <td class="black">266</td>
            <td>        Right(Tree(parent.section,
</td>
          </tr><tr>
            <td class="black">267</td>
            <td>          c :+ n))
</td>
          </tr><tr>
            <td class="black">268</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">269</td>
            <td> */ 
</td>
          </tr><tr>
            <td class="black">270</td>
            <td>
</td>
          </tr><tr>
            <td class="black">271</td>
            <td>      // drill down to last child
</td>
          </tr><tr>
            <td class="black">272</td>
            <td>      //tpath.lastChild().get
</td>
          </tr><tr>
            <td class="green">273</td>
            <td>      Path(tpath, scales.utils.Node(size, n))
</td>
          </tr><tr>
            <td class="black">274</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">275</td>
            <td>
</td>
          </tr><tr>
            <td class="black">276</td>
            <td>  final def addChild(path: XmlPath, child: XmlItem) = {
</td>
          </tr><tr>
            <td class="black">277</td>
            <td>    import path.node.focus
</td>
          </tr><tr>
            <td class="green">278</td>
            <td>    val parent = focus.getRight
</td>
          </tr><tr>
            <td class="green">279</td>
            <td>    Path( path.top, 
</td>
          </tr><tr>
            <td class="black">280</td>
            <td>         scales.utils.Node( path.node.index,
</td>
          </tr><tr>
            <td class="black">281</td>
            <td>         Tree(parent.section,//Right()
</td>
          </tr><tr>
            <td class="black">282</td>
            <td>        parent.children :+ item[XmlItem, Elem, XCC](child))
</td>
          </tr><tr>
            <td class="black">283</td>
            <td>             ))
</td>
          </tr><tr>
            <td class="black">284</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">285</td>
            <td>/*    path.modify { focus =&gt;
</td>
          </tr><tr>
            <td class="black">286</td>
            <td>    
</td>
          </tr><tr>
            <td class="black">287</td>
            <td>      val parent = focus.right.get
</td>
          </tr><tr>
            <td class="black">288</td>
            <td>      Right(Tree(parent.section,
</td>
          </tr><tr>
            <td class="black">289</td>
            <td>        parent.children :+ item[XmlItem, Elem, XCC](child)))
</td>
          </tr><tr>
            <td class="black">290</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">291</td>
            <td>*/
</td>
          </tr><tr>
            <td class="black">292</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">293</td>
            <td>
</td>
          </tr><tr>
            <td class="black">294</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">295</td>
            <td> * Attributes can only work with either a prefixed qname or an empty ns name
</td>
          </tr><tr>
            <td class="black">296</td>
            <td> */
</td>
          </tr><tr>
            <td class="green">297</td>
            <td>case class Attribute(name: AttributeQName, value: String)
</td>
          </tr><tr>
            <td class="black">298</td>
            <td>
</td>
          </tr><tr>
            <td class="black">299</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">300</td>
            <td> * Allows easy patterns for attribute values
</td>
          </tr><tr>
            <td class="black">301</td>
            <td> */
</td>
          </tr><tr>
            <td class="black">302</td>
            <td><a id="Object_scales_xml_Attr"></a>object Attr {
</td>
          </tr><tr>
            <td class="red">303</td>
            <td>  def unapply(attr: Attribute) = <span class="non">Some(attr.value)
</span></td>
          </tr><tr>
            <td class="black">304</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">305</td>
            <td>
</td>
          </tr><tr>
            <td class="black">306</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">307</td>
            <td> * Basis for typed pull api
</td>
          </tr><tr>
            <td class="black">308</td>
            <td> */
</td>
          </tr><tr>
            <td class="black">309</td>
            <td><a id="Trait_scales_xml_XmlEvent"></a>sealed trait XmlEvent
</td>
          </tr><tr>
            <td class="black">310</td>
            <td>
</td>
          </tr><tr>
            <td class="black">311</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">312</td>
            <td> * The namespaces map refers to sax startPrefixMapping events before this element.  These are used
</td>
          </tr><tr>
            <td class="black">313</td>
            <td> * in order to properly write the same XML back out, otherwise we end up with new xmlns:pre declarations
</td>
          </tr><tr>
            <td class="black">314</td>
            <td> * for each step.
</td>
          </tr><tr>
            <td class="black">315</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">316</td>
            <td> * The namespaces map may of course contain a DefaultNamespace.
</td>
          </tr><tr>
            <td class="black">317</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">318</td>
            <td> * QName -&gt; Attribute as the map functions need the lowest QName to search for not an either
</td>
          </tr><tr>
            <td class="black">319</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">320</td>
            <td> * @author Chris
</td>
          </tr><tr>
            <td class="black">321</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">322</td>
            <td> */
</td>
          </tr><tr>
            <td class="black">323</td>
            <td>
</td>
          </tr><tr>
            <td class="black">324</td>
            <td>import ScalesXml._
</td>
          </tr><tr>
            <td class="black">325</td>
            <td>import xml._
</td>
          </tr><tr>
            <td class="black">326</td>
            <td>
</td>
          </tr><tr>
            <td class="black">327</td>
            <td><a id="Trait_scales_xml_Elem"></a>sealed trait Elem extends XmlEvent {
</td>
          </tr><tr>
            <td class="black">328</td>
            <td>  val name : QName
</td>
          </tr><tr>
            <td class="black">329</td>
            <td>  val attributes : Attributes
</td>
          </tr><tr>
            <td class="black">330</td>
            <td>  val namespaces : Map[String, String]
</td>
          </tr><tr>
            <td class="black">331</td>
            <td>
</td>
          </tr><tr>
            <td class="black">332</td>
            <td>  def copy(name: QName = name, attributes: Attributes = attributes, namespaces: Map[String, String] = namespaces)(implicit fromParser : FromParser) : Elem
</td>
          </tr><tr>
            <td class="black">333</td>
            <td>
</td>
          </tr><tr>
            <td class="green">334</td>
            <td>  override def equals( other : Any ) = other match {
</td>
          </tr><tr>
            <td class="black">335</td>
            <td>    case o : Elem =&gt; 
</td>
          </tr><tr>
            <td class="green">336</td>
            <td>      if ((name === o.name) // exact match needed?? 
</td>
          </tr><tr>
            <td class="black">337</td>
            <td>    &amp;&amp; (attributes == o.attributes)
</td>
          </tr><tr>
            <td class="black">338</td>
            <td>    &amp;&amp; (namespaces == o.namespaces) )
</td>
          </tr><tr>
            <td class="green">339</td>
            <td>  true
</td>
          </tr><tr>
            <td class="black">340</td>
            <td>      else
</td>
          </tr><tr>
            <td class="red">341</td>
            <td>  <span class="non">false
</span></td>
          </tr><tr>
            <td class="red">342</td>
            <td>    case _ =&gt; <span class="non">false
</span></td>
          </tr><tr>
            <td class="black">343</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">344</td>
            <td>
</td>
          </tr><tr>
            <td class="black">345</td>
            <td>  override def hashCode() : Int = {
</td>
          </tr><tr>
            <td class="green">346</td>
            <td>    var hs = 1
</td>
          </tr><tr>
            <td class="green">347</td>
            <td>    hs = (hs * 31) + name.hashCode
</td>
          </tr><tr>
            <td class="green">348</td>
            <td>    hs = (hs * 31) + (
</td>
          </tr><tr>
            <td class="green">349</td>
            <td>      if (emptyAttributes eq attributes)
</td>
          </tr><tr>
            <td class="green">350</td>
            <td>  emptyAttributesHash // don't do it more than once
</td>
          </tr><tr>
            <td class="black">351</td>
            <td>      else
</td>
          </tr><tr>
            <td class="red">352</td>
            <td>  <span class="non">attributes.hashCode
</span></td>
          </tr><tr>
            <td class="black">353</td>
            <td>      )
</td>
          </tr><tr>
            <td class="green">354</td>
            <td>    hs = (hs * 31) + (
</td>
          </tr><tr>
            <td class="green">355</td>
            <td>      if (namespaces eq emptyNamespaces)
</td>
          </tr><tr>
            <td class="green">356</td>
            <td>  emptyNamespacesHash // don't do it more than once
</td>
          </tr><tr>
            <td class="black">357</td>
            <td>      else
</td>
          </tr><tr>
            <td class="red">358</td>
            <td>  <span class="non">namespaces.hashCode
</span></td>
          </tr><tr>
            <td class="black">359</td>
            <td>      )
</td>
          </tr><tr>
            <td class="black">360</td>
            <td>
</td>
          </tr><tr>
            <td class="green">361</td>
            <td>    hs    
</td>
          </tr><tr>
            <td class="black">362</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">363</td>
            <td>
</td>
          </tr><tr>
            <td class="black">364</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">365</td>
            <td>
</td>
          </tr><tr>
            <td class="black">366</td>
            <td><a id="Object_scales_xml_Elem"></a>object Elem {
</td>
          </tr><tr>
            <td class="green">367</td>
            <td><a id="Class_scales_xml_Elem"></a>  def apply(namei: QName, attributesi: Attributes = emptyAttributes, namespacesi: Map[String, String] = emptyNamespaces)(implicit fromParser : FromParser) : Elem = new Elem {
</td>
          </tr><tr>
            <td class="green">368</td>
            <td>    if (fromParser eq NotFromParser) {
</td>
          </tr><tr>
            <td class="green">369</td>
            <td>      require(!(namei.prefix.map { p =&gt;
</td>
          </tr><tr>
            <td class="green">370</td>
            <td>  (p eq PrefixedNamespace.xmlPRE) ||
</td>
          </tr><tr>
            <td class="black">371</td>
            <td>         (p eq PrefixedNamespace.xmlnsPRE)
</td>
          </tr><tr>
            <td class="black">372</td>
            <td>             }.getOrElse(false)), &quot;Prefixes (xmlns, xml) are not allowed for elements&quot;)
</td>
          </tr><tr>
            <td class="black">373</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">374</td>
            <td>
</td>
          </tr><tr>
            <td class="green">375</td>
            <td>    val name = namei
</td>
          </tr><tr>
            <td class="green">376</td>
            <td>    val attributes = attributesi
</td>
          </tr><tr>
            <td class="green">377</td>
            <td>    val namespaces = namespacesi
</td>
          </tr><tr>
            <td class="black">378</td>
            <td>
</td>
          </tr><tr>
            <td class="black">379</td>
            <td>    def copy(name: QName = name, attributes: Attributes = attributes, namespaces: Map[String, String] = namespaces)(implicit fromParseri : FromParser) : Elem =
</td>
          </tr><tr>
            <td class="black">380</td>
            <td>      apply(name, attributes, namespaces)(fromParseri)
</td>
          </tr><tr>
            <td class="black">381</td>
            <td>
</td>
          </tr><tr>
            <td class="black">382</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">383</td>
            <td>
</td>
          </tr><tr>
            <td class="green">384</td>
            <td>  def unapply( el : Elem) = Some((el.name, el.attributes, el.namespaces))
</td>
          </tr><tr>
            <td class="black">385</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">386</td>
            <td>/*
</td>
          </tr><tr>
            <td class="black">387</td>
            <td>case class Elem(name: QName, attributes: ListSet[Attribute] = emptyAttributes, namespaces: Map[String, String] = emptyNamespaces)(implicit fromParser : FromParser) extends XmlEvent {
</td>
          </tr><tr>
            <td class="black">388</td>
            <td>  if (fromParser eq NotFromParser) {
</td>
          </tr><tr>
            <td class="black">389</td>
            <td>    require(!(name.prefix.map { p =&gt;
</td>
          </tr><tr>
            <td class="black">390</td>
            <td>      (p eq PrefixedNamespace.xmlPRE) ||
</td>
          </tr><tr>
            <td class="black">391</td>
            <td>      (p eq PrefixedNamespace.xmlnsPRE)
</td>
          </tr><tr>
            <td class="black">392</td>
            <td>    }.getOrElse(false)), &quot;Prefixes (xmlns, xml) are not allowed for elements&quot;)
</td>
          </tr><tr>
            <td class="black">393</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">394</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">395</td>
            <td>*/
</td>
          </tr><tr>
            <td class="black">396</td>
            <td>
</td>
          </tr><tr>
            <td class="black">397</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">398</td>
            <td> * Allows quick lookups without creating elements, only use via copy and then don't change it
</td>
          </tr><tr>
            <td class="black">399</td>
            <td> */ 
</td>
          </tr><tr>
            <td class="green">400</td>
            <td><a id="Class_scales_xml_ElemKey"></a>class ElemKey {
</td>
          </tr><tr>
            <td class="black">401</td>
            <td>  var name : QName = _
</td>
          </tr><tr>
            <td class="green">402</td>
            <td>  var nameHash : Int = 0// incase it can be passed in
</td>
          </tr><tr>
            <td class="black">403</td>
            <td>  var attributes : Attributes = _
</td>
          </tr><tr>
            <td class="black">404</td>
            <td>  var namespaces : Map[String, String] = _
</td>
          </tr><tr>
            <td class="black">405</td>
            <td>
</td>
          </tr><tr>
            <td class="black">406</td>
            <td>  def set(name : QName, attributes : Attributes, namespaces : Map[String, String], nameHash : Int = 0) = {
</td>
          </tr><tr>
            <td class="green">407</td>
            <td>    this.name = name
</td>
          </tr><tr>
            <td class="green">408</td>
            <td>    this.attributes = attributes
</td>
          </tr><tr>
            <td class="green">409</td>
            <td>    this.namespaces = namespaces
</td>
          </tr><tr>
            <td class="black">410</td>
            <td>
</td>
          </tr><tr>
            <td class="green">411</td>
            <td>    if (nameHash == 0)
</td>
          </tr><tr>
            <td class="red">412</td>
            <td>      <span class="non">this.nameHash = name.hashCode
</span></td>
          </tr><tr>
            <td class="black">413</td>
            <td>    else
</td>
          </tr><tr>
            <td class="green">414</td>
            <td>      this.nameHash = nameHash
</td>
          </tr><tr>
            <td class="black">415</td>
            <td>    
</td>
          </tr><tr>
            <td class="green">416</td>
            <td>    lastHash = 0
</td>
          </tr><tr>
            <td class="black">417</td>
            <td>    // do it now
</td>
          </tr><tr>
            <td class="green">418</td>
            <td>    hashCode
</td>
          </tr><tr>
            <td class="green">419</td>
            <td>    this
</td>
          </tr><tr>
            <td class="black">420</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">421</td>
            <td>
</td>
          </tr><tr>
            <td class="black">422</td>
            <td>  def copy = {
</td>
          </tr><tr>
            <td class="green">423</td>
            <td>    val r = new ElemKey
</td>
          </tr><tr>
            <td class="green">424</td>
            <td>    r.name = name
</td>
          </tr><tr>
            <td class="green">425</td>
            <td>    r.attributes = attributes
</td>
          </tr><tr>
            <td class="green">426</td>
            <td>    r.namespaces = namespaces
</td>
          </tr><tr>
            <td class="green">427</td>
            <td>    r.lastHash = lastHash
</td>
          </tr><tr>
            <td class="green">428</td>
            <td>    r
</td>
          </tr><tr>
            <td class="black">429</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">430</td>
            <td>
</td>
          </tr><tr>
            <td class="black">431</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">432</td>
            <td>   * Why are we doing eq's as well? Defaults and caching, and having to recast every time when we already know what we are..
</td>
          </tr><tr>
            <td class="black">433</td>
            <td>   */ 
</td>
          </tr><tr>
            <td class="green">434</td>
            <td>  override def equals( other : Any ) = other match {
</td>
          </tr><tr>
            <td class="black">435</td>
            <td>    case oq : ElemKey =&gt;
</td>
          </tr><tr>
            <td class="green">436</td>
            <td>      if ((lastHash == oq.lastHash) &amp;&amp;
</td>
          </tr><tr>
            <td class="black">437</td>
            <td>  ((name eq oq.name) || (name === oq.name)) &amp;&amp; 
</td>
          </tr><tr>
            <td class="black">438</td>
            <td>    ((attributes eq oq.attributes) || (attributes == oq.attributes)) &amp;&amp;
</td>
          </tr><tr>
            <td class="black">439</td>
            <td>    ((namespaces eq oq.namespaces) || (namespaces == oq.namespaces)) // only checks after running equals == instanceof checks ++
</td>
          </tr><tr>
            <td class="black">440</td>
            <td>  )
</td>
          </tr><tr>
            <td class="green">441</td>
            <td>  true
</td>
          </tr><tr>
            <td class="black">442</td>
            <td>      else
</td>
          </tr><tr>
            <td class="red">443</td>
            <td>  <span class="non">false
</span></td>
          </tr><tr>
            <td class="red">444</td>
            <td>    case _ =&gt; <span class="non">scales.utils.error(&quot;Cannot compare an ElemKey to anything else other than a ElemKey&quot;)
</span></td>
          </tr><tr>
            <td class="black">445</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">446</td>
            <td>
</td>
          </tr><tr>
            <td class="black">447</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">448</td>
            <td>   * When non 0 it has been calculated
</td>
          </tr><tr>
            <td class="black">449</td>
            <td>   */ 
</td>
          </tr><tr>
            <td class="green">450</td>
            <td>  var lastHash : Int = 0
</td>
          </tr><tr>
            <td class="black">451</td>
            <td>
</td>
          </tr><tr>
            <td class="black">452</td>
            <td>  override def hashCode() : Int = {
</td>
          </tr><tr>
            <td class="green">453</td>
            <td>    if (lastHash != 0) return lastHash
</td>
          </tr><tr>
            <td class="black">454</td>
            <td>
</td>
          </tr><tr>
            <td class="green">455</td>
            <td>    var hs = 1
</td>
          </tr><tr>
            <td class="green">456</td>
            <td>    hs = (hs * 31) + nameHash
</td>
          </tr><tr>
            <td class="green">457</td>
            <td>    hs = (hs * 31) + (
</td>
          </tr><tr>
            <td class="green">458</td>
            <td>      if (emptyAttributes eq attributes)
</td>
          </tr><tr>
            <td class="green">459</td>
            <td>  emptyAttributesHash // don't do it more than once
</td>
          </tr><tr>
            <td class="black">460</td>
            <td>      else
</td>
          </tr><tr>
            <td class="red">461</td>
            <td>  <span class="non">attributes.hashCode
</span></td>
          </tr><tr>
            <td class="black">462</td>
            <td>      )
</td>
          </tr><tr>
            <td class="green">463</td>
            <td>    hs = (hs * 31) + (
</td>
          </tr><tr>
            <td class="green">464</td>
            <td>      if (namespaces eq emptyNamespaces)
</td>
          </tr><tr>
            <td class="green">465</td>
            <td>  emptyNamespacesHash // don't do it more than once
</td>
          </tr><tr>
            <td class="black">466</td>
            <td>      else
</td>
          </tr><tr>
            <td class="red">467</td>
            <td>  <span class="non">namespaces.hashCode
</span></td>
          </tr><tr>
            <td class="black">468</td>
            <td>      )
</td>
          </tr><tr>
            <td class="black">469</td>
            <td>
</td>
          </tr><tr>
            <td class="green">470</td>
            <td>    lastHash = hs
</td>
          </tr><tr>
            <td class="green">471</td>
            <td>    hs    
</td>
          </tr><tr>
            <td class="black">472</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">473</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">474</td>
            <td>
</td>
          </tr><tr>
            <td class="black">475</td>
            <td><a id="Trait_scales_xml_XmlItem"></a>sealed trait XmlItem extends LeftLike[XmlItem, Tree[XmlItem, Elem, XCC]] with XmlEvent {
</td>
          </tr><tr>
            <td class="black">476</td>
            <td>  val value: String
</td>
          </tr><tr>
            <td class="black">477</td>
            <td>
</td>
          </tr><tr>
            <td class="black">478</td>
            <td>  override def hashCode() : Int = 
</td>
          </tr><tr>
            <td class="green">479</td>
            <td>    value.hashCode
</td>
          </tr><tr>
            <td class="black">480</td>
            <td>
</td>
          </tr><tr>
            <td class="black">481</td>
            <td>  def doEquals( other : Any, clazz : Class[_] ) = 
</td>
          </tr><tr>
            <td class="red">482</td>
            <td>    if (<span class="non">clazz.isInstance(other)) {
</span></td>
          </tr><tr>
            <td class="red">483</td>
            <td>      val o = <span class="non">other.asInstanceOf[XmlItem]
</span></td>
          </tr><tr>
            <td class="red">484</td>
            <td>      (<span class="non">o.value == value)
</span></td>
          </tr><tr>
            <td class="red">485</td>
            <td>    } else <span class="non">false
</span></td>
          </tr><tr>
            <td class="black">486</td>
            <td>
</td>
          </tr><tr>
            <td class="black">487</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">488</td>
            <td>
</td>
          </tr><tr>
            <td class="green">489</td>
            <td>case class Text(value: String) extends XmlItem
</td>
          </tr><tr>
            <td class="black">490</td>
            <td>
</td>
          </tr><tr>
            <td class="black">491</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">492</td>
            <td> * Comments aren't escaped and will throw a CommentCannotBeEncoded error if the contents cannot be serialized, xalan just tries to serialize directly which can't work.
</td>
          </tr><tr>
            <td class="black">493</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">494</td>
            <td> * Note: Will throw if &quot;--&quot; is found in the value
</td>
          </tr><tr>
            <td class="black">495</td>
            <td> */
</td>
          </tr><tr>
            <td class="black">496</td>
            <td><a id="Trait_scales_xml_Comment"></a>trait Comment extends XmlItem {
</td>
          </tr><tr>
            <td class="red">497</td>
            <td>  override def equals( other : Any ) = <span class="non">doEquals(other, Comment.commentClass)
</span></td>
          </tr><tr>
            <td class="black">498</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">499</td>
            <td>
</td>
          </tr><tr>
            <td class="black">500</td>
            <td><a id="Object_scales_xml_Comment"></a>object Comment {
</td>
          </tr><tr>
            <td class="black">501</td>
            <td>
</td>
          </tr><tr>
            <td class="green">502</td>
            <td>  val commentClass = Comment(&quot;a&quot;)(IsFromParser).getClass
</td>
          </tr><tr>
            <td class="black">503</td>
            <td>
</td>
          </tr><tr>
            <td class="green">504</td>
            <td><a id="Class_scales_xml_Comment"></a>  def apply(valuei : String)(implicit fromParser : FromParser) = new Comment {
</td>
          </tr><tr>
            <td class="green">505</td>
            <td>    if (fromParser eq NotFromParser) 
</td>
          </tr><tr>
            <td class="green">506</td>
            <td>      require(valuei.indexOf(&quot;--&quot;) == -1, &quot;Comments cannot contain the sequence --&quot;)
</td>
          </tr><tr>
            <td class="black">507</td>
            <td>
</td>
          </tr><tr>
            <td class="green">508</td>
            <td>    val value = valuei
</td>
          </tr><tr>
            <td class="black">509</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">510</td>
            <td>
</td>
          </tr><tr>
            <td class="green">511</td>
            <td>  def unapply(cmt : Comment) = Some(cmt.value)
</td>
          </tr><tr>
            <td class="black">512</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">513</td>
            <td>
</td>
          </tr><tr>
            <td class="black">514</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">515</td>
            <td> * Might be tempting to use, but think twice, XOM removes it for a
</td>
          </tr><tr>
            <td class="black">516</td>
            <td>good reason, and I'm sorely tempted to, but I've worked with enough
</td>
          </tr><tr>
            <td class="black">517</td>
            <td>applications that really thought they needed it.
</td>
          </tr><tr>
            <td class="black">518</td>
            <td> * CData serialization is dependent on the encoding, if your CData contains
</td>
          </tr><tr>
            <td class="black">519</td>
            <td>umlauts etc but you choose US-ACSII you will receive a
</td>
          </tr><tr>
            <td class="black">520</td>
            <td>CDataCannotBeEncoded for your efforts.  Choose not to use CData in the
</td>
          </tr><tr>
            <td class="black">521</td>
            <td>first place.
</td>
          </tr><tr>
            <td class="black">522</td>
            <td> * Note: Will throw if given the CData end sequence
</td>
          </tr><tr>
            <td class="black">523</td>
            <td> */
</td>
          </tr><tr>
            <td class="black">524</td>
            <td><a id="Trait_scales_xml_CData"></a>trait CData extends XmlItem {
</td>
          </tr><tr>
            <td class="red">525</td>
            <td>  override def equals( other : Any ) = <span class="non">doEquals(other, CData.cdataClass)
</span></td>
          </tr><tr>
            <td class="black">526</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">527</td>
            <td>
</td>
          </tr><tr>
            <td class="black">528</td>
            <td><a id="Object_scales_xml_CData"></a>object CData {
</td>
          </tr><tr>
            <td class="green">529</td>
            <td>  val cdataClass = CData(&quot;&quot;)(IsFromParser).getClass
</td>
          </tr><tr>
            <td class="black">530</td>
            <td>
</td>
          </tr><tr>
            <td class="green">531</td>
            <td><a id="Class_scales_xml_CData"></a>  def apply(valuei : String)(implicit fromParser : FromParser) = new CData {
</td>
          </tr><tr>
            <td class="green">532</td>
            <td>    if (fromParser eq NotFromParser)
</td>
          </tr><tr>
            <td class="green">533</td>
            <td>      require(valuei.indexOf(&quot;]]&gt;&quot;) == -1, 
</td>
          </tr><tr>
            <td class="black">534</td>
            <td>  &quot;CData sections cannot contain the sequence ]]&gt;&quot;)
</td>
          </tr><tr>
            <td class="black">535</td>
            <td> 
</td>
          </tr><tr>
            <td class="green">536</td>
            <td>    val value = valuei
</td>
          </tr><tr>
            <td class="black">537</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">538</td>
            <td>
</td>
          </tr><tr>
            <td class="green">539</td>
            <td>  def unapply(cmt : CData) = Some(cmt.value)
</td>
          </tr><tr>
            <td class="black">540</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">541</td>
            <td>
</td>
          </tr><tr>
            <td class="black">542</td>
            <td><a id="Trait_scales_xml_PI"></a>trait PI extends XmlItem {
</td>
          </tr><tr>
            <td class="black">543</td>
            <td>
</td>
          </tr><tr>
            <td class="black">544</td>
            <td>  override def equals( other : Any ) = 
</td>
          </tr><tr>
            <td class="red">545</td>
            <td>    if (<span class="non">other.isInstanceOf[PI]) {
</span></td>
          </tr><tr>
            <td class="red">546</td>
            <td>      val o = <span class="non">other.asInstanceOf[PI]
</span></td>
          </tr><tr>
            <td class="red">547</td>
            <td>      (<span class="non">o.value == value) &amp;&amp; (o.target == target)
</span></td>
          </tr><tr>
            <td class="red">548</td>
            <td>    } else <span class="non">false
</span></td>
          </tr><tr>
            <td class="black">549</td>
            <td>
</td>
          </tr><tr>
            <td class="black">550</td>
            <td>  override def hashCode() : Int = {
</td>
          </tr><tr>
            <td class="red">551</td>
            <td>    var hs = <span class="non">1
</span></td>
          </tr><tr>
            <td class="red">552</td>
            <td>    <span class="non">hs = (hs * 31) + value.hashCode
</span></td>
          </tr><tr>
            <td class="red">553</td>
            <td>    <span class="non">hs = (hs * 31) + target.hashCode
</span></td>
          </tr><tr>
            <td class="red">554</td>
            <td>    <span class="non">hs    
</span></td>
          </tr><tr>
            <td class="black">555</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">556</td>
            <td>
</td>
          </tr><tr>
            <td class="black">557</td>
            <td>  val target : String
</td>
          </tr><tr>
            <td class="black">558</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">559</td>
            <td>
</td>
          </tr><tr>
            <td class="black">560</td>
            <td><a id="Object_scales_xml_PI"></a>object PI {
</td>
          </tr><tr>
            <td class="black">561</td>
            <td>
</td>
          </tr><tr>
            <td class="green">562</td>
            <td><a id="Class_scales_xml_PI"></a>  def apply(targeti : String, valuei : String)(implicit fromParser : FromParser) = new PI {
</td>
          </tr><tr>
            <td class="green">563</td>
            <td>    if (fromParser eq NotFromParser) {
</td>
          </tr><tr>
            <td class="red">564</td>
            <td>      <span class="non">require(valuei.indexOf(&quot;?&gt;&quot;) == -1, &quot;PI Processing Instructions cannot contain the sequence ?&gt; in the value&quot;)
</span></td>
          </tr><tr>
            <td class="red">565</td>
            <td>      <span class="non">require(targeti.indexOf(&quot;?&gt;&quot;) == -1, &quot;PI Processing Instructions cannot contain the sequence ?&gt; in the value&quot;)
</span></td>
          </tr><tr>
            <td class="red">566</td>
            <td>      <span class="non">require(!targeti.toLowerCase.startsWith(&quot;xml&quot;), &quot;PI Processing Instructions targets cannot start with ?&gt;&quot;)
</span></td>
          </tr><tr>
            <td class="black">567</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">568</td>
            <td>
</td>
          </tr><tr>
            <td class="green">569</td>
            <td>    val value = valuei
</td>
          </tr><tr>
            <td class="green">570</td>
            <td>    val target = targeti
</td>
          </tr><tr>
            <td class="black">571</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">572</td>
            <td>
</td>
          </tr><tr>
            <td class="green">573</td>
            <td>  def unapply(pi : PI) = Some((pi.target, pi.value))
</td>
          </tr><tr>
            <td class="black">574</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">575</td>
            <td>
</td>
          </tr><tr>
            <td class="black">576</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">577</td>
            <td> * Xml declaration
</td>
          </tr><tr>
            <td class="black">578</td>
            <td> */
</td>
          </tr><tr>
            <td class="green">579</td>
            <td>case class Declaration(version: XmlVersion = defaultVersion, encoding: Charset = scales.utils.defaultCharset, standalone: Boolean = false)
</td>
          </tr><tr>
            <td class="black">580</td>
            <td>
</td>
          </tr><tr>
            <td class="black">581</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">582</td>
            <td> * DTD is not part of the tree, nor a stream, it can only occur once and as such is neither an XmlEvent nor an XmlItem directly
</td>
          </tr><tr>
            <td class="black">583</td>
            <td> */
</td>
          </tr><tr>
            <td class="red">584</td>
            <td>case class DTD<span class="non">(name: String, publicId: String, systemId: String)
</span></td>
          </tr><tr>
            <td class="black">585</td>
            <td>
</td>
          </tr><tr>
            <td class="black">586</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">587</td>
            <td> * Includes all information before the root elem
</td>
          </tr><tr>
            <td class="black">588</td>
            <td> */
</td>
          </tr><tr>
            <td class="green">589</td>
            <td>case class Prolog(
</td>
          </tr><tr>
            <td class="black">590</td>
            <td>  decl: Declaration = Declaration(),
</td>
          </tr><tr>
            <td class="black">591</td>
            <td>  misc: Miscs = emptyMiscs,
</td>
          </tr><tr>
            <td class="black">592</td>
            <td>  dtd: Option[DTD] = None)
</td>
          </tr><tr>
            <td class="black">593</td>
            <td>
</td>
          </tr><tr>
            <td class="black">594</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">595</td>
            <td> * The information after the root elem
</td>
          </tr><tr>
            <td class="black">596</td>
            <td> */
</td>
          </tr><tr>
            <td class="green">597</td>
            <td>case class EndMisc(misc: Miscs = emptyMiscs)
</td>
          </tr><tr>
            <td class="black">598</td>
            <td>
</td>
          </tr><tr>
            <td class="black">599</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">600</td>
            <td> * All documents look similar to this, even when stream
</td>
          </tr><tr>
            <td class="black">601</td>
            <td> */
</td>
          </tr><tr>
            <td class="black">602</td>
            <td><a id="Trait_scales_xml_DocLike"></a>trait DocLike {
</td>
          </tr><tr>
            <td class="black">603</td>
            <td>  def prolog: Prolog
</td>
          </tr><tr>
            <td class="black">604</td>
            <td>  def end: EndMisc
</td>
          </tr><tr>
            <td class="black">605</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">606</td>
            <td>
</td>
          </tr><tr>
            <td class="black">607</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">608</td>
            <td> * Provides a simple empty document for streams etc
</td>
          </tr><tr>
            <td class="black">609</td>
            <td> */
</td>
          </tr><tr>
            <td class="red">610</td>
            <td>case class EmptyDoc<span class="non">(prolog: Prolog = Prolog(), end: EndMisc = EndMisc()) extends DocLike
</span></td>
          </tr><tr>
            <td class="black">611</td>
            <td>
</td>
          </tr><tr>
            <td class="black">612</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">613</td>
            <td> * Tree based document
</td>
          </tr><tr>
            <td class="black">614</td>
            <td> */
</td>
          </tr><tr>
            <td class="green">615</td>
            <td>case class Doc(rootElem: XmlTree, prolog: Prolog = Prolog(), end: EndMisc = EndMisc()) extends DocLike {
</td>
          </tr><tr>
            <td class="red">616</td>
            <td>  override def toString() = <span class="non">&quot;scales.xml.doc&quot;
</span></td>
          </tr><tr>
            <td class="black">617</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">618</td>
            <td>
</td>
          </tr></tbody></table>