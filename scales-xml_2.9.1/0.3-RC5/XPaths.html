<?xml version='1.0' encoding='utf-8' ?><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=8" /><link href="./scales_base.css" rel="stylesheet" type="text/css" media="screen" /><link href="./site_docs.css" rel="stylesheet" type="text/css" media="screen" /><link href="./highlight/styles/idea.css" rel="stylesheet" type="text/css" media="screen" /><script src="./jquery.js" type="text/javascript"></script><script src="./highlight/highlight.pack.js" type="text/javascript"></script><script type="text/javascript">
$(function() {
$("pre[class^='language-']").each(function(i,elem) {
  var clazz = $(elem).attr('class');
  var str = elem.innerHTML//.replace(/\r\n|\r|\n/g,"<br/>");
  // Workaround for IE <PRE> innerHTML normalization quirk
  if (elem.tagName == "PRE" && "outerHTML" in elem)
    {
      elem.outerHTML = "<PRE><CODE class='"+clazz+"'>" + str + "</CODE></PRE>";
    }
  else
    {
      elem.innerHTML = "<CODE class='"+clazz+"'>" + str + "</CODE>"; //.replace(/\r\n|\r|\n/g,"<br/>");;
    }
});
  hljs.initHighlighting();
});
</script>
<link href="./menubar.css" rel="stylesheet" type="text/css" media="screen" />
  <script type="text/javascript">
  $(function(){

  $('#scales-site-menubar li:has(ul)').toggleClass('menuPlus');
  $('#scales-site-menubar ul').children('li:has(ul)').click(function(event){
            if (this == event.target) {                
                $(this).children('ul').fadeToggle('fast');
		$(this).toggleClass('menuPlus');
		$(this).toggleClass('menuMinus');
            }
	    if ($(event).get(0).target.tagName.toLowerCase() == "a") {
	      return true; // we want links to be clickable
	    } else {
              return false;
	    }
        })
        .children('ul').hide();

});
</script>
</head><body><h1 id="XPath_Embedded_DSL">XPath Embedded DSL</h1><p>The XML XPath specifications allows navigation of XML documents via a DSL that describes routes through a document using a combination of axe, steps and predicates.  It has a limited number of these abstractions but together they create a powerful direct, whilst remaining simple to use, querying language.</p><p>Scales provides this power via both a traditional string based approach and an embedded DSL that leverages the power of Scalas syntactical flexibility to mimic the XPath syntax.</p><p>The DSL uses the existing Scales abstractions to the full, and works via a zipper over the XmlTree itself.  Each navigation step through the tree creates new zippers and new paths through the tree.</p><p>In every case possible (with the exception of the namespace:: axis) the range of behaviours closely follows the specification, like for like queries matching 100%.  Instead of matching on prefixes Scales uses fully qualified expanded QNames (qualifiedName in the <a href="XPathFunctions.html#QName_Functions">QName Functions</a>) to match against, not requiring a prefix context within which to evaluate.</p><p>Internally, perhaps unsuprisingly, XPath is implemented as a combination of filter, map and flatMap.  When retrieving results (e.g. converting to an Iterable) the results are sorted into Document order, this can be expensive for large result sets (see <a href="#Unsorted_Results_and_Views">Unsorted Results</a> for alternatives).</p><h2 id="Simple_Usage_Examples">Simple Usage Examples</h2><p>Given the following document:</p><pre class="language-scala">
  val ns = Namespace("test:uri")
  val nsa = Namespace("test:uri:attribs")
  val nsp = nsa.prefixed("pre")

  val builder = 
    ns("Elem") /@ (nsa("pre", "attr1") -&gt; "val1",
      	    	   "attr2" -&gt; "val2",
		   nsp("attr3") -&gt; "val3") /(
      ns("Child"),
      "Mixed Content",
      ns("Child2") /( ns("Subchild") ~&gt; "text" )
    )
</pre><p>we can easily query for the Subchild:</p><pre class="language-scala">
  // top produces a Path from a Tree, in this case an XPath
  val path = top(builder)

  val res = path \* ns("Child2") \* ns("Subchild")
  res.size // 1

  string(res) // text
  qname(res) // Subchild
</pre><h2 id="XPath_Axe">XPath Axe</h2><p>Scales supports the complete useful XPath axe:</p><ul><li>ancestor (ancestor_::)</li><li>ancestor-or-self (ancestor_or_self::)</li><li>attribute (*@)</li></ul><ul><li>child (\ or \+ to expand XmlItems)</li><li>descendant (descendant_::)</li><li>descendant-or-self (descendant_or_self_::)</li></ul><ul><li>following (following_::)</li><li>following-sibling (following_sibling_::)</li><li>parent (\^)</li></ul><ul><li>preceding (preceding_::)</li><li>preceding-sibling (preceding_sibling_::)</li><li>self (.)</li></ul><p>A commonly used abbreviation not listed above is of course \\, which means descendant_or_self_::.  The difference being that \\ also supports possible eager evaluation and as per the spec the notion of <a href="http://www.w3.org/TR/xpath20/#id-path-expressions">\\ in the beginning expression</a>.</p><p><i>NB Scales Embedded XPath DSL does not support the namespace axis - if you have a requirement for it then it can be looked at (please send an email to <a href="mailto:scales-xml@googlegroups.com">the mailing list</a> to discuss possible improvements)</i></p><h2 id="Node_Tests">Node Tests</h2><p>Scales embedded XPath DSL views the majority of node tests as predicates</p><ul><li>node() (\+)</li><li>text() (.text)</li><li>comment() (.comment)</li></ul><p>Scales XML also adds:</p><ul><li>.textOnly (filters out CData, just giving text nodes)</li><li>.cdata (provides CData nodes)</li><li>.pi (provides processing instructions)</li></ul><h2 id="Predicates">Predicates</h2><p>There are three areas allowing for predicates within XPaths:</p><ul><li>Attributes</li><li>Elements</li><li>General</li></ul><p>The first two are special cased, as in the XPath spec, as they are the most heavily used predicates (using the above example document):</p><pre class="language-scala">
  // QName based match
  val attributeNamePredicates = path \@ nsp("attr3")
  string(attributeNamePredicates) // "val3"
  
  // predicate based match
  val attributePredicates = path \@ ( string(_) == "val3" )
  qualifiedName(attributePredicates) // {test:uri:attribs}attr3

  // Find child descendants that contain a Subchild 
  val elemsWithASubchild = path \\* ( _ \* ns("Subchild"))
  string(elemsWithASubchild) // text
  qualifiedName(elemsWithASubchild) // {test:uri}Child2
</pre><p>In each case the XmlPath (or AttributePath) is passed to the predicate with a number of short cuts for the common QName based matches and positional matches for elements:</p><pre class="language-scala">
  val second = path \*(2) // path \* 2 is also valid but doesn't read like \*[2]
  qname(second) // Child2
</pre><h3 id="Positional_Predicates">Positional Predicates</h3><ul><li>position() (pos)<ul><li>pos_&lt;, pos_==, pos_&gt;</li></ul></li><li>last() (last)<ul><li>last_&lt;, last_==, last_&gt;</li></ul></li><li>position() == last() <ul><li>pos_eq_last</li></ul></li></ul><p>These, more difficult to model, positional tests can be leveraged the same way as position() and last() can be in XPath.</p><p>So, for example:</p><pre class="language-scala">
  // /*[position() = last()]
  val theLast = path.\.pos_eq_last
  qname(theLast) // Elem

  // //*[position() = last()]
  val allLasts = path.\\*.pos_eq_last
  allLasts map(qname(_)) // List(Elem, Child2, Subchild)

  // all elems with more than one child
  // //*[ ./*[last() &gt; 1]]
  val moreThanOne = path.\\*( _.\*.last_&gt;(1) )
  qname(moreThanOne) // Elem

  // all elems that aren't the first child
  // //*[ position() &gt; 1]
  val notFirst = path.\\*.pos_&gt;(1)
  qname(notFirst) // Child2
</pre><h3 id="Direct_Filtering">Direct Filtering</h3><p>The xflatMap, xmap, xfilter and filter methods allow extra predicate usage where the existing XPath 1.0 functions don't suffice.</p><p>The filter method accepts a simple XmlPath =&gt; Boolean, whereas the other varieties work on the matching sets themselves.</p><p>It is not recommended to use these functions for general use as they primarly exist for internal re-use.</p><h2 id="Unsorted_Results_and_Views">Unsorted Results and Views</h2><p>In order to meet XPath expected usage results are sorted in Document order and checked for duplicates.  If this is not necessary - but speed of matching over a result set is (for example lazy querying over a large set) - then the raw functions (either raw or rawLazy) are good choices.</p><p>The viewed function however uses views as its default type and may help add further lazy evaluation.  Whilst tests have shown lazy evaluation takes place its worth profiling your application to see if it actually impacts performance in an expected fashion.</p><p>See the <a href="./doc/scales/xml/XmlPaths.html">XmlPaths trait</a> for more information.</p><div id="scales-site-menubar"><h2 id="Generated_Documentation">Generated Documentation</h2><ul><li><a href="./api.sxr/index.html">SXR Source</a></li><li><a href="./doc/index.html">ScalaDocs</a></li></ul><h2 id="Documentation_Highlights">Documentation Highlights</h2><ul><li><a href="./ScalesXmlIntro.html">Introduction</a></li><li><a href="./MemoryOptimisation.html">Memory and Performance</a></li></ul><dl><dt><b>First Steps</b><ul><li><a href="Setup.html">Setup</a></li><li><a href="HowToUse.html">How To Use</a></li></ul></dt></dl><dl><dt><b>Xml Model</b><ul><li><a href="QNames.html">QNames</a><ul><li><a href="QNames.html#Creating_QNames">Creating QNames</a><ul><li><a href="QNames.html#Directly">Directly</a></li><li><a href="QNames.html#Implicits">With Sugar</a></li></ul></li><li><a href="QNames.html#Namespaces_.26_Scope">Namespaces &amp; Scope</a></li><li><a href="QNames.html#Namespaces_in_Scales">Namespaces in Scales</a></li><li><a href="QNames.html#QNames_in_Scales_-_Let_the_compliler_help_us">Type System FTW</a></li><li><a href="QNames.html#Runtime_Validation">Runtime Validation</a></li><li><a href="QNames.html#Equality">Equality</a><ul><li><a href="QNames.html#Scalaz_Equal_and_Scales_Equiv">via Scalaz Equal and Scales Equiv</a></li></ul></li><li><a href="QNames.html#Testing_For_QNames">Testing For QNames</a></li><li><a href="QNames.html#Serializing_QNames">Serializing QNames</a></li></ul></li><li><a href="XmlVersionSupport.html">XML Version Support</a><ul><li><a href="XmlVersionSupport.html#Differences_Between_1.0_and_1.1">Differences Between Xml 1.0 and 1.1</a></li><li><a href="XmlVersionSupport.html#How_Does_Scales_Allow_Both_Versions_.3F">Scales Support for Both Versions</a><ul><li><a href="XmlVersionSupport.html#In_Parser_We_Trust_-_Users_We_Protect">In Parser We Trust - Users We Protect</a></li><li><a href="XmlVersionSupport.html#Runtime_XmlVersion_QName_Related_Correctness">Runtime XmlVersion QName Related Correctness</a></li></ul></li></ul></li><li><a href="Attributes.html">Attributes</a><ul><li><a href="Attributes.html#Defining_an_Attribute">Defining</a><ul><li><a href="Attributes.html#Explicitly">Explicitly</a></li><li><a href="Attributes.html#Implicitly">Implicitly</a></li></ul></li><li><a href="Attributes.html#Equality">Equality</a><ul><li><a href="Attributes.html#Within_an_Elem">Within an Elem</a></li><li><a href="Attributes.html#Attributes_ListSet">Attributes ListSet</a></li></ul></li><li><a href="Attributes.html#Testing_Against_QNames_or_Namespaces">Testing Against QNames or Namespaces</a></li></ul></li><li><a href="Elem.html">Elem</a><ul><li><a href="Elem.html#XML_Elements">XML Elements</a></li><li><a href="Elem.html#Declaring">Declaring</a></li><li><a href="Elem.html#QName_And_Namespace_Correctness">QName And Namespace Correctness</a></li><li><a href="Elem.html#Elems_Are_Reusable">Elems Are Reusable</a></li><li><a href="Elem.html#Runtime_Validation_Checks">Runtime Validation Checks</a></li></ul></li><li><a href="XmlItem.html">XmlItem</a><ul><li><a href="XmlItem.html#Declaring">Declaring</a></li><li><a href="XmlItem.html#XmlItems_Are_Reusable">XmlItems Are Reusable</a></li><li><a href="XmlItem.html#Runtime_Correctness_Checks">Runtime Correctness Checks</a></li><li><a href="XmlItem.html#Serializing_XmlItems">Serializing XmlItems</a><ul><li><a href="XmlItem.html#Serializing_CData">Serializing CData</a></li></ul></li></ul></li><li><a href="XmlDsl.html">Xml DSL and Trees</a><ul><li><a href="XmlDsl.html#Tour_of_the_DSL">Tour of the DSL</a></li><li><a href="XmlDsl.html#Creating_a_Tree">Creating a Tree</a></li><li><a href="XmlDsl.html#Adding_To_The_Tree">Adding To The Tree</a></li><li><a href="XmlDsl.html#Adding_an_Attribute">Adding an Attribute</a></li><li><a href="XmlDsl.html#Setting_Text">Setting Text</a></li><li><a href="XmlDsl.html#Removing_Children">Removing Children</a></li><li><a href="XmlDsl.html#Removing_Attributes">Removing Attributes</a></li><li><a href="XmlDsl.html#Folding_Within_The_DSL">Folding Within The DSL</a></li></ul></li></ul></dt></dl><dl><dt><b>Accessing and Querying Data</b><ul><li><a href="XPathFunctions.html">XPath Functions</a><ul><li><a href="XPathFunctions.html#Organisation">Organisation</a></li><li><a href="XPathFunctions.html#Using">Using</a></li><li><a href="XPathFunctions.html#QName_Functions">QName Functions</a></li><li><a href="XPathFunctions.html#Text_Functions">Text Functions</a></li><li><a href="XPathFunctions.html#Boolean_Function">Boolean Function</a></li></ul></li><li><a href="XPaths.html">XPath Embedded DSL</a><ul><li><a href="XPaths.html#Simple_Usage_Examples">Simple Usage Examples</a></li><li><a href="XPaths.html#XPath_Axe">XPath Axe</a></li><li><a href="XPaths.html#Node_Tests">Node Tests</a></li><li><a href="XPaths.html#Predicates">Predicates</a><ul><li><a href="XPaths.html#Positional_Predicates">Positional Predicates</a></li><li><a href="XPaths.html#Direct_Filtering">Direct Filtering</a></li></ul></li><li><a href="XPaths.html#Unsorted_Results_and_Views">Unsorted Results and Views</a></li></ul></li><li><a href="StringXPaths.html">XPath 1.0 String Evaluation</a><ul><li><a href="StringXPaths.html#How_To_Use">How To Use</a></li><li><a href="StringXPaths.html#Other_Jaxen_Tricks">Other Jaxen Tricks</a></li></ul></li></ul></dt></dl><dl><dt><b>Transforming XML</b><ul><li><a href="Folding.html">Folding Xml</a><ul><li><a href="Folding.html#PathFoldR_-_Catchy_Result_Type">PathFoldR - Catchy Result Type</a></li><li><a href="Folding.html#Composing_Transformations">Composing Transformations</a><ul><li><a href="Folding.html#ReplaceWith_-_Nested"> ReplaceWith - Nested</a></li><li><a href="Folding.html#.26_-_Fail_Early">&amp; - Fail Early</a></li><li><a href="Folding.html#.7C_-_Try_The_Next">| - Try The Next</a></li></ul></li></ul></li><li>XSLT Support</li></ul></dt></dl></div></body></html>