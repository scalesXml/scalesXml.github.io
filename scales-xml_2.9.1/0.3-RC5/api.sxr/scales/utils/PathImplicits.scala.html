<?xml version="1.0" encoding="utf-8"?>
			<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>scales\utils\PathImplicits.scala</title>
        <script type="text/javascript" src="../../jquery-all.js"></script>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> scales.utils

<span class="keyword">import</span> scala.collection.immutable.Stack
<span class="keyword">import</span> scala.collection.IndexedSeqLike
<span class="keyword">import</span> scala.collection.generic.CanBuildFrom

<span class="keyword">import</span> scalaz._
<span class="keyword">import</span> <span title="object scalaz.Scalaz">Scalaz</span>._

<span class="comment">/**
 * Provide &amp; combinator to pass the result of one fold onto the other,
 * in the case of failure no further joined functions will be called.
 *
 * And provides | which allows NoPaths failures, allowing the use site to decide
 * how to combine
 */</span>
<span class="keyword">class</span> <a title="class PathFoldCombiner[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]] extends java.lang.Object with ScalaObject" id="11116">PathFoldCombiner</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="12025">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="12026">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="12027">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="86731">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><a href="#11116" title="ScalaObject" class="delimiter">(</a><a title="scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]" id="71304">f</a>: <span title="scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]">PathFoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(next: scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC], orOnFail: (scales.utils.Path[Item,Section,CC], scales.utils.FoldError) =&gt; scales.utils.package.FoldR[Item,Section,CC])scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]" id="71301">onSuccess</a><span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]" id="86734">next</a>: <span title="scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]">PathFoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, <a title="(scales.utils.Path[Item,Section,CC], scales.utils.FoldError) =&gt; scales.utils.package.FoldR[Item,Section,CC]" id="86737">orOnFail</a>: <span class="delimiter">(</span>Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span>, FoldError<span class="delimiter">)</span> =&gt; FoldR<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> = <span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC]" id="86786">a</a>, <a title="scales.utils.FoldError" id="86787">b</a><a href="PathFolds.scala.html#10456" title="scales.utils.FoldError" class="delimiter">)</a> =&gt; <span title="(b: scales.utils.FoldError)Right[Nothing,scales.utils.FoldError]">Right</span><span class="delimiter">(</span><a href="#86787" title="scales.utils.FoldError">b</a><span class="delimiter">)</span><span class="delimiter">)</span>: <span title="scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]">PathFoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> =
    <span class="delimiter">(</span>path: <a href="Paths.scala.html#11083" title="scales.utils.Path[Item,Section,CC]">Path</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> =&gt;
      <span class="comment">// modify back in (allows changes), or pass on the error</span>
      <a href="#71304" title="(v1: scales.utils.Path[Item,Section,CC])scales.utils.package.FoldR[Item,Section,CC]">f</a><span class="delimiter">(</span><a href="#86752" title="scales.utils.Path[Item,Section,CC]">path</a><span class="delimiter">)</span>.<span title="(fa: scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC], fb: scales.utils.FoldError =&gt; scales.utils.package.FoldR[Item,Section,CC])scales.utils.package.FoldR[Item,Section,CC]">fold</span><span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC]" id="86760">fres</a> =&gt;
        <a href="#86734" title="(v1: scales.utils.Path[Item,Section,CC])scales.utils.package.FoldR[Item,Section,CC]">next</a><span class="delimiter">(</span><a href="#86752" title="scales.utils.Path[Item,Section,CC]">path</a>.<a href="Paths.scala.html#43444" title="(newFocus: scales.utils.package.ItemOrTree[Item,Section,CC] =&gt; scales.utils.package.ItemOrTree[Item,Section,CC])scales.utils.Path[Item,Section,CC]">modify</a><span class="delimiter">(</span><a title="scales.utils.package.ItemOrTree[Item,Section,CC]" id="86764">_</a> =&gt; <a href="#86760" title="scales.utils.Path[Item,Section,CC]">fres</a>.<a href="Paths.scala.html#43436" title="()scales.utils.Tree[Item,Section,CC]">tree</a><span class="delimiter">)</span><span class="delimiter">)</span>,
	    <a href="#86737" title="(v1: scales.utils.Path[Item,Section,CC], v2: scales.utils.FoldError)scales.utils.package.FoldR[Item,Section,CC]">orOnFail</a><span class="delimiter">(</span><a href="#86752" title="scales.utils.Path[Item,Section,CC]">path</a>, <a href="#86766" title="scales.utils.FoldError">_</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Combine with next, but only when this PathFoldR has not failed
   */</span> 
  <span class="keyword">def</span> <a title="(next: scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC])scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]" id="71302">&amp;</a><span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]" id="86771">next</a>: <span title="scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]">PathFoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]">PathFoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> =
    <a href="#71301" title="(next: scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC], orOnFail: (scales.utils.Path[Item,Section,CC], scales.utils.FoldError) =&gt; scales.utils.package.FoldR[Item,Section,CC])scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]">onSuccess</a><span class="delimiter">(</span><a href="#86771" title="scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]">next</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Combine with next, and allow next to be used if this PathFoldR returns NoPaths
   */</span> 
  <span class="keyword">def</span> <a title="(next: scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC])scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]" id="71303">|</a><span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]" id="86775">next</a>: <span title="scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]">PathFoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]">PathFoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span> =
    <a href="#71301" title="(next: scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC], orOnFail: (scales.utils.Path[Item,Section,CC], scales.utils.FoldError) =&gt; scales.utils.package.FoldR[Item,Section,CC])scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]">onSuccess</a><span class="delimiter">(</span><a href="#86775" title="scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]">next</a>, orOnFail = <span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC]" id="86778">path</a>, <a title="scales.utils.FoldError" id="86779">res</a><a href="PathFolds.scala.html#10456" title="scales.utils.FoldError" class="delimiter">)</a> =&gt;
      <span title="scales.utils.package.FoldR[Item,Section,CC]" class="keyword">if</span> <span class="delimiter">(</span><a href="#86779" title="scales.utils.FoldError">res</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="PathFolds.scala.html#11060" title="object scales.utils.NoPaths">NoPaths</a><span class="delimiter">)</span>
        <a href="#86775" title="(v1: scales.utils.Path[Item,Section,CC])scales.utils.package.FoldR[Item,Section,CC]">next</a><span class="delimiter">(</span><a href="#86778" title="scales.utils.Path[Item,Section,CC]">path</a><span class="delimiter">)</span>
      <span class="keyword">else</span>
        <span title="(b: scales.utils.FoldError)Right[Nothing,scales.utils.FoldError]">Right</span><span class="delimiter">(</span><a href="#86779" title="scales.utils.FoldError">res</a><span class="delimiter">)</span><span class="delimiter">)</span>
<span class="delimiter">}</span>


<span class="keyword">trait</span> <a title="trait PathImplicits extends java.lang.Object with ScalaObject" id="11125">PathImplicits</a> <span title="ScalaObject" class="delimiter">{</span>
  <span class="comment">/**
   * Provide &amp; combinator to pass the result of one fold onto the other,
   * in the case of failure no further joined functions will be called.
   *
   * And provides | which allows NoPaths failures, allowing the use site to decide
   * how to combine
   */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]](f: scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC])scales.utils.PathFoldCombiner[Item,Section,CC]" id="70474">fToFoldRToCombine</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="70478">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="70479">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="70480">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="71297">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]" id="71294">f</a>: <span title="scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]">PathFoldR</span><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">)</span> = <span title="scales.utils.PathFoldCombiner[Item,Section,CC]" class="keyword">new</span> <a href="#11116" title="scales.utils.PathFoldCombiner[Item,Section,CC]">PathFoldCombiner</a><span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">(</span><a href="#71294" title="scales.utils.Path[Item,Section,CC] =&gt; scales.utils.package.FoldR[Item,Section,CC]">f</a><span class="delimiter">)</span>

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[Item &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]], Section, CC[X] &lt;: scala.collection.IndexedSeqLike[X,CC[X]]]=&gt; scalaz.Equal[scales.utils.Path[Item,Section,CC]]" id="70481">toEqual</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scales.utils.LeftLike[Item,scales.utils.Tree[Item,Section,CC]]" id="70485">Item</a> &lt;: LeftLike<span class="delimiter">[</span>Item, Tree<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="70486">Section</a>, <a title="[X]&gt;: Nothing &lt;: scala.collection.IndexedSeqLike[X,CC[X]]" id="70487">CC</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="71291">X</a><span class="delimiter">]</span> &lt;: IndexedSeqLike<span class="delimiter">[</span>X, CC<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> : <span title="scalaz.Equal[scales.utils.Path[Item,Section,CC]]">Equal</span><span class="delimiter">[</span>Path<span class="delimiter">[</span>Item, Section, CC<span class="delimiter">]</span><span class="delimiter">]</span> =
    <span title="(f: (scales.utils.Path[Item,Section,CC], scales.utils.Path[Item,Section,CC]) =&gt; Boolean)scalaz.Equal[scales.utils.Path[Item,Section,CC]]">equal</span> <span class="delimiter">{</span>
      <a href="PathFunctions.scala.html#15039" title="(path1: scales.utils.Path[Item,Section,CC], path2: scales.utils.Path[Item,Section,CC])Boolean">comparePathsDirect</a><span class="delimiter">(</span><a href="#86803" title="scales.utils.Path[Item,Section,CC]">_</a>,<a href="#86804" title="scales.utils.Path[Item,Section,CC]">_</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>