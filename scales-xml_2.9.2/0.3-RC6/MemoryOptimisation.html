<?xml version='1.0' encoding='utf-8' ?><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=8" /><link href="./scales_base.css" rel="stylesheet" type="text/css" media="screen" /><link href="./site_docs.css" rel="stylesheet" type="text/css" media="screen" /><link href="./highlight/styles/idea.css" rel="stylesheet" type="text/css" media="screen" /><script src="./jquery.js" type="text/javascript"></script><script src="./highlight/highlight.pack.js" type="text/javascript"></script><script type="text/javascript">
$(function() {
$("pre[class^='language-']").each(function(i,elem) {
  var clazz = $(elem).attr('class');
  var str = elem.innerHTML//.replace(/\r\n|\r|\n/g,"<br/>");
  // Workaround for IE <PRE> innerHTML normalization quirk
  if (elem.tagName == "PRE" && "outerHTML" in elem)
    {
      elem.outerHTML = "<PRE><CODE class='"+clazz+"'>" + str + "</CODE></PRE>";
    }
  else
    {
      elem.innerHTML = "<CODE class='"+clazz+"'>" + str + "</CODE>"; //.replace(/\r\n|\r|\n/g,"<br/>");;
    }
});
  hljs.initHighlighting();
});
</script>
<link href="./menubar.css" rel="stylesheet" type="text/css" media="screen" />
  <script type="text/javascript">
  $(function(){

  $('#scales-site-menubar li:has(ul)').toggleClass('menuPlus');
  $('#scales-site-menubar ul').children('li:has(ul)').click(function(event){
            if (this == event.target) {                
                $(this).children('ul').fadeToggle('fast');
		$(this).toggleClass('menuPlus');
		$(this).toggleClass('menuMinus');
            }
	    if ($(event).get(0).target.tagName.toLowerCase() == "a") {
	      return true; // we want links to be clickable
	    } else {
              return false;
	    }
        })
        .children('ul').hide();

});
</script>
<title>An Overview of Memory Optimisation and Performance</title></head><body><h1 id="Scales_Xml_Memory_Optimisation">Scales Xml Memory Optimisation</h1><h2 id="Disclaimer">Disclaimer</h2><p>Measuring and comparing XML models is fraught with difficulty and will often vary based on individual XML documents and application behaviour. </p><h2 id="Introduction">Introduction</h2><p>A basic premise of Scales Xml is to separate the structure of XML from its contents, allowing optimisation on both axes.  Due to the Elem also being the child node container scala.xml can only leverage identical subtrees, not individual elements.  scala.xml can also optimise via string inlining and namespace map caching, which is much more likely than optimising the subtrees during a parse.</p><p>The speed of parsing is also directly related to how much garbage is produced during the parse.  For example pre 0.1 versions of Scales used Path directly to build the resulting tree, creating many intermediate Path objects - 99.9% of which were immediately ready for garbage collection.  Swapping this into a mutable stack of mutable trees improved parsing performance 20-30%.</p><p>Scales takes a flexible approach to memory management allowing the user to tune how much work is performed to reduce allocations during the parse and total resulting memory usage.</p><p>It should also be noted that the memory usage for a non deferred Xerces DOM is high enough that parsing a 6MB message (on disk, 12MB in memory, Recon 40,000) is only possible with -Xm135M, whereas Scales can process this with -Xmx102M.  Indeed for -Xm135M Scales can parse a Recon of 53,000 yielding a Doc of 46Mb (from 16MB xml).</p><p>Although Scales allows customisable memory optimisation strategies the base children IndexedSeq is already optimised for memory usage.  Vector is appropriate for large structures (&gt; 30 records) but inappropriate for smaller collections, taking many Mb of unnecessary memory usage.</p><p>The same is true of a simple immutable array, the costs are too high for items less than 4 in size.</p><p>As such Scales provides an abstraction around array like IndexedSeq - ImmutableArrayProxy, which provides a One, Two and Three Seq, an ImmutableArray for less than 32 and a Vector wrapper for greater than 32.  There is also ImmutableArrayAll, which reduces offset information to further reduce memory usage.</p><p>A last concession to memory performance (and CPU performance) was the replacement of Either as a container and the creating of EitherLike.  EitherLike has the similar properties but is a trait applied to classes, fold and projections are still present but the memory usage from the level of indirection is removed.  Tests showed that 10-15% of the memory usage was held purely by the Either ADT, and performance was around 4-5% impact across the board.</p><h2 id="Options_for_memory_optimisation">Options for memory optimisation</h2><p>Scales Xml's separation of structure and content in particular allows the following areas of memory optimisation:</p><ul><li>QNames</li><li>Attributes</li><li>Elems</li><li>Subtrees</li><li>Structure</li></ul><p>During several optimisation rounds it was clear that the largest wins were due to QName and simple Elem (no attributes or namespaces) usage, and as such forms basis for the default parsing behaviour. </p><p>QNames often repeat during individual XML documents and, of course, across them in a given domain.  QNames can also be shared between Attributes and Elems.  There are two direct benefits of optimising at the QName/ level:</p><ol><li>Reduced memory consumption</li><li>Reduced garbage during parsing</li></ol><p>However the time taken to cache QNames is significant for smaller documents (e.g. 150-200 elements) where typically any garbage effects are less likely to impact performance.</p><p>The below diagrams illustrate the relative parsing performance of Scales Xml against Scala XML (2.9.1) and the two common Xerces implementations.  For all sizes of documents Scales is notably faster than Scala XML, and for larger documents it is considerable faster.</p><dl><dd><img title="Parsing Performance Of Smaller XML" alt="Parsing Performance Of Smaller XML" border="0" src="img/parsing_perf_small_recon.png"/></dd></dl><dl><dd><img title="Parsing Performance Of Larger XML" alt="Parsing Performance Of Larger XML" border="0" src="img/parsing_perf_large_recon.png"/></dd></dl><p>The most important point is that the developer has a choice, when needed, in how to optimise and that Scales allows the developer to easily enhance the default optimisations.  The defaults use a thread safe singleton to cache, but developers can also choose to implement a ThreadLocal or a per parse strategy if it better fits.  If in doubt profile.</p><h2 id="Resulting_Sizes">Resulting Sizes</h2><p>The Recon test (See ParsingPerformance - PerfData.reconDoc) favours the default Scales Xml memory optimisation as it does not contain attributes, however it is taken from a real world scenario.  The 40,000 Recon size is chosen to demonstrate the resulting memory sizes (NB obtained by the excellent Yourkit profiler):</p><dl><dd><img title="Memory Usage" alt="Memory Usage" border="0" src="img/memory_usage_recon40.png"/></dd></dl><p>As can be seen the size of the Non Optimised version is very large at 65.3MB, whereas the default optimisation (which is also 15-20% faster on larger documents) is roughly halve the size. NB The resulting QName and Elem caches are 2.24KB and 2.18KB respectively, showing more than a clear space saving.</p><p>In fact, in addition to being 10MB less than Scala XML for the same document, it comes in at slightly less memory cost as the Xerces deferred DOM impl.</p><p>This benefit in memory reduction can also be extended to full Elem caching but this reduces the overall performance by up to 15%, putting it around (and sometimes below) the parsing performance of Scala XML.  The potential memory savings are also limited by how often the attribute or namespace values are identical, and it is often better to simply cache attribute values if there is a restricted range available.</p><h2 id="Overall_Parsing_Performance">Overall Parsing Performance</h2><p>The overall parsing performance of Scales Xml, with default Optimisation, is around 10-20% faster than Scala XML and a similar amount slower than JAXP.</p><p>The larger the amount of data and the level of repeated structure the faster Scales Xml can parse.</p><h2 id="Special_Case_-_Pull_Parsing_via_onQNames">Special Case - Pull Parsing via onQNames</h2><p>A key feature of Scales is the XML Pull (via StAX) based parsing that leverages Scalaz Iteratees.  A shining example of this being onQNames, the recon file being a driving force behind its design.</p><p>In the recon example what is actually interesting is three simple hash maps (Int -&gt; Int), as such the memory usage of a onQNames -&gt; map was examined.  Both the overall resulting savings (over a full tree) and the runtime memory requirements to parse are examined using the following code:</p><pre class="language-scala">
    object Recon {
      import PerfData.ns

      val Part = List(ns("Recon"), ns("Parts"), ns("Part"))
      val Bom = List(ns("Recon"), ns("BOMs"), ns("BOM"))
      val Rec = List(ns("Recon"), ns("Records"), ns("Record"))

      val id = ns("id")
      val version = ns("version")

    }

    case class Recon(val parts : Map[Int, Int], 
		 val boms : Map[Int, Int],
		 val recs : Map[Int, Int])


    import Recon._
    import Functions._

    val xml = pullXml(new java.io.StringReader(s)).it
    foldOnDone( xml )( Recon(), 
		      onDone( List(onQNames(Part), 
				   onQNames(Bom), 
				   onQNames(Rec)) )) {
      (recon, qNamesMatch) =&gt; 
	if (qNamesMatch.size == 0)
	  recon
	else {
	  // we expect only one to match in this pattern	  
	  val matched = qNamesMatch.head
	  val qnames = matched._1  // to get an onDone it must be defined
	  val x = matched._2.get
	  // only one child
	  val pair = (text(x.\*(id)).toInt, text(x.\*(version)).toInt)

	  qnames match {
	    case Part =&gt; recon.copy( parts = recon.parts + pair )
	    case Bom =&gt; recon.copy( boms = recon.boms + pair )
	    case Rec =&gt; recon.copy( recs = recon.recs + pair )
	  }
	}			   
    
    }

</pre><p>In short the memory requirements for the maps are 13.7MB, whereas the test itself can run in under 45MB, albeit with a high GC overhead. As such thats roughly 25MB required to actually parse the entire document in such a high level api.</p><p><i>Also worth noting is that it takes 42MB to generate the document</i></p><p>See the <a href="PullParsing.html">Pull Parsing</a>, <a href="RepeatedSections.html">Pulling Repeated Sections</a> and the PullTests themselves for examples on how this approach can be best leveraged in your code.</p><div id="scales-site-menubar"><h1 id="Scales_Xml_0.3-RC6">Scales Xml 0.3-RC6</h1><h2 id="Generated_Documentation">Generated Documentation</h2><ul><li><a href="./api.sxr/index.html">SXR Source</a></li><li><a href="./doc/index.html">ScalaDocs</a></li></ul><h2 id="Documentation_Highlights">Documentation Highlights</h2><ul><li><a href="./ScalesXmlIntro.html">Overview</a></li><li><a href="./MemoryOptimisation.html">Memory and Performance</a></li></ul><dl><dt><b>First Steps</b><ul><li><a href="Setup.html">Setup</a></li><li><a href="HowToUse.html">How To Use</a></li></ul></dt></dl><dl><dt><b>Xml Model</b><ul><li><a href="QNames.html">QNames</a><ul><li><a href="QNames.html#Creating_QNames">Creating QNames</a><ul><li><a href="QNames.html#Directly">Directly</a></li><li><a href="QNames.html#Implicits">With Sugar</a></li></ul></li><li><a href="QNames.html#Namespaces_.26_Scope">Namespaces &amp; Scope</a></li><li><a href="QNames.html#Namespaces_in_Scales">Namespaces in Scales</a></li><li><a href="QNames.html#QNames_in_Scales_-_Let_the_compiler_help_us">Type System FTW</a></li><li><a href="QNames.html#Runtime_Validation">Runtime Validation</a></li><li><a href="QNames.html#Equality">Equality</a><ul><li><a href="QNames.html#Scalaz_Equal_and_Scales_Equiv">via Scalaz Equal and Scales Equiv</a></li></ul></li><li><a href="QNames.html#Testing_For_QNames">Testing For QNames</a></li><li><a href="QNames.html#Serializing_QNames">Serializing QNames</a></li></ul></li><li><a href="XmlVersionSupport.html">XML Version Support</a><ul><li><a href="XmlVersionSupport.html#Differences_Between_1.0_and_1.1">Differences Between Xml 1.0 and 1.1</a></li><li><a href="XmlVersionSupport.html#How_Does_Scales_Allow_Both_Versions_.3F">Scales Support for Both Versions</a><ul><li><a href="XmlVersionSupport.html#In_Parser_We_Trust_-_Users_We_Protect">In Parser We Trust - Users We Protect</a></li><li><a href="XmlVersionSupport.html#Runtime_XmlVersion_QName_Related_Correctness">Runtime XmlVersion QName Related Correctness</a></li></ul></li></ul></li><li><a href="Attributes.html">Attributes</a><ul><li><a href="Attributes.html#Defining_an_Attribute">Defining</a><ul><li><a href="Attributes.html#Explicitly">Explicitly</a></li><li><a href="Attributes.html#Implicitly">Implicitly</a></li></ul></li><li><a href="Attributes.html#Equality">Equality</a><ul><li><a href="Attributes.html#Within_an_Elem">Within an Elem</a></li><li><a href="Attributes.html#Attributes_ListSet">Attributes ListSet</a></li></ul></li><li><a href="Attributes.html#Testing_Against_QNames_or_Namespaces">Testing Against QNames or Namespaces</a></li></ul></li><li><a href="Elem.html">Elem</a><ul><li><a href="Elem.html#XML_Elements">XML Elements</a></li><li><a href="Elem.html#Declaring">Declaring</a></li><li><a href="Elem.html#QName_And_Namespace_Correctness">QName And Namespace Correctness</a></li><li><a href="Elem.html#Elems_Are_Reusable">Elems Are Reusable</a></li><li><a href="Elem.html#Runtime_Validation_Checks">Runtime Validation Checks</a></li></ul></li><li><a href="XmlItem.html">XmlItem</a><ul><li><a href="XmlItem.html#Declaring">Declaring</a></li><li><a href="XmlItem.html#XmlItems_Are_Reusable">XmlItems Are Reusable</a></li><li><a href="XmlItem.html#Runtime_Correctness_Checks">Runtime Correctness Checks</a></li><li><a href="XmlItem.html#Serializing_XmlItems">Serializing XmlItems</a><ul><li><a href="XmlItem.html#Serializing_CData">Serializing CData</a></li></ul></li></ul></li><li><a href="XmlDsl.html">Xml DSL and Trees</a><ul><li><a href="XmlDsl.html#Tour_of_the_DSL">Tour of the DSL</a></li><li><a href="XmlDsl.html#Creating_a_Tree">Creating a Tree</a></li><li><a href="XmlDsl.html#Adding_To_The_Tree">Adding To The Tree</a></li><li><a href="XmlDsl.html#Adding_an_Attribute">Adding an Attribute</a></li><li><a href="XmlDsl.html#Setting_Text">Setting Text</a></li><li><a href="XmlDsl.html#Removing_Children">Removing Children</a></li><li><a href="XmlDsl.html#Removing_Attributes">Removing Attributes</a></li><li><a href="XmlDsl.html#Folding_Within_The_DSL">Folding Within The DSL</a></li></ul></li></ul></dt></dl><dl><dt><b>Accessing and Querying Data</b><ul><li><a href="XPathFunctions.html">XPath Functions</a><ul><li><a href="XPathFunctions.html#Organisation">Organisation</a></li><li><a href="XPathFunctions.html#Using">Using</a></li><li><a href="XPathFunctions.html#QName_Functions">QName Functions</a></li><li><a href="XPathFunctions.html#Text_Functions">Text Functions</a></li><li><a href="XPathFunctions.html#Boolean_Function">Boolean Function</a></li></ul></li><li><a href="XPaths.html">XPath Embedded DSL</a><ul><li><a href="XPaths.html#Simple_Usage_Examples">Simple Usage Examples</a></li><li><a href="XPaths.html#XPath_Axe">XPath Axe</a></li><li><a href="XPaths.html#Node_Tests">Node Tests</a></li><li><a href="XPaths.html#Predicates">Predicates</a><ul><li><a href="XPaths.html#Positional_Predicates">Positional Predicates</a></li><li><a href="XPaths.html#Direct_Filtering">Direct Filtering</a></li></ul></li><li><a href="XPaths.html#Unsorted_Results_and_Views">Unsorted Results and Views</a></li></ul></li><li><a href="StringXPaths.html">XPath 1.0 String Evaluation</a><ul><li><a href="StringXPaths.html#How_To_Use">How To Use</a></li><li><a href="StringXPaths.html#Other_Jaxen_Tricks">Other Jaxen Tricks</a></li></ul></li></ul></dt></dl><dl><dt><b>Parsing XML</b><ul><li><a href="FullParsing.html">Full XML Doc Parsing</a></li><li><a href="PullParsing.html">Pull Parsing</a><ul><li><a href="PullParsing.html#Pull_Model">Pull Model</a></li><li><a href="PullParsing.html#Resource_Management">Resource Management</a></li><li><a href="PullParsing.html#Simple_Reading_Of_Repeated_Sections">Simple Reading Of Repeated Sections</a></li><li><a href="PullParsing.html#Buffering_And_Identifying_Xml_Messages">Buffering And Identifying Xml Messages</a></li></ul></li><li><a href="RepeatedSections.html">Pulling Repeated Sections</a><ul><li><a href="RepeatedSections.html#Supported_Repeating_Section_Examples">Supported Repeating Section Examples</a><ul><li><a href="RepeatedSections.html#alternating_and_Repeating_Elements">Alternating and Repeating Elements</a></li><li><a href="RepeatedSections.html#Grouped_Repeating">Grouped Repeating</a></li><li><a href="RepeatedSections.html#Repeating_Nested">Repeating Nested</a></li><li><a href="RepeatedSections.html#Sectioned_Grouped_Repeated">Sectioned Grouped Repeating</a></li></ul></li><li><a href="RepeatedSections.html#Pull_Parsing_ResumableIter.27atees">Pull Parsing ResumableIter'atees</a></li></ul></li></ul></dt></dl><dl><dt><b>Serializing &amp; Transforming XML</b><ul><li><a href="SerializingIntro.html">Serializing</a><ul><li><a href="SerializingIntro.html#writeTo_.26_writeTo">writeTo &amp; writeTo</a></li><li><a href="SerializingIntro.html#What_Can_Be_Serialized.3F">What Can Be Serialized?</a></li></ul></li><li><a href="Folding.html">Folding Xml</a><ul><li><a href="Folding.html#PathFoldR_-_Catchy_Result_Type">PathFoldR - Catchy Result Type</a></li><li><a href="Folding.html#Composing_Transformations">Composing Transformations</a><ul><li><a href="Folding.html#ReplaceWith_-_Nested"> ReplaceWith - Nested</a></li><li><a href="Folding.html#.26_-_Fail_Early">&amp; - Fail Early</a></li><li><a href="Folding.html#.7C_-_Try_The_Next">| - Try The Next</a></li></ul></li></ul></li><li><a href="XSLT.html">TrAX &amp; XSLT Support</a><ul><li><a href="XSLT.html#Simple_Usage_Example">Simple Usage Example</a></li></ul></li></ul></dt></dl><dl><dt><b>Xml Equality</b><ul><li><a href="EqualityBasics.html">Xml Equality Basics</a><ul><li><a href="EqualityBasics.html#How_To_Use">How To Use</a></li><li><a href="EqualityBasics.html#Types_Covered">Types Covered</a></li><li><a href="EqualityBasics.html#Why_Join_Adjacent_Text_and_CData.3F">Why Join Adjacent Text and CData?</a></li><li><a href="EqualityBasics.html#Removing_Comments_And_PIs">Removing Comments and PIs</a></li><li><a href="EqualityBasics.html#Why_Not_Use_Canonical_Xml.3F">Why Not Use Canonical Xml?</a></li></ul></li><li><a href="XmlComparison.html">XmlComparison - Where Is It Different?</a><ul><li><a href="XmlComparison.html#The_compare_Function">The compare Function</a><ul><li><a href="XmlComparison.html#The_calculate_Parameter">The calculate Parameter</a></li><li><a href="XmlComparison.html#ComparisonContext">ComparisonContext</a></li><li><a href="XmlComparison.html#Return_Value">Return Value</a></li></ul></li><li><a href="XmlComparison.html#XmlDifference">XmlDifference</a></li><li><a href="XmlComparison.html#QName_Token_Handling">QName Token Handling</a></li></ul></li></ul></dt></dl><dl><dt><b>Technical Details</b><ul><li><a href="MemoryOptimisation.html">Memory Optimisation</a><ul><li><a href="MemoryOptimisation.html#Disclaimer">Disclaimer</a></li><li><a href="MemoryOptimisation.html#Introduction">Introduction</a></li><li><a href="MemoryOptimisation.html#Options_for_memory_optimisation">Options for memory optimisation</a></li><li><a href="MemoryOptimisation.html#Resulting_Sizes">Resulting Sizes</a></li><li><a href="MemoryOptimisation.html#Overall_Parsing_Performance">Overall Parsing Performance</a></li><li><a href="MemoryOptimisation.html#Special_Case_-_Pull_Parsing_via_onQNames">Special Case - Pull Parsing via onQNames</a></li></ul></li><li><a href="Serialization.html">Serializing Details</a><ul><li><a href="Serialization.html#Encoding">Encoding</a><ul><li><a href="Serialization.html#XML_Names">XML Names</a></li><li><a href="Serialization.html#Text_Data">Text Data</a></li><li><a href="Serialization.html#Other_Markup_Character_Data">Other Markup Character Data</a></li></ul></li><li><a href="Serialization.html#Creating_a_SerializerFactory">Creating a SerializerFactory</a></li></ul></li></ul></dt></dl></div></body></html>