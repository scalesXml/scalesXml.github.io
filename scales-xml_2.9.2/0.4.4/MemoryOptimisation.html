<?xml version='1.0' encoding='utf-8' ?><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=8" /><link href="./scales_base.css" rel="stylesheet" type="text/css" media="screen" /><link href="./site_docs.css" rel="stylesheet" type="text/css" media="screen" /><link href="./highlight/styles/idea.css" rel="stylesheet" type="text/css" media="screen" /><script src="./jquery.js" type="text/javascript"></script><script src="./highlight/highlight.pack.js" type="text/javascript"></script><script type="text/javascript">
$(function() {
$("pre[class^='language-']").each(function(i,elem) {
  var clazz = $(elem).attr('class');
  var str = elem.innerHTML//.replace(/\r\n|\r|\n/g,"<br/>");
  // Workaround for IE <PRE> innerHTML normalization quirk
  if (elem.tagName == "PRE" && "outerHTML" in elem)
    {
      elem.outerHTML = "<PRE><CODE class='"+clazz+"'>" + str + "</CODE></PRE>";
    }
  else
    {
      elem.innerHTML = "<CODE class='"+clazz+"'>" + str + "</CODE>"; //.replace(/\r\n|\r|\n/g,"<br/>");;
    }
});
  hljs.initHighlighting();
});
</script>
<link href="./menubar.css" rel="stylesheet" type="text/css" media="screen" />
  <script type="text/javascript">
  $(function(){

  $('#scales-site-menubar li:has(ul)').toggleClass('menuPlus');
  $('#scales-site-menubar ul').children('li:has(ul)').click(function(event){
            if (this == event.target) {                
                $(this).children('ul').fadeToggle('fast');
		$(this).toggleClass('menuPlus');
		$(this).toggleClass('menuMinus');
            }
	    if ($(event).get(0).target.tagName.toLowerCase() == "a") {
	      return true; // we want links to be clickable
	    } else {
              return false;
	    }
        })
        .children('ul').hide();

});
</script>
<title>An Overview of Memory Optimisation and Performance</title></head><body><h1 id="Scales_Xml_Optimisation">Scales Xml Optimisation</h1><h2 id="Disclaimer">Disclaimer</h2><p>Measuring and comparing XML models is fraught with difficulty and will often vary based on individual XML documents and application behaviour. </p><h2 id="Introduction">Introduction</h2><p>A basic premise of Scales Xml is to separate the structure of XML from its contents, allowing optimisation on both axes.  Due to the Elem also being the child node container scala.xml can only leverage identical subtrees, not individual elements.</p><p>The speed of parsing is also directly related to how much garbage is produced during the parse.  For example pre 0.1 versions of Scales used Path directly to build the resulting tree, creating many intermediate Path objects - 99.9% of which were immediately ready for garbage collection.  Swapping this into a mutable stack of mutable trees improved parsing performance 20-30%.</p><p>Scales takes a flexible approach to memory management allowing the user to tune how much work is performed to reduce allocations during the parse and total resulting memory usage.</p><h2 id="Options_for_memory_optimisation">Options for memory optimisation</h2><p>Scales Xml's separation of structure and content in particular allows the following areas of memory optimisation:</p><ul><li>QNames</li><li>Attributes</li><li>Elems</li><li>Subtrees</li><li>Structure</li></ul><p>During several optimisation rounds it was clear that the largest wins were due to QName and simple Elem (no attributes or namespaces) usage, and as such forms basis for the default parsing behaviour. </p><p>QNames often repeat during individual XML documents and, of course, across them in a given domain.  QNames can also be shared between Attributes and Elems.  There are two direct benefits of optimising at the QName/ level:</p><ol><li>Reduced memory consumption</li><li>Reduced garbage during parsing</li></ol><p>However the time taken to cache QNames is significant for smaller documents (e.g. 150-200 elements) where typically any garbage effects are less likely to impact performance.</p><p>The below diagrams illustrate the relative parsing performance of Scales Xml against Scala XML (2.9.1) and the two common Xerces implementations.  For all sizes of documents Scales is notably faster than Scala XML, and for larger documents it is considerable faster.</p><dl><dd><img title="Parsing Performance Of Smaller XML" alt="Parsing Performance Of Smaller XML" border="0" src="img/parsing_perf_small_recon.png"/></dd></dl><dl><dd><img title="Parsing Performance Of Larger XML" alt="Parsing Performance Of Larger XML" border="0" src="img/parsing_perf_large_recon.png"/></dd></dl><p>The most important point is that the developer has a choice, when needed, in how to optimise and that Scales allows the developer to easily enhance the default optimisations.  The defaults use a thread safe singleton to cache, but developers can also choose to implement a ThreadLocal or a per parse strategy if it better fits.  If in doubt profile.</p><h2 id="Resulting_Sizes">Resulting Sizes</h2><p>The Recon test (See ParsingPerformance - PerfData.reconDoc) approximates a few real world problems tackled by Scales has very few attributes and a flat structure.  The 40,000 Recon size is chosen to demonstrate the resulting memory sizes (obtained by the excellent Yourkit profiler):</p><dl><dd><img title="Memory Usage" alt="Memory Usage" border="0" src="img/memory_usage_recon40.png"/></dd></dl><p>The default optimisation (which is also 10-20% faster on larger documents than Scala) strikes a very good balance between speed and memory usage.  The Scales parsing optimisations also result in QName and Elem cache sizes of 2.24KB and 2.18KB respectively (the Elem caches are used by HighMemory and QNameElemTree Optimisations), showing more than a clear space saving.</p><p>The slightly slower to parse (but still faster than Scala XML) Tree based optimisations reduce immediate memory usage by over 15Mb less than Scala XML for the same document, in fact the two Tree optimisations also consume 5Mb less than the Xerces deferred DOM impl.</p><p>Full Elem caching alone (not including Elem + Tree) reduces the overall performance by up to 15%, putting it around (and sometimes below) the parsing performance of Scala XML.  The potential memory savings are also limited by how often the attribute or namespace values are identical, and it is often better to simply cache attribute values if there is a restricted range available.</p><p>See <a href="OptimisationDetails.html#QName_and_Elem_Memory_Usage">QName and Elem Memory Usage</a> for more details on default memory saving.</p><h2 id="Memory_Consumption_During_Parsing">Memory Consumption During Parsing</h2><p>The memory consumed by Scales in its default configuration is close to or better than Xerces / JAXP default without the nasty expansion upon using it.</p><dl><dd><img title="Memory Usage During Parsing" alt="Memory Usage During Parsing" border="0" src="img/memory_usage_during_parsing.png"/></dd></dl><p>However as can be seen above the memory usage can be substantially reduced, in a similar fashion to Xerces Deferred processing (albeit immutably so).</p><h2 id="Overall_Parsing_Performance">Overall Parsing Performance</h2><p>The overall parsing performance of Scales Xml, with default Optimisation, is around 20-25% faster than Scala XML for small to mid size documents to 40-45% faster for larger documents.</p><p>The larger the amount of data and the level of repeated structure the greater the difference in Scales Xml parsing performance.</p><p>Scales is less than 10% slower than JAXP Deferred for smaller documents and for larger documents up to 30% slower.  For fully parsed documents however its less than 5% slower for smaller documents and up to 30% faster for larger docs.</p><h2 id="Special_Case_-_Pull_Parsing_via_onQNames">Special Case - Pull Parsing via onQNames</h2><p>A key feature of Scales is the XML Pull (via StAX) based parsing that leverages Scalaz Iteratees.  A shining example of this being onQNames, the recon file being a driving force behind its design.</p><p>In the recon example what is actually interesting is three simple hash maps (Int -&gt; Int), as such the memory usage of a onQNames -&gt; map was examined.  Both the overall resulting savings (over a full tree) and the runtime memory requirements to parse are examined using the following code:</p><pre class="language-scala">
    object Recon {
      import PerfData.ns

      val Part = List(ns("Recon"), ns("Parts"), ns("Part"))
      val Bom = List(ns("Recon"), ns("BOMs"), ns("BOM"))
      val Rec = List(ns("Recon"), ns("Records"), ns("Record"))

      val id = ns("id")
      val version = ns("version")

    }

    case class Recon(val parts : Map[Int, Int], 
		 val boms : Map[Int, Int],
		 val recs : Map[Int, Int])


    import Recon._
    import Functions._

    val xml = pullXml(new java.io.StringReader(s)).it
    foldOnDone( xml )( Recon(), 
		      onDone( List(onQNames(Part), 
				   onQNames(Bom), 
				   onQNames(Rec)) )) {
      (recon, qNamesMatch) =&gt; 
	if (qNamesMatch.size == 0)
	  recon
	else {
	  // we expect only one to match in this pattern	  
	  val matched = qNamesMatch.head
	  val qnames = matched._1  // to get an onDone it must be defined
	  val x = matched._2.get
	  // only one child
	  val pair = (text(x.\*(id)).toInt, text(x.\*(version)).toInt)

	  qnames match {
	    case Part =&gt; recon.copy( parts = recon.parts + pair )
	    case Bom =&gt; recon.copy( boms = recon.boms + pair )
	    case Rec =&gt; recon.copy( recs = recon.recs + pair )
	  }
	}			   
    
    }

</pre><p>In short the memory requirements for the maps are 13.7MB, whereas the test itself can run in under 45MB, albeit with a high GC overhead. As such thats roughly 25MB required to actually parse the entire document in such a high level api.</p><p><i>Also worth noting is that it takes 42MB to generate the document</i></p><p>See the <a href="PullParsing.html">Pull Parsing</a>, <a href="RepeatedSections.html">Pulling Repeated Sections</a> and the PullTests themselves for examples on how this approach can be best leveraged in your code.</p><div id="scales-site-menubar"><h1 id="Scales_Xml_0.4.4">Scales Xml 0.4.4</h1><h2 id="Generated_Documentation">Generated Documentation</h2><ul><li><a href="./api.sxr/index.html">SXR Source</a></li><li><a href="./doc/index.html">ScalaDocs</a></li></ul><h2 id="Documentation_Highlights">Documentation Highlights</h2><ul><li><a href="./ScalesXmlIntro.html">Overview</a></li><li><a href="./MemoryOptimisation.html">Memory and Performance</a></li></ul><dl><dt><b>First Steps</b><ul><li><a href="Setup.html">Setup</a></li><li><a href="HowToUse.html">How To Use</a></li></ul></dt></dl><dl><dt><b>Xml Model</b><ul><li><a href="QNames.html">QNames</a><ul><li><a href="QNames.html#Creating_QNames">Creating QNames</a><ul><li><a href="QNames.html#Directly">Directly</a></li><li><a href="QNames.html#Implicits">With Sugar</a></li></ul></li><li><a href="QNames.html#Namespaces_.26_Scope">Namespaces &amp; Scope</a></li><li><a href="QNames.html#Namespaces_in_Scales">Namespaces in Scales</a></li><li><a href="QNames.html#QNames_in_Scales_-_Let_the_compiler_help_us">Type System FTW</a></li><li><a href="QNames.html#Runtime_Validation">Runtime Validation</a></li><li><a href="QNames.html#Equality">Equality</a><ul><li><a href="QNames.html#Scalaz_Equal_and_Scales_Equiv">via Scalaz Equal and Scales Equiv</a></li></ul></li><li><a href="QNames.html#Testing_For_QNames">Testing For QNames</a></li><li><a href="QNames.html#Serializing_QNames">Serializing QNames</a></li></ul></li><li><a href="XmlVersionSupport.html">XML Version Support</a><ul><li><a href="XmlVersionSupport.html#Differences_Between_1.0_and_1.1">Differences Between Xml 1.0 and 1.1</a></li><li><a href="XmlVersionSupport.html#How_Does_Scales_Allow_Both_Versions_.3F">Scales Support for Both Versions</a><ul><li><a href="XmlVersionSupport.html#In_Parser_We_Trust_-_Users_We_Protect">In Parser We Trust - Users We Protect</a></li><li><a href="XmlVersionSupport.html#Runtime_XmlVersion_QName_Related_Correctness">Runtime XmlVersion QName Related Correctness</a></li></ul></li></ul></li><li><a href="Attributes.html">Attributes</a><ul><li><a href="Attributes.html#Defining_an_Attribute">Defining</a><ul><li><a href="Attributes.html#Explicitly">Explicitly</a></li><li><a href="Attributes.html#Implicitly">Implicitly</a></li></ul></li><li><a href="Attributes.html#Equality">Equality</a><ul><li><a href="Attributes.html#Within_an_Elem">Within an Elem</a></li><li><a href="Attributes.html#Attributes_ListSet">Attributes ListSet</a></li></ul></li><li><a href="Attributes.html#Testing_Against_QNames_or_Namespaces">Testing Against QNames or Namespaces</a></li></ul></li><li><a href="Elem.html">Elem</a><ul><li><a href="Elem.html#XML_Elements">XML Elements</a></li><li><a href="Elem.html#Declaring">Declaring</a></li><li><a href="Elem.html#QName_And_Namespace_Correctness">QName And Namespace Correctness</a></li><li><a href="Elem.html#Elems_Are_Reusable">Elems Are Reusable</a></li><li><a href="Elem.html#Runtime_Validation_Checks">Runtime Validation Checks</a></li></ul></li><li><a href="XmlItem.html">XmlItem</a><ul><li><a href="XmlItem.html#Declaring">Declaring</a></li><li><a href="XmlItem.html#XmlItems_Are_Reusable">XmlItems Are Reusable</a></li><li><a href="XmlItem.html#Runtime_Correctness_Checks">Runtime Correctness Checks</a></li><li><a href="XmlItem.html#Serializing_XmlItems">Serializing XmlItems</a><ul><li><a href="XmlItem.html#Serializing_CData">Serializing CData</a></li></ul></li></ul></li><li><a href="XmlDsl.html">Xml DSL and Trees</a><ul><li><a href="XmlDsl.html#Tour_of_the_DSL">Tour of the DSL</a></li><li><a href="XmlDsl.html#Creating_a_Tree">Creating a Tree</a></li><li><a href="XmlDsl.html#Adding_To_The_Tree">Adding To The Tree</a></li><li><a href="XmlDsl.html#Adding_an_Attribute">Adding an Attribute</a></li><li><a href="XmlDsl.html#Setting_Text">Setting Text</a></li><li><a href="XmlDsl.html#Removing_Children">Removing Children</a></li><li><a href="XmlDsl.html#Removing_Attributes">Removing Attributes</a></li><li><a href="XmlDsl.html#Optional_XML">Optional XML</a></li><li><a href="XmlDsl.html#Folding_Within_The_DSL">Folding Within The DSL</a></li></ul></li></ul></dt></dl><dl><dt><b>Accessing and Querying Data</b><ul><li><a href="XPaths.html">XPath Embedded DSL</a><ul><li><a href="XPaths.html#Simple_Usage_Examples">Simple Usage Examples</a></li><li><a href="XPaths.html#XPath_Crash_Course">XPath Crash Course</a></li><li><a href="XPaths.html#XPath_Axe">XPath Axe</a></li><li><a href="XPaths.html#Node_Tests">Node Tests</a></li><li><a href="XPaths.html#Predicates">Predicates</a><ul><li><a href="XPaths.html#Predicate_Construction">Predicate Construction</a></li><li><a href="XPaths.html#Chaining_Predicates">Chaining Predicates</a></li><li><a href="XPaths.html#Positional_Predicates">Positional Predicates</a></li><li><a href="XPaths.html#Direct_Filtering">Direct Filtering</a></li></ul></li><li><a href="XPaths.html#Unsorted_Results_and_Views">Unsorted Results and Views</a></li></ul></li><li><a href="XPathFunctions.html">XPath Functions</a><ul><li><a href="XPathFunctions.html#Organisation">Organisation</a></li><li><a href="XPathFunctions.html#Using">Using</a></li><li><a href="XPathFunctions.html#QName_Functions">QName Functions</a></li><li><a href="XPathFunctions.html#Text_Functions">Text Functions</a></li><li><a href="XPathFunctions.html#Boolean_Function">Boolean Function</a></li></ul></li><li><a href="StringXPaths.html">XPath 1.0 String Evaluation</a><ul><li><a href="StringXPaths.html#How_To_Use">How To Use</a></li><li><a href="StringXPaths.html#Other_Jaxen_Tricks">Other Jaxen Tricks</a></li></ul></li></ul></dt></dl><dl><dt><b>Parsing XML</b><ul><li><a href="FullParsing.html">Full XML Doc Parsing</a><ul><li><a href="FullParsing.html#Direct_SAX_XMLReader_Usage">Direct SAX XMLReader Usage</a></li></ul></li><li><a href="PullParsing.html">Pull Parsing</a><ul><li><a href="PullParsing.html#Pull_Model">Pull Model</a></li><li><a href="PullParsing.html#Resource_Management">Resource Management</a></li><li><a href="PullParsing.html#Simple_Reading_Of_Repeated_Sections">Simple Reading Of Repeated Sections</a></li><li><a href="PullParsing.html#Buffering_And_Identifying_Xml_Messages">Buffering And Identifying Xml Messages</a></li></ul></li><li><a href="RepeatedSections.html">Pulling Repeated Sections</a><ul><li><a href="RepeatedSections.html#Supported_Repeating_Section_Examples">Supported Repeating Section Examples</a><ul><li><a href="RepeatedSections.html#alternating_and_Repeating_Elements">Alternating and Repeating Elements</a></li><li><a href="RepeatedSections.html#Grouped_Repeating">Grouped Repeating</a></li><li><a href="RepeatedSections.html#Repeating_Nested">Repeating Nested</a></li><li><a href="RepeatedSections.html#Sectioned_Grouped_Repeated">Sectioned Grouped Repeating</a></li></ul></li><li><a href="RepeatedSections.html#Pull_Parsing_ResumableIter.27atees">Pull Parsing ResumableIter'atees</a></li></ul></li></ul></dt></dl><dl><dt><b>Serializing &amp; Transforming XML</b><ul><li><a href="SerializingIntro.html">Serializing</a><ul><li><a href="SerializingIntro.html#writeTo_.26_writeTo">writeTo &amp; writeTo</a></li><li><a href="SerializingIntro.html#What_Can_Be_Serialized.3F">What Can Be Serialized?</a></li></ul></li><li><a href="Folding.html">Folding Xml</a><ul><li><a href="Folding.html#PathFoldR_-_Catchy_Result_Type">PathFoldR - Catchy Result Type</a></li><li><a href="Folding.html#Composing_Transformations">Composing Transformations</a><ul><li><a href="Folding.html#ReplaceWith_-_Nested"> ReplaceWith - Nested</a></li><li><a href="Folding.html#.26_-_Fail_Early">&amp; - Fail Early</a></li><li><a href="Folding.html#.7C_-_Try_The_Next">| - Try The Next</a></li></ul></li></ul></li><li><a href="XSLT.html">TrAX &amp; XSLT Support</a><ul><li><a href="XSLT.html#Simple_Usage_Example">Simple Usage Example</a></li></ul></li></ul></dt></dl><dl><dt><b>Xml Equality</b><ul><li><a href="EqualityBasics.html">Xml Equality Basics</a><ul><li><a href="EqualityBasics.html#How_To_Use">How To Use</a></li><li><a href="EqualityBasics.html#Types_Covered">Types Covered</a></li><li><a href="EqualityBasics.html#Why_Join_Adjacent_Text_and_CData.3F">Why Join Adjacent Text and CData?</a></li><li><a href="EqualityBasics.html#Removing_Comments_And_PIs">Removing Comments and PIs</a></li><li><a href="EqualityBasics.html#Why_Not_Use_Canonical_Xml.3F">Why Not Use Canonical Xml?</a></li></ul></li><li><a href="XmlComparison.html">XmlComparison - Where Is It Different?</a><ul><li><a href="XmlComparison.html#The_compare_Function">The compare Function</a><ul><li><a href="XmlComparison.html#The_calculate_Parameter">The calculate Parameter</a></li><li><a href="XmlComparison.html#ComparisonContext">ComparisonContext</a></li><li><a href="XmlComparison.html#Return_Value">Return Value</a></li></ul></li><li><a href="XmlComparison.html#XmlDifference">XmlDifference</a></li><li><a href="XmlComparison.html#QName_Token_Handling">QName Token Handling</a></li></ul></li></ul></dt></dl><dl><dt><b>Technical Details</b><ul><li><a href="MemoryOptimisation.html">Memory Optimisation</a><ul><li><a href="MemoryOptimisation.html#Disclaimer">Disclaimer</a></li><li><a href="MemoryOptimisation.html#Introduction">Introduction</a></li><li><a href="MemoryOptimisation.html#Options_for_memory_optimisation">Options for memory optimisation</a></li><li><a href="MemoryOptimisation.html#Resulting_Sizes">Resulting Sizes</a></li><li><a href="MemoryOptimisation.html#Memory_Consumption_During_Parsing">Memory Consumption During Parsing</a></li><li><a href="MemoryOptimisation.html#Overall_Parsing_Performance">Overall Parsing Performance</a></li><li><a href="MemoryOptimisation.html#Special_Case_-_Pull_Parsing_via_onQNames">Special Case - Pull Parsing via onQNames</a></li></ul></li><li><a href="OptimisationDetails.html">General Memory Optimisation Details</a><ul><li><a href="OptimisationDetails.html#ImmutableArrayProxy">ImmutableArrayProxy</a></li><li><a href="OptimisationDetails.html#EitherLike">EitherLike</a></li><li><a href="OptimisationDetails.html#TreeOptimisation">TreeOptimisation</a></li><li><a href="OptimisationDetails.html#QName_and_Elem_Memory_Usage">QName and Elem Memory Usage</a></li><li><a href="OptimisationDetails.html#TreeProxies_and_Builders">TreeProxies and Builders</a></li></ul></li><li><a href="Serialization.html">Serializing Details</a><ul><li><a href="Serialization.html#Encoding">Encoding</a><ul><li><a href="Serialization.html#XML_Names">XML Names</a></li><li><a href="Serialization.html#Text_Data">Text Data</a></li><li><a href="Serialization.html#Other_Markup_Character_Data">Other Markup Character Data</a></li></ul></li><li><a href="Serialization.html#Creating_a_SerializerFactory">Creating a SerializerFactory</a></li></ul></li></ul></dt></dl></div></body></html>